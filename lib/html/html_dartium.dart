#library('html');

#import('dart:dom', prefix:'dom');
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// DO NOT EDIT
// Auto-generated dart:html library.






_WindowImpl __window;
_DocumentImpl __document;

void _initialize() {
  __window = _wrap(dom.window);
  __document = _wrap(dom.document.documentElement);
}

Window get window() {
  if (__window == null) {
    _initialize();
  }
  return __window;
}

Document get document() {
  if (__document == null) {
    _initialize();
  }
  return __document;
}

_WindowImpl get _window() {
  if (__window == null) {
    _initialize();
  }
  return __window;
}

_DocumentImpl get _document() {
  if (__document == null) {
    _initialize();
  }
  return __document;
}

_unwrap(raw) {
  return raw is _DOMTypeBase ? raw._ptr : raw;
}

// Warning: does not attempt wrap event listeners.
_wrap(raw) {
  if (raw is! dom.DOMType) return raw;
  dom.DOMType domObject = raw;
  if (domObject.dartObjectLocalStorage != null)
    return domObject.dartObjectLocalStorage;
  switch(domObject.typeName) {
    case 'HTMLDocument':
      throw 'A document should never be wrapped directly. TODO(jacobr) XXX';
    case 'HTMLHtmlElement':
      return new _DocumentImpl._wrap(domObject);
    case 'HTMLElement':
      return new _UnknownElementImpl._wrap(domObject);
    case "EventTarget": return new _EventTargetImpl._wrap(domObject);
    case "AbstractWorker": return new _AbstractWorkerImpl._wrap(domObject);
    case "Node": return new _NodeImpl._wrap(domObject);
    case "NodeSelector": return new _NodeSelectorImpl._wrap(domObject);
    case "ElementTraversal": return new _ElementTraversalImpl._wrap(domObject);
    case "Element": return new _ElementImpl._wrap(domObject);
    case "HTMLAnchorElement": return new _AnchorElementImpl._wrap(domObject);
    case "WebKitAnimation": return new _AnimationImpl._wrap(domObject);
    case "Event": return new _EventImpl._wrap(domObject);
    case "WebKitAnimationEvent": return new _AnimationEventImpl._wrap(domObject);
    case "WebKitAnimationList": return new _AnimationListImpl._wrap(domObject);
    case "HTMLAppletElement": return new _AppletElementImpl._wrap(domObject);
    case "HTMLAreaElement": return new _AreaElementImpl._wrap(domObject);
    case "ArrayBuffer": return new _ArrayBufferImpl._wrap(domObject);
    case "ArrayBufferView": return new _ArrayBufferViewImpl._wrap(domObject);
    case "Attr": return new _AttrImpl._wrap(domObject);
    case "AudioBuffer": return new _AudioBufferImpl._wrap(domObject);
    case "AudioNode": return new _AudioNodeImpl._wrap(domObject);
    case "AudioSourceNode": return new _AudioSourceNodeImpl._wrap(domObject);
    case "AudioBufferSourceNode": return new _AudioBufferSourceNodeImpl._wrap(domObject);
    case "AudioChannelMerger": return new _AudioChannelMergerImpl._wrap(domObject);
    case "AudioChannelSplitter": return new _AudioChannelSplitterImpl._wrap(domObject);
    case "AudioContext": return new _AudioContextImpl._wrap(domObject);
    case "AudioDestinationNode": return new _AudioDestinationNodeImpl._wrap(domObject);
    case "HTMLMediaElement": return new _MediaElementImpl._wrap(domObject);
    case "HTMLAudioElement": return new _AudioElementImpl._wrap(domObject);
    case "AudioParam": return new _AudioParamImpl._wrap(domObject);
    case "AudioGain": return new _AudioGainImpl._wrap(domObject);
    case "AudioGainNode": return new _AudioGainNodeImpl._wrap(domObject);
    case "AudioListener": return new _AudioListenerImpl._wrap(domObject);
    case "AudioPannerNode": return new _AudioPannerNodeImpl._wrap(domObject);
    case "AudioProcessingEvent": return new _AudioProcessingEventImpl._wrap(domObject);
    case "HTMLBRElement": return new _BRElementImpl._wrap(domObject);
    case "BarInfo": return new _BarInfoImpl._wrap(domObject);
    case "HTMLBaseElement": return new _BaseElementImpl._wrap(domObject);
    case "HTMLBaseFontElement": return new _BaseFontElementImpl._wrap(domObject);
    case "BeforeLoadEvent": return new _BeforeLoadEventImpl._wrap(domObject);
    case "BiquadFilterNode": return new _BiquadFilterNodeImpl._wrap(domObject);
    case "Blob": return new _BlobImpl._wrap(domObject);
    case "WebKitBlobBuilder": return new _BlobBuilderImpl._wrap(domObject);
    case "HTMLBodyElement": return new _BodyElementImpl._wrap(domObject);
    case "HTMLButtonElement": return new _ButtonElementImpl._wrap(domObject);
    case "CharacterData": return new _CharacterDataImpl._wrap(domObject);
    case "Text": return new _TextImpl._wrap(domObject);
    case "CDATASection": return new _CDATASectionImpl._wrap(domObject);
    case "CSSRule": return new _CSSRuleImpl._wrap(domObject);
    case "CSSCharsetRule": return new _CSSCharsetRuleImpl._wrap(domObject);
    case "CSSFontFaceRule": return new _CSSFontFaceRuleImpl._wrap(domObject);
    case "CSSImportRule": return new _CSSImportRuleImpl._wrap(domObject);
    case "WebKitCSSKeyframeRule": return new _CSSKeyframeRuleImpl._wrap(domObject);
    case "WebKitCSSKeyframesRule": return new _CSSKeyframesRuleImpl._wrap(domObject);
    case "WebKitCSSMatrix": return new _CSSMatrixImpl._wrap(domObject);
    case "CSSMediaRule": return new _CSSMediaRuleImpl._wrap(domObject);
    case "CSSPageRule": return new _CSSPageRuleImpl._wrap(domObject);
    case "CSSValue": return new _CSSValueImpl._wrap(domObject);
    case "CSSPrimitiveValue": return new _CSSPrimitiveValueImpl._wrap(domObject);
    case "CSSRuleList": return new _CSSRuleListImpl._wrap(domObject);
    case "CSSStyleDeclaration": return new _CSSStyleDeclarationImpl._wrap(domObject);
    case "CSSStyleRule": return new _CSSStyleRuleImpl._wrap(domObject);
    case "StyleSheet": return new _StyleSheetImpl._wrap(domObject);
    case "CSSStyleSheet": return new _CSSStyleSheetImpl._wrap(domObject);
    case "CSSValueList": return new _CSSValueListImpl._wrap(domObject);
    case "WebKitCSSTransformValue": return new _CSSTransformValueImpl._wrap(domObject);
    case "CSSUnknownRule": return new _CSSUnknownRuleImpl._wrap(domObject);
    case "HTMLCanvasElement": return new _CanvasElementImpl._wrap(domObject);
    case "CanvasGradient": return new _CanvasGradientImpl._wrap(domObject);
    case "CanvasPattern": return new _CanvasPatternImpl._wrap(domObject);
    case "CanvasPixelArray": return new _CanvasPixelArrayImpl._wrap(domObject);
    case "CanvasRenderingContext": return new _CanvasRenderingContextImpl._wrap(domObject);
    case "CanvasRenderingContext2D": return new _CanvasRenderingContext2DImpl._wrap(domObject);
    case "ClientRect": return new _ClientRectImpl._wrap(domObject);
    case "ClientRectList": return new _ClientRectListImpl._wrap(domObject);
    case "Clipboard": return new _ClipboardImpl._wrap(domObject);
    case "CloseEvent": return new _CloseEventImpl._wrap(domObject);
    case "Comment": return new _CommentImpl._wrap(domObject);
    case "UIEvent": return new _UIEventImpl._wrap(domObject);
    case "CompositionEvent": return new _CompositionEventImpl._wrap(domObject);
    case "Console": return new _ConsoleImpl._wrap(domObject);
    case "HTMLContentElement": return new _ContentElementImpl._wrap(domObject);
    case "ConvolverNode": return new _ConvolverNodeImpl._wrap(domObject);
    case "Coordinates": return new _CoordinatesImpl._wrap(domObject);
    case "Counter": return new _CounterImpl._wrap(domObject);
    case "Crypto": return new _CryptoImpl._wrap(domObject);
    case "CustomEvent": return new _CustomEventImpl._wrap(domObject);
    case "HTMLDListElement": return new _DListElementImpl._wrap(domObject);
    case "DOMApplicationCache": return new _DOMApplicationCacheImpl._wrap(domObject);
    case "DOMException": return new _DOMExceptionImpl._wrap(domObject);
    case "DOMFileSystem": return new _DOMFileSystemImpl._wrap(domObject);
    case "DOMFileSystemSync": return new _DOMFileSystemSyncImpl._wrap(domObject);
    case "DOMFormData": return new _DOMFormDataImpl._wrap(domObject);
    case "DOMImplementation": return new _DOMImplementationImpl._wrap(domObject);
    case "DOMMimeType": return new _DOMMimeTypeImpl._wrap(domObject);
    case "DOMMimeTypeArray": return new _DOMMimeTypeArrayImpl._wrap(domObject);
    case "DOMParser": return new _DOMParserImpl._wrap(domObject);
    case "DOMPlugin": return new _DOMPluginImpl._wrap(domObject);
    case "DOMPluginArray": return new _DOMPluginArrayImpl._wrap(domObject);
    case "DOMSelection": return new _DOMSelectionImpl._wrap(domObject);
    case "DOMTokenList": return new _DOMTokenListImpl._wrap(domObject);
    case "DOMSettableTokenList": return new _DOMSettableTokenListImpl._wrap(domObject);
    case "DOMURL": return new _DOMURLImpl._wrap(domObject);
    case "DataTransferItem": return new _DataTransferItemImpl._wrap(domObject);
    case "DataTransferItemList": return new _DataTransferItemListImpl._wrap(domObject);
    case "DataView": return new _DataViewImpl._wrap(domObject);
    case "Database": return new _DatabaseImpl._wrap(domObject);
    case "DatabaseSync": return new _DatabaseSyncImpl._wrap(domObject);
    case "WorkerContext": return new _WorkerContextImpl._wrap(domObject);
    case "DedicatedWorkerContext": return new _DedicatedWorkerContextImpl._wrap(domObject);
    case "DelayNode": return new _DelayNodeImpl._wrap(domObject);
    case "DeprecatedPeerConnection": return new _DeprecatedPeerConnectionImpl._wrap(domObject);
    case "HTMLDetailsElement": return new _DetailsElementImpl._wrap(domObject);
    case "DeviceMotionEvent": return new _DeviceMotionEventImpl._wrap(domObject);
    case "DeviceOrientationEvent": return new _DeviceOrientationEventImpl._wrap(domObject);
    case "HTMLDirectoryElement": return new _DirectoryElementImpl._wrap(domObject);
    case "Entry": return new _EntryImpl._wrap(domObject);
    case "DirectoryEntry": return new _DirectoryEntryImpl._wrap(domObject);
    case "EntrySync": return new _EntrySyncImpl._wrap(domObject);
    case "DirectoryEntrySync": return new _DirectoryEntrySyncImpl._wrap(domObject);
    case "DirectoryReader": return new _DirectoryReaderImpl._wrap(domObject);
    case "DirectoryReaderSync": return new _DirectoryReaderSyncImpl._wrap(domObject);
    case "HTMLDivElement": return new _DivElementImpl._wrap(domObject);
    case "DocumentFragment": return new _DocumentFragmentImpl._wrap(domObject);
    case "DocumentType": return new _DocumentTypeImpl._wrap(domObject);
    case "DynamicsCompressorNode": return new _DynamicsCompressorNodeImpl._wrap(domObject);
    case "EXTTextureFilterAnisotropic": return new _EXTTextureFilterAnisotropicImpl._wrap(domObject);
    case "ElementTimeControl": return new _ElementTimeControlImpl._wrap(domObject);
    case "HTMLEmbedElement": return new _EmbedElementImpl._wrap(domObject);
    case "Entity": return new _EntityImpl._wrap(domObject);
    case "EntityReference": return new _EntityReferenceImpl._wrap(domObject);
    case "EntryArray": return new _EntryArrayImpl._wrap(domObject);
    case "EntryArraySync": return new _EntryArraySyncImpl._wrap(domObject);
    case "ErrorEvent": return new _ErrorEventImpl._wrap(domObject);
    case "EventException": return new _EventExceptionImpl._wrap(domObject);
    case "EventSource": return new _EventSourceImpl._wrap(domObject);
    case "HTMLFieldSetElement": return new _FieldSetElementImpl._wrap(domObject);
    case "File": return new _FileImpl._wrap(domObject);
    case "FileEntry": return new _FileEntryImpl._wrap(domObject);
    case "FileEntrySync": return new _FileEntrySyncImpl._wrap(domObject);
    case "FileError": return new _FileErrorImpl._wrap(domObject);
    case "FileException": return new _FileExceptionImpl._wrap(domObject);
    case "FileList": return new _FileListImpl._wrap(domObject);
    case "FileReader": return new _FileReaderImpl._wrap(domObject);
    case "FileReaderSync": return new _FileReaderSyncImpl._wrap(domObject);
    case "FileWriter": return new _FileWriterImpl._wrap(domObject);
    case "FileWriterSync": return new _FileWriterSyncImpl._wrap(domObject);
    case "Float32Array": return new _Float32ArrayImpl._wrap(domObject);
    case "Float64Array": return new _Float64ArrayImpl._wrap(domObject);
    case "HTMLFontElement": return new _FontElementImpl._wrap(domObject);
    case "HTMLFormElement": return new _FormElementImpl._wrap(domObject);
    case "HTMLFrameElement": return new _FrameElementImpl._wrap(domObject);
    case "HTMLFrameSetElement": return new _FrameSetElementImpl._wrap(domObject);
    case "Geolocation": return new _GeolocationImpl._wrap(domObject);
    case "Geoposition": return new _GeopositionImpl._wrap(domObject);
    case "HTMLHRElement": return new _HRElementImpl._wrap(domObject);
    case "HTMLAllCollection": return new _HTMLAllCollectionImpl._wrap(domObject);
    case "HTMLCollection": return new _HTMLCollectionImpl._wrap(domObject);
    case "HTMLOptionsCollection": return new _HTMLOptionsCollectionImpl._wrap(domObject);
    case "HashChangeEvent": return new _HashChangeEventImpl._wrap(domObject);
    case "HTMLHeadElement": return new _HeadElementImpl._wrap(domObject);
    case "HTMLHeadingElement": return new _HeadingElementImpl._wrap(domObject);
    case "HighPass2FilterNode": return new _HighPass2FilterNodeImpl._wrap(domObject);
    case "History": return new _HistoryImpl._wrap(domObject);
    case "IDBAny": return new _IDBAnyImpl._wrap(domObject);
    case "IDBCursor": return new _IDBCursorImpl._wrap(domObject);
    case "IDBCursorWithValue": return new _IDBCursorWithValueImpl._wrap(domObject);
    case "IDBDatabase": return new _IDBDatabaseImpl._wrap(domObject);
    case "IDBDatabaseError": return new _IDBDatabaseErrorImpl._wrap(domObject);
    case "IDBDatabaseException": return new _IDBDatabaseExceptionImpl._wrap(domObject);
    case "IDBFactory": return new _IDBFactoryImpl._wrap(domObject);
    case "IDBIndex": return new _IDBIndexImpl._wrap(domObject);
    case "IDBKey": return new _IDBKeyImpl._wrap(domObject);
    case "IDBKeyRange": return new _IDBKeyRangeImpl._wrap(domObject);
    case "IDBObjectStore": return new _IDBObjectStoreImpl._wrap(domObject);
    case "IDBRequest": return new _IDBRequestImpl._wrap(domObject);
    case "IDBTransaction": return new _IDBTransactionImpl._wrap(domObject);
    case "IDBVersionChangeEvent": return new _IDBVersionChangeEventImpl._wrap(domObject);
    case "IDBVersionChangeRequest": return new _IDBVersionChangeRequestImpl._wrap(domObject);
    case "HTMLIFrameElement": return new _IFrameElementImpl._wrap(domObject);
    case "IceCandidate": return new _IceCandidateImpl._wrap(domObject);
    case "ImageData": return new _ImageDataImpl._wrap(domObject);
    case "HTMLImageElement": return new _ImageElementImpl._wrap(domObject);
    case "HTMLInputElement": return new _InputElementImpl._wrap(domObject);
    case "Int16Array": return new _Int16ArrayImpl._wrap(domObject);
    case "Int32Array": return new _Int32ArrayImpl._wrap(domObject);
    case "Int8Array": return new _Int8ArrayImpl._wrap(domObject);
    case "JavaScriptAudioNode": return new _JavaScriptAudioNodeImpl._wrap(domObject);
    case "JavaScriptCallFrame": return new _JavaScriptCallFrameImpl._wrap(domObject);
    case "KeyboardEvent": return new _KeyboardEventImpl._wrap(domObject);
    case "HTMLKeygenElement": return new _KeygenElementImpl._wrap(domObject);
    case "HTMLLIElement": return new _LIElementImpl._wrap(domObject);
    case "HTMLLabelElement": return new _LabelElementImpl._wrap(domObject);
    case "HTMLLegendElement": return new _LegendElementImpl._wrap(domObject);
    case "HTMLLinkElement": return new _LinkElementImpl._wrap(domObject);
    case "MediaStream": return new _MediaStreamImpl._wrap(domObject);
    case "LocalMediaStream": return new _LocalMediaStreamImpl._wrap(domObject);
    case "Location": return new _LocationImpl._wrap(domObject);
    case "LowPass2FilterNode": return new _LowPass2FilterNodeImpl._wrap(domObject);
    case "HTMLMapElement": return new _MapElementImpl._wrap(domObject);
    case "HTMLMarqueeElement": return new _MarqueeElementImpl._wrap(domObject);
    case "MediaController": return new _MediaControllerImpl._wrap(domObject);
    case "MediaElementAudioSourceNode": return new _MediaElementAudioSourceNodeImpl._wrap(domObject);
    case "MediaError": return new _MediaErrorImpl._wrap(domObject);
    case "MediaList": return new _MediaListImpl._wrap(domObject);
    case "MediaQueryList": return new _MediaQueryListImpl._wrap(domObject);
    case "MediaQueryListListener": return new _MediaQueryListListenerImpl._wrap(domObject);
    case "MediaStreamEvent": return new _MediaStreamEventImpl._wrap(domObject);
    case "MediaStreamList": return new _MediaStreamListImpl._wrap(domObject);
    case "MediaStreamTrack": return new _MediaStreamTrackImpl._wrap(domObject);
    case "MediaStreamTrackList": return new _MediaStreamTrackListImpl._wrap(domObject);
    case "MemoryInfo": return new _MemoryInfoImpl._wrap(domObject);
    case "HTMLMenuElement": return new _MenuElementImpl._wrap(domObject);
    case "MessageChannel": return new _MessageChannelImpl._wrap(domObject);
    case "MessageEvent": return new _MessageEventImpl._wrap(domObject);
    case "MessagePort": return new _MessagePortImpl._wrap(domObject);
    case "HTMLMetaElement": return new _MetaElementImpl._wrap(domObject);
    case "Metadata": return new _MetadataImpl._wrap(domObject);
    case "HTMLMeterElement": return new _MeterElementImpl._wrap(domObject);
    case "HTMLModElement": return new _ModElementImpl._wrap(domObject);
    case "MouseEvent": return new _MouseEventImpl._wrap(domObject);
    case "MutationEvent": return new _MutationEventImpl._wrap(domObject);
    case "NamedNodeMap": return new _NamedNodeMapImpl._wrap(domObject);
    case "Navigator": return new _NavigatorImpl._wrap(domObject);
    case "NavigatorUserMediaError": return new _NavigatorUserMediaErrorImpl._wrap(domObject);
    case "NodeFilter": return new _NodeFilterImpl._wrap(domObject);
    case "NodeIterator": return new _NodeIteratorImpl._wrap(domObject);
    case "NodeList": return new _NodeListImpl._wrap(domObject);
    case "Notation": return new _NotationImpl._wrap(domObject);
    case "Notification": return new _NotificationImpl._wrap(domObject);
    case "NotificationCenter": return new _NotificationCenterImpl._wrap(domObject);
    case "OESStandardDerivatives": return new _OESStandardDerivativesImpl._wrap(domObject);
    case "OESTextureFloat": return new _OESTextureFloatImpl._wrap(domObject);
    case "OESVertexArrayObject": return new _OESVertexArrayObjectImpl._wrap(domObject);
    case "HTMLOListElement": return new _OListElementImpl._wrap(domObject);
    case "HTMLObjectElement": return new _ObjectElementImpl._wrap(domObject);
    case "OfflineAudioCompletionEvent": return new _OfflineAudioCompletionEventImpl._wrap(domObject);
    case "OperationNotAllowedException": return new _OperationNotAllowedExceptionImpl._wrap(domObject);
    case "HTMLOptGroupElement": return new _OptGroupElementImpl._wrap(domObject);
    case "HTMLOptionElement": return new _OptionElementImpl._wrap(domObject);
    case "HTMLOutputElement": return new _OutputElementImpl._wrap(domObject);
    case "OverflowEvent": return new _OverflowEventImpl._wrap(domObject);
    case "PageTransitionEvent": return new _PageTransitionEventImpl._wrap(domObject);
    case "HTMLParagraphElement": return new _ParagraphElementImpl._wrap(domObject);
    case "HTMLParamElement": return new _ParamElementImpl._wrap(domObject);
    case "Performance": return new _PerformanceImpl._wrap(domObject);
    case "PerformanceNavigation": return new _PerformanceNavigationImpl._wrap(domObject);
    case "PerformanceTiming": return new _PerformanceTimingImpl._wrap(domObject);
    case "WebKitPoint": return new _PointImpl._wrap(domObject);
    case "PopStateEvent": return new _PopStateEventImpl._wrap(domObject);
    case "PositionError": return new _PositionErrorImpl._wrap(domObject);
    case "HTMLPreElement": return new _PreElementImpl._wrap(domObject);
    case "ProcessingInstruction": return new _ProcessingInstructionImpl._wrap(domObject);
    case "HTMLProgressElement": return new _ProgressElementImpl._wrap(domObject);
    case "ProgressEvent": return new _ProgressEventImpl._wrap(domObject);
    case "HTMLQuoteElement": return new _QuoteElementImpl._wrap(domObject);
    case "RGBColor": return new _RGBColorImpl._wrap(domObject);
    case "Range": return new _RangeImpl._wrap(domObject);
    case "RangeException": return new _RangeExceptionImpl._wrap(domObject);
    case "RealtimeAnalyserNode": return new _RealtimeAnalyserNodeImpl._wrap(domObject);
    case "Rect": return new _RectImpl._wrap(domObject);
    case "SQLError": return new _SQLErrorImpl._wrap(domObject);
    case "SQLException": return new _SQLExceptionImpl._wrap(domObject);
    case "SQLResultSet": return new _SQLResultSetImpl._wrap(domObject);
    case "SQLResultSetRowList": return new _SQLResultSetRowListImpl._wrap(domObject);
    case "SQLTransaction": return new _SQLTransactionImpl._wrap(domObject);
    case "SQLTransactionSync": return new _SQLTransactionSyncImpl._wrap(domObject);
    case "SVGElement": return new _SVGElementImpl._wrap(domObject);
    case "SVGURIReference": return new _SVGURIReferenceImpl._wrap(domObject);
    case "SVGTests": return new _SVGTestsImpl._wrap(domObject);
    case "SVGLangSpace": return new _SVGLangSpaceImpl._wrap(domObject);
    case "SVGExternalResourcesRequired": return new _SVGExternalResourcesRequiredImpl._wrap(domObject);
    case "SVGStylable": return new _SVGStylableImpl._wrap(domObject);
    case "SVGLocatable": return new _SVGLocatableImpl._wrap(domObject);
    case "SVGTransformable": return new _SVGTransformableImpl._wrap(domObject);
    case "SVGAElement": return new _SVGAElementImpl._wrap(domObject);
    case "SVGAltGlyphDefElement": return new _SVGAltGlyphDefElementImpl._wrap(domObject);
    case "SVGTextContentElement": return new _SVGTextContentElementImpl._wrap(domObject);
    case "SVGTextPositioningElement": return new _SVGTextPositioningElementImpl._wrap(domObject);
    case "SVGAltGlyphElement": return new _SVGAltGlyphElementImpl._wrap(domObject);
    case "SVGAltGlyphItemElement": return new _SVGAltGlyphItemElementImpl._wrap(domObject);
    case "SVGAngle": return new _SVGAngleImpl._wrap(domObject);
    case "SVGAnimationElement": return new _SVGAnimationElementImpl._wrap(domObject);
    case "SVGAnimateColorElement": return new _SVGAnimateColorElementImpl._wrap(domObject);
    case "SVGAnimateElement": return new _SVGAnimateElementImpl._wrap(domObject);
    case "SVGAnimateMotionElement": return new _SVGAnimateMotionElementImpl._wrap(domObject);
    case "SVGAnimateTransformElement": return new _SVGAnimateTransformElementImpl._wrap(domObject);
    case "SVGAnimatedAngle": return new _SVGAnimatedAngleImpl._wrap(domObject);
    case "SVGAnimatedBoolean": return new _SVGAnimatedBooleanImpl._wrap(domObject);
    case "SVGAnimatedEnumeration": return new _SVGAnimatedEnumerationImpl._wrap(domObject);
    case "SVGAnimatedInteger": return new _SVGAnimatedIntegerImpl._wrap(domObject);
    case "SVGAnimatedLength": return new _SVGAnimatedLengthImpl._wrap(domObject);
    case "SVGAnimatedLengthList": return new _SVGAnimatedLengthListImpl._wrap(domObject);
    case "SVGAnimatedNumber": return new _SVGAnimatedNumberImpl._wrap(domObject);
    case "SVGAnimatedNumberList": return new _SVGAnimatedNumberListImpl._wrap(domObject);
    case "SVGAnimatedPreserveAspectRatio": return new _SVGAnimatedPreserveAspectRatioImpl._wrap(domObject);
    case "SVGAnimatedRect": return new _SVGAnimatedRectImpl._wrap(domObject);
    case "SVGAnimatedString": return new _SVGAnimatedStringImpl._wrap(domObject);
    case "SVGAnimatedTransformList": return new _SVGAnimatedTransformListImpl._wrap(domObject);
    case "SVGCircleElement": return new _SVGCircleElementImpl._wrap(domObject);
    case "SVGClipPathElement": return new _SVGClipPathElementImpl._wrap(domObject);
    case "SVGColor": return new _SVGColorImpl._wrap(domObject);
    case "SVGComponentTransferFunctionElement": return new _SVGComponentTransferFunctionElementImpl._wrap(domObject);
    case "SVGCursorElement": return new _SVGCursorElementImpl._wrap(domObject);
    case "SVGDefsElement": return new _SVGDefsElementImpl._wrap(domObject);
    case "SVGDescElement": return new _SVGDescElementImpl._wrap(domObject);
    case "SVGDocument": return new _SVGDocumentImpl._wrap(domObject);
    case "SVGElementInstance": return new _SVGElementInstanceImpl._wrap(domObject);
    case "SVGElementInstanceList": return new _SVGElementInstanceListImpl._wrap(domObject);
    case "SVGEllipseElement": return new _SVGEllipseElementImpl._wrap(domObject);
    case "SVGException": return new _SVGExceptionImpl._wrap(domObject);
    case "SVGFilterPrimitiveStandardAttributes": return new _SVGFilterPrimitiveStandardAttributesImpl._wrap(domObject);
    case "SVGFEBlendElement": return new _SVGFEBlendElementImpl._wrap(domObject);
    case "SVGFEColorMatrixElement": return new _SVGFEColorMatrixElementImpl._wrap(domObject);
    case "SVGFEComponentTransferElement": return new _SVGFEComponentTransferElementImpl._wrap(domObject);
    case "SVGFECompositeElement": return new _SVGFECompositeElementImpl._wrap(domObject);
    case "SVGFEConvolveMatrixElement": return new _SVGFEConvolveMatrixElementImpl._wrap(domObject);
    case "SVGFEDiffuseLightingElement": return new _SVGFEDiffuseLightingElementImpl._wrap(domObject);
    case "SVGFEDisplacementMapElement": return new _SVGFEDisplacementMapElementImpl._wrap(domObject);
    case "SVGFEDistantLightElement": return new _SVGFEDistantLightElementImpl._wrap(domObject);
    case "SVGFEDropShadowElement": return new _SVGFEDropShadowElementImpl._wrap(domObject);
    case "SVGFEFloodElement": return new _SVGFEFloodElementImpl._wrap(domObject);
    case "SVGFEFuncAElement": return new _SVGFEFuncAElementImpl._wrap(domObject);
    case "SVGFEFuncBElement": return new _SVGFEFuncBElementImpl._wrap(domObject);
    case "SVGFEFuncGElement": return new _SVGFEFuncGElementImpl._wrap(domObject);
    case "SVGFEFuncRElement": return new _SVGFEFuncRElementImpl._wrap(domObject);
    case "SVGFEGaussianBlurElement": return new _SVGFEGaussianBlurElementImpl._wrap(domObject);
    case "SVGFEImageElement": return new _SVGFEImageElementImpl._wrap(domObject);
    case "SVGFEMergeElement": return new _SVGFEMergeElementImpl._wrap(domObject);
    case "SVGFEMergeNodeElement": return new _SVGFEMergeNodeElementImpl._wrap(domObject);
    case "SVGFEMorphologyElement": return new _SVGFEMorphologyElementImpl._wrap(domObject);
    case "SVGFEOffsetElement": return new _SVGFEOffsetElementImpl._wrap(domObject);
    case "SVGFEPointLightElement": return new _SVGFEPointLightElementImpl._wrap(domObject);
    case "SVGFESpecularLightingElement": return new _SVGFESpecularLightingElementImpl._wrap(domObject);
    case "SVGFESpotLightElement": return new _SVGFESpotLightElementImpl._wrap(domObject);
    case "SVGFETileElement": return new _SVGFETileElementImpl._wrap(domObject);
    case "SVGFETurbulenceElement": return new _SVGFETurbulenceElementImpl._wrap(domObject);
    case "SVGFilterElement": return new _SVGFilterElementImpl._wrap(domObject);
    case "SVGFitToViewBox": return new _SVGFitToViewBoxImpl._wrap(domObject);
    case "SVGFontElement": return new _SVGFontElementImpl._wrap(domObject);
    case "SVGFontFaceElement": return new _SVGFontFaceElementImpl._wrap(domObject);
    case "SVGFontFaceFormatElement": return new _SVGFontFaceFormatElementImpl._wrap(domObject);
    case "SVGFontFaceNameElement": return new _SVGFontFaceNameElementImpl._wrap(domObject);
    case "SVGFontFaceSrcElement": return new _SVGFontFaceSrcElementImpl._wrap(domObject);
    case "SVGFontFaceUriElement": return new _SVGFontFaceUriElementImpl._wrap(domObject);
    case "SVGForeignObjectElement": return new _SVGForeignObjectElementImpl._wrap(domObject);
    case "SVGGElement": return new _SVGGElementImpl._wrap(domObject);
    case "SVGGlyphElement": return new _SVGGlyphElementImpl._wrap(domObject);
    case "SVGGlyphRefElement": return new _SVGGlyphRefElementImpl._wrap(domObject);
    case "SVGGradientElement": return new _SVGGradientElementImpl._wrap(domObject);
    case "SVGHKernElement": return new _SVGHKernElementImpl._wrap(domObject);
    case "SVGImageElement": return new _SVGImageElementImpl._wrap(domObject);
    case "SVGLength": return new _SVGLengthImpl._wrap(domObject);
    case "SVGLengthList": return new _SVGLengthListImpl._wrap(domObject);
    case "SVGLineElement": return new _SVGLineElementImpl._wrap(domObject);
    case "SVGLinearGradientElement": return new _SVGLinearGradientElementImpl._wrap(domObject);
    case "SVGMPathElement": return new _SVGMPathElementImpl._wrap(domObject);
    case "SVGMarkerElement": return new _SVGMarkerElementImpl._wrap(domObject);
    case "SVGMaskElement": return new _SVGMaskElementImpl._wrap(domObject);
    case "SVGMatrix": return new _SVGMatrixImpl._wrap(domObject);
    case "SVGMetadataElement": return new _SVGMetadataElementImpl._wrap(domObject);
    case "SVGMissingGlyphElement": return new _SVGMissingGlyphElementImpl._wrap(domObject);
    case "SVGNumber": return new _SVGNumberImpl._wrap(domObject);
    case "SVGNumberList": return new _SVGNumberListImpl._wrap(domObject);
    case "SVGPaint": return new _SVGPaintImpl._wrap(domObject);
    case "SVGPathElement": return new _SVGPathElementImpl._wrap(domObject);
    case "SVGPathSeg": return new _SVGPathSegImpl._wrap(domObject);
    case "SVGPathSegArcAbs": return new _SVGPathSegArcAbsImpl._wrap(domObject);
    case "SVGPathSegArcRel": return new _SVGPathSegArcRelImpl._wrap(domObject);
    case "SVGPathSegClosePath": return new _SVGPathSegClosePathImpl._wrap(domObject);
    case "SVGPathSegCurvetoCubicAbs": return new _SVGPathSegCurvetoCubicAbsImpl._wrap(domObject);
    case "SVGPathSegCurvetoCubicRel": return new _SVGPathSegCurvetoCubicRelImpl._wrap(domObject);
    case "SVGPathSegCurvetoCubicSmoothAbs": return new _SVGPathSegCurvetoCubicSmoothAbsImpl._wrap(domObject);
    case "SVGPathSegCurvetoCubicSmoothRel": return new _SVGPathSegCurvetoCubicSmoothRelImpl._wrap(domObject);
    case "SVGPathSegCurvetoQuadraticAbs": return new _SVGPathSegCurvetoQuadraticAbsImpl._wrap(domObject);
    case "SVGPathSegCurvetoQuadraticRel": return new _SVGPathSegCurvetoQuadraticRelImpl._wrap(domObject);
    case "SVGPathSegCurvetoQuadraticSmoothAbs": return new _SVGPathSegCurvetoQuadraticSmoothAbsImpl._wrap(domObject);
    case "SVGPathSegCurvetoQuadraticSmoothRel": return new _SVGPathSegCurvetoQuadraticSmoothRelImpl._wrap(domObject);
    case "SVGPathSegLinetoAbs": return new _SVGPathSegLinetoAbsImpl._wrap(domObject);
    case "SVGPathSegLinetoHorizontalAbs": return new _SVGPathSegLinetoHorizontalAbsImpl._wrap(domObject);
    case "SVGPathSegLinetoHorizontalRel": return new _SVGPathSegLinetoHorizontalRelImpl._wrap(domObject);
    case "SVGPathSegLinetoRel": return new _SVGPathSegLinetoRelImpl._wrap(domObject);
    case "SVGPathSegLinetoVerticalAbs": return new _SVGPathSegLinetoVerticalAbsImpl._wrap(domObject);
    case "SVGPathSegLinetoVerticalRel": return new _SVGPathSegLinetoVerticalRelImpl._wrap(domObject);
    case "SVGPathSegList": return new _SVGPathSegListImpl._wrap(domObject);
    case "SVGPathSegMovetoAbs": return new _SVGPathSegMovetoAbsImpl._wrap(domObject);
    case "SVGPathSegMovetoRel": return new _SVGPathSegMovetoRelImpl._wrap(domObject);
    case "SVGPatternElement": return new _SVGPatternElementImpl._wrap(domObject);
    case "SVGPoint": return new _SVGPointImpl._wrap(domObject);
    case "SVGPointList": return new _SVGPointListImpl._wrap(domObject);
    case "SVGPolygonElement": return new _SVGPolygonElementImpl._wrap(domObject);
    case "SVGPolylineElement": return new _SVGPolylineElementImpl._wrap(domObject);
    case "SVGPreserveAspectRatio": return new _SVGPreserveAspectRatioImpl._wrap(domObject);
    case "SVGRadialGradientElement": return new _SVGRadialGradientElementImpl._wrap(domObject);
    case "SVGRect": return new _SVGRectImpl._wrap(domObject);
    case "SVGRectElement": return new _SVGRectElementImpl._wrap(domObject);
    case "SVGRenderingIntent": return new _SVGRenderingIntentImpl._wrap(domObject);
    case "SVGZoomAndPan": return new _SVGZoomAndPanImpl._wrap(domObject);
    case "SVGSVGElement": return new _SVGSVGElementImpl._wrap(domObject);
    case "SVGScriptElement": return new _SVGScriptElementImpl._wrap(domObject);
    case "SVGSetElement": return new _SVGSetElementImpl._wrap(domObject);
    case "SVGStopElement": return new _SVGStopElementImpl._wrap(domObject);
    case "SVGStringList": return new _SVGStringListImpl._wrap(domObject);
    case "SVGStyleElement": return new _SVGStyleElementImpl._wrap(domObject);
    case "SVGSwitchElement": return new _SVGSwitchElementImpl._wrap(domObject);
    case "SVGSymbolElement": return new _SVGSymbolElementImpl._wrap(domObject);
    case "SVGTRefElement": return new _SVGTRefElementImpl._wrap(domObject);
    case "SVGTSpanElement": return new _SVGTSpanElementImpl._wrap(domObject);
    case "SVGTextElement": return new _SVGTextElementImpl._wrap(domObject);
    case "SVGTextPathElement": return new _SVGTextPathElementImpl._wrap(domObject);
    case "SVGTitleElement": return new _SVGTitleElementImpl._wrap(domObject);
    case "SVGTransform": return new _SVGTransformImpl._wrap(domObject);
    case "SVGTransformList": return new _SVGTransformListImpl._wrap(domObject);
    case "SVGUnitTypes": return new _SVGUnitTypesImpl._wrap(domObject);
    case "SVGUseElement": return new _SVGUseElementImpl._wrap(domObject);
    case "SVGVKernElement": return new _SVGVKernElementImpl._wrap(domObject);
    case "SVGViewElement": return new _SVGViewElementImpl._wrap(domObject);
    case "SVGViewSpec": return new _SVGViewSpecImpl._wrap(domObject);
    case "SVGZoomEvent": return new _SVGZoomEventImpl._wrap(domObject);
    case "Screen": return new _ScreenImpl._wrap(domObject);
    case "HTMLScriptElement": return new _ScriptElementImpl._wrap(domObject);
    case "ScriptProfile": return new _ScriptProfileImpl._wrap(domObject);
    case "ScriptProfileNode": return new _ScriptProfileNodeImpl._wrap(domObject);
    case "HTMLSelectElement": return new _SelectElementImpl._wrap(domObject);
    case "SessionDescription": return new _SessionDescriptionImpl._wrap(domObject);
    case "HTMLShadowElement": return new _ShadowElementImpl._wrap(domObject);
    case "ShadowRoot": return new _ShadowRootImpl._wrap(domObject);
    case "SharedWorker": return new _SharedWorkerImpl._wrap(domObject);
    case "SharedWorkerContext": return new _SharedWorkerContextImpl._wrap(domObject);
    case "HTMLSourceElement": return new _SourceElementImpl._wrap(domObject);
    case "HTMLSpanElement": return new _SpanElementImpl._wrap(domObject);
    case "SpeechGrammar": return new _SpeechGrammarImpl._wrap(domObject);
    case "SpeechGrammarList": return new _SpeechGrammarListImpl._wrap(domObject);
    case "SpeechInputEvent": return new _SpeechInputEventImpl._wrap(domObject);
    case "SpeechInputResult": return new _SpeechInputResultImpl._wrap(domObject);
    case "SpeechInputResultList": return new _SpeechInputResultListImpl._wrap(domObject);
    case "SpeechRecognition": return new _SpeechRecognitionImpl._wrap(domObject);
    case "SpeechRecognitionAlternative": return new _SpeechRecognitionAlternativeImpl._wrap(domObject);
    case "SpeechRecognitionError": return new _SpeechRecognitionErrorImpl._wrap(domObject);
    case "SpeechRecognitionEvent": return new _SpeechRecognitionEventImpl._wrap(domObject);
    case "SpeechRecognitionResult": return new _SpeechRecognitionResultImpl._wrap(domObject);
    case "SpeechRecognitionResultList": return new _SpeechRecognitionResultListImpl._wrap(domObject);
    case "Storage": return new _StorageImpl._wrap(domObject);
    case "StorageEvent": return new _StorageEventImpl._wrap(domObject);
    case "StorageInfo": return new _StorageInfoImpl._wrap(domObject);
    case "HTMLStyleElement": return new _StyleElementImpl._wrap(domObject);
    case "StyleMedia": return new _StyleMediaImpl._wrap(domObject);
    case "StyleSheetList": return new _StyleSheetListImpl._wrap(domObject);
    case "HTMLTableCaptionElement": return new _TableCaptionElementImpl._wrap(domObject);
    case "HTMLTableCellElement": return new _TableCellElementImpl._wrap(domObject);
    case "HTMLTableColElement": return new _TableColElementImpl._wrap(domObject);
    case "HTMLTableElement": return new _TableElementImpl._wrap(domObject);
    case "HTMLTableRowElement": return new _TableRowElementImpl._wrap(domObject);
    case "HTMLTableSectionElement": return new _TableSectionElementImpl._wrap(domObject);
    case "HTMLTextAreaElement": return new _TextAreaElementImpl._wrap(domObject);
    case "TextEvent": return new _TextEventImpl._wrap(domObject);
    case "TextMetrics": return new _TextMetricsImpl._wrap(domObject);
    case "TextTrack": return new _TextTrackImpl._wrap(domObject);
    case "TextTrackCue": return new _TextTrackCueImpl._wrap(domObject);
    case "TextTrackCueList": return new _TextTrackCueListImpl._wrap(domObject);
    case "TextTrackList": return new _TextTrackListImpl._wrap(domObject);
    case "TimeRanges": return new _TimeRangesImpl._wrap(domObject);
    case "HTMLTitleElement": return new _TitleElementImpl._wrap(domObject);
    case "Touch": return new _TouchImpl._wrap(domObject);
    case "TouchEvent": return new _TouchEventImpl._wrap(domObject);
    case "TouchList": return new _TouchListImpl._wrap(domObject);
    case "HTMLTrackElement": return new _TrackElementImpl._wrap(domObject);
    case "TrackEvent": return new _TrackEventImpl._wrap(domObject);
    case "WebKitTransitionEvent": return new _TransitionEventImpl._wrap(domObject);
    case "TreeWalker": return new _TreeWalkerImpl._wrap(domObject);
    case "HTMLUListElement": return new _UListElementImpl._wrap(domObject);
    case "Uint16Array": return new _Uint16ArrayImpl._wrap(domObject);
    case "Uint32Array": return new _Uint32ArrayImpl._wrap(domObject);
    case "Uint8Array": return new _Uint8ArrayImpl._wrap(domObject);
    case "Uint8ClampedArray": return new _Uint8ClampedArrayImpl._wrap(domObject);
    case "HTMLUnknownElement": return new _UnknownElementImpl._wrap(domObject);
    case "ValidityState": return new _ValidityStateImpl._wrap(domObject);
    case "HTMLVideoElement": return new _VideoElementImpl._wrap(domObject);
    case "WaveShaperNode": return new _WaveShaperNodeImpl._wrap(domObject);
    case "WebGLActiveInfo": return new _WebGLActiveInfoImpl._wrap(domObject);
    case "WebGLBuffer": return new _WebGLBufferImpl._wrap(domObject);
    case "WebGLCompressedTextureS3TC": return new _WebGLCompressedTextureS3TCImpl._wrap(domObject);
    case "WebGLContextAttributes": return new _WebGLContextAttributesImpl._wrap(domObject);
    case "WebGLContextEvent": return new _WebGLContextEventImpl._wrap(domObject);
    case "WebGLDebugRendererInfo": return new _WebGLDebugRendererInfoImpl._wrap(domObject);
    case "WebGLDebugShaders": return new _WebGLDebugShadersImpl._wrap(domObject);
    case "WebGLFramebuffer": return new _WebGLFramebufferImpl._wrap(domObject);
    case "WebGLLoseContext": return new _WebGLLoseContextImpl._wrap(domObject);
    case "WebGLProgram": return new _WebGLProgramImpl._wrap(domObject);
    case "WebGLRenderbuffer": return new _WebGLRenderbufferImpl._wrap(domObject);
    case "WebGLRenderingContext": return new _WebGLRenderingContextImpl._wrap(domObject);
    case "WebGLShader": return new _WebGLShaderImpl._wrap(domObject);
    case "WebGLTexture": return new _WebGLTextureImpl._wrap(domObject);
    case "WebGLUniformLocation": return new _WebGLUniformLocationImpl._wrap(domObject);
    case "WebGLVertexArrayObjectOES": return new _WebGLVertexArrayObjectOESImpl._wrap(domObject);
    case "WebKitCSSRegionRule": return new _WebKitCSSRegionRuleImpl._wrap(domObject);
    case "WebKitNamedFlow": return new _WebKitNamedFlowImpl._wrap(domObject);
    case "WebSocket": return new _WebSocketImpl._wrap(domObject);
    case "WheelEvent": return new _WheelEventImpl._wrap(domObject);
    case "DOMWindow": return new _WindowImpl._wrap(domObject);
    case "Worker": return new _WorkerImpl._wrap(domObject);
    case "WorkerLocation": return new _WorkerLocationImpl._wrap(domObject);
    case "WorkerNavigator": return new _WorkerNavigatorImpl._wrap(domObject);
    case "XMLHttpRequest": return new _XMLHttpRequestImpl._wrap(domObject);
    case "XMLHttpRequestException": return new _XMLHttpRequestExceptionImpl._wrap(domObject);
    case "XMLHttpRequestProgressEvent": return new _XMLHttpRequestProgressEventImpl._wrap(domObject);
    case "XMLHttpRequestUpload": return new _XMLHttpRequestUploadImpl._wrap(domObject);
    case "XMLSerializer": return new _XMLSerializerImpl._wrap(domObject);
    case "XPathEvaluator": return new _XPathEvaluatorImpl._wrap(domObject);
    case "XPathException": return new _XPathExceptionImpl._wrap(domObject);
    case "XPathExpression": return new _XPathExpressionImpl._wrap(domObject);
    case "XPathNSResolver": return new _XPathNSResolverImpl._wrap(domObject);
    case "XPathResult": return new _XPathResultImpl._wrap(domObject);
    case "XSLTProcessor": return new _XSLTProcessorImpl._wrap(domObject);
    default:
      throw 'Unrecognized object $domObject. Name=${domObject.typeName}';
  }
}

class _AbstractWorkerImpl extends _EventTargetImpl implements AbstractWorker {
  _AbstractWorkerImpl._wrap(ptr) : super._wrap(ptr);

  _AbstractWorkerEventsImpl get on() {
    if (_on == null) _on = new _AbstractWorkerEventsImpl(this);
    return _on;
  }

  void _addEventListener(String type, EventListener listener, [bool useCapture = null]) {
    if (useCapture === null) {
      _ptr.addEventListener(_unwrap(type), _unwrap(listener));
      return;
    } else {
      _ptr.addEventListener(_unwrap(type), _unwrap(listener), _unwrap(useCapture));
      return;
    }
  }

  bool _dispatchEvent(Event evt) {
    return _wrap(_ptr.dispatchEvent(_unwrap(evt)));
  }

  void _removeEventListener(String type, EventListener listener, [bool useCapture = null]) {
    if (useCapture === null) {
      _ptr.removeEventListener(_unwrap(type), _unwrap(listener));
      return;
    } else {
      _ptr.removeEventListener(_unwrap(type), _unwrap(listener), _unwrap(useCapture));
      return;
    }
  }
}

class _AbstractWorkerEventsImpl extends _EventsImpl implements AbstractWorkerEvents {
  _AbstractWorkerEventsImpl(_ptr) : super(_ptr);

  EventListenerList get error() => _get('error');
}

class _AnchorElementImpl extends _ElementImpl implements AnchorElement {
  _AnchorElementImpl._wrap(ptr) : super._wrap(ptr);

  String get charset() => _wrap(_ptr.charset);

  void set charset(String value) { _ptr.charset = _unwrap(value); }

  String get coords() => _wrap(_ptr.coords);

  void set coords(String value) { _ptr.coords = _unwrap(value); }

  String get download() => _wrap(_ptr.download);

  void set download(String value) { _ptr.download = _unwrap(value); }

  String get hash() => _wrap(_ptr.hash);

  void set hash(String value) { _ptr.hash = _unwrap(value); }

  String get host() => _wrap(_ptr.host);

  void set host(String value) { _ptr.host = _unwrap(value); }

  String get hostname() => _wrap(_ptr.hostname);

  void set hostname(String value) { _ptr.hostname = _unwrap(value); }

  String get href() => _wrap(_ptr.href);

  void set href(String value) { _ptr.href = _unwrap(value); }

  String get hreflang() => _wrap(_ptr.hreflang);

  void set hreflang(String value) { _ptr.hreflang = _unwrap(value); }

  String get name() => _wrap(_ptr.name);

  void set name(String value) { _ptr.name = _unwrap(value); }

  String get origin() => _wrap(_ptr.origin);

  String get pathname() => _wrap(_ptr.pathname);

  void set pathname(String value) { _ptr.pathname = _unwrap(value); }

  String get ping() => _wrap(_ptr.ping);

  void set ping(String value) { _ptr.ping = _unwrap(value); }

  String get port() => _wrap(_ptr.port);

  void set port(String value) { _ptr.port = _unwrap(value); }

  String get protocol() => _wrap(_ptr.protocol);

  void set protocol(String value) { _ptr.protocol = _unwrap(value); }

  String get rel() => _wrap(_ptr.rel);

  void set rel(String value) { _ptr.rel = _unwrap(value); }

  String get rev() => _wrap(_ptr.rev);

  void set rev(String value) { _ptr.rev = _unwrap(value); }

  String get search() => _wrap(_ptr.search);

  void set search(String value) { _ptr.search = _unwrap(value); }

  String get shape() => _wrap(_ptr.shape);

  void set shape(String value) { _ptr.shape = _unwrap(value); }

  String get target() => _wrap(_ptr.target);

  void set target(String value) { _ptr.target = _unwrap(value); }

  String get type() => _wrap(_ptr.type);

  void set type(String value) { _ptr.type = _unwrap(value); }

  String toString() {
    return _wrap(_ptr.toString());
  }
}

class _AnimationImpl extends _DOMTypeBase implements Animation {
  _AnimationImpl._wrap(ptr) : super._wrap(ptr);

  num get delay() => _wrap(_ptr.delay);

  int get direction() => _wrap(_ptr.direction);

  num get duration() => _wrap(_ptr.duration);

  num get elapsedTime() => _wrap(_ptr.elapsedTime);

  void set elapsedTime(num value) { _ptr.elapsedTime = _unwrap(value); }

  bool get ended() => _wrap(_ptr.ended);

  int get fillMode() => _wrap(_ptr.fillMode);

  int get iterationCount() => _wrap(_ptr.iterationCount);

  String get name() => _wrap(_ptr.name);

  bool get paused() => _wrap(_ptr.paused);

  void pause() {
    _ptr.pause();
    return;
  }

  void play() {
    _ptr.play();
    return;
  }
}

class _AnimationEventImpl extends _EventImpl implements AnimationEvent {
  _AnimationEventImpl._wrap(ptr) : super._wrap(ptr);

  String get animationName() => _wrap(_ptr.animationName);

  num get elapsedTime() => _wrap(_ptr.elapsedTime);
}

class _AnimationListImpl extends _DOMTypeBase implements AnimationList {
  _AnimationListImpl._wrap(ptr) : super._wrap(ptr);

  int get length() => _wrap(_ptr.length);

  Animation item(int index) {
    return _wrap(_ptr.item(_unwrap(index)));
  }
}

class _AppletElementImpl extends _ElementImpl implements AppletElement {
  _AppletElementImpl._wrap(ptr) : super._wrap(ptr);

  String get align() => _wrap(_ptr.align);

  void set align(String value) { _ptr.align = _unwrap(value); }

  String get alt() => _wrap(_ptr.alt);

  void set alt(String value) { _ptr.alt = _unwrap(value); }

  String get archive() => _wrap(_ptr.archive);

  void set archive(String value) { _ptr.archive = _unwrap(value); }

  String get code() => _wrap(_ptr.code);

  void set code(String value) { _ptr.code = _unwrap(value); }

  String get codeBase() => _wrap(_ptr.codeBase);

  void set codeBase(String value) { _ptr.codeBase = _unwrap(value); }

  String get height() => _wrap(_ptr.height);

  void set height(String value) { _ptr.height = _unwrap(value); }

  String get hspace() => _wrap(_ptr.hspace);

  void set hspace(String value) { _ptr.hspace = _unwrap(value); }

  String get name() => _wrap(_ptr.name);

  void set name(String value) { _ptr.name = _unwrap(value); }

  String get object() => _wrap(_ptr.object);

  void set object(String value) { _ptr.object = _unwrap(value); }

  String get vspace() => _wrap(_ptr.vspace);

  void set vspace(String value) { _ptr.vspace = _unwrap(value); }

  String get width() => _wrap(_ptr.width);

  void set width(String value) { _ptr.width = _unwrap(value); }
}

class _AreaElementImpl extends _ElementImpl implements AreaElement {
  _AreaElementImpl._wrap(ptr) : super._wrap(ptr);

  String get alt() => _wrap(_ptr.alt);

  void set alt(String value) { _ptr.alt = _unwrap(value); }

  String get coords() => _wrap(_ptr.coords);

  void set coords(String value) { _ptr.coords = _unwrap(value); }

  String get hash() => _wrap(_ptr.hash);

  String get host() => _wrap(_ptr.host);

  String get hostname() => _wrap(_ptr.hostname);

  String get href() => _wrap(_ptr.href);

  void set href(String value) { _ptr.href = _unwrap(value); }

  bool get noHref() => _wrap(_ptr.noHref);

  void set noHref(bool value) { _ptr.noHref = _unwrap(value); }

  String get pathname() => _wrap(_ptr.pathname);

  String get ping() => _wrap(_ptr.ping);

  void set ping(String value) { _ptr.ping = _unwrap(value); }

  String get port() => _wrap(_ptr.port);

  String get protocol() => _wrap(_ptr.protocol);

  String get search() => _wrap(_ptr.search);

  String get shape() => _wrap(_ptr.shape);

  void set shape(String value) { _ptr.shape = _unwrap(value); }

  String get target() => _wrap(_ptr.target);

  void set target(String value) { _ptr.target = _unwrap(value); }
}

class _ArrayBufferImpl extends _DOMTypeBase implements ArrayBuffer {
  _ArrayBufferImpl._wrap(ptr) : super._wrap(ptr);

  int get byteLength() => _wrap(_ptr.byteLength);

  ArrayBuffer slice(int begin, [int end = null]) {
    if (end === null) {
      return _wrap(_ptr.slice(_unwrap(begin)));
    } else {
      return _wrap(_ptr.slice(_unwrap(begin), _unwrap(end)));
    }
  }
}

class _ArrayBufferViewImpl extends _DOMTypeBase implements ArrayBufferView {
  _ArrayBufferViewImpl._wrap(ptr) : super._wrap(ptr);

  ArrayBuffer get buffer() => _wrap(_ptr.buffer);

  int get byteLength() => _wrap(_ptr.byteLength);

  int get byteOffset() => _wrap(_ptr.byteOffset);
}

class _AttrImpl extends _NodeImpl implements Attr {
  _AttrImpl._wrap(ptr) : super._wrap(ptr);

  bool get isId() => _wrap(_ptr.isId);

  String get name() => _wrap(_ptr.name);

  Element get ownerElement() => _wrap(_ptr.ownerElement);

  bool get specified() => _wrap(_ptr.specified);

  String get value() => _wrap(_ptr.value);

  void set value(String value) { _ptr.value = _unwrap(value); }
}

class _AudioBufferImpl extends _DOMTypeBase implements AudioBuffer {
  _AudioBufferImpl._wrap(ptr) : super._wrap(ptr);

  num get duration() => _wrap(_ptr.duration);

  num get gain() => _wrap(_ptr.gain);

  void set gain(num value) { _ptr.gain = _unwrap(value); }

  int get length() => _wrap(_ptr.length);

  int get numberOfChannels() => _wrap(_ptr.numberOfChannels);

  num get sampleRate() => _wrap(_ptr.sampleRate);

  Float32Array getChannelData(int channelIndex) {
    return _wrap(_ptr.getChannelData(_unwrap(channelIndex)));
  }
}

class _AudioBufferSourceNodeImpl extends _AudioSourceNodeImpl implements AudioBufferSourceNode {
  _AudioBufferSourceNodeImpl._wrap(ptr) : super._wrap(ptr);

  AudioBuffer get buffer() => _wrap(_ptr.buffer);

  void set buffer(AudioBuffer value) { _ptr.buffer = _unwrap(value); }

  AudioGain get gain() => _wrap(_ptr.gain);

  bool get loop() => _wrap(_ptr.loop);

  void set loop(bool value) { _ptr.loop = _unwrap(value); }

  bool get looping() => _wrap(_ptr.looping);

  void set looping(bool value) { _ptr.looping = _unwrap(value); }

  AudioParam get playbackRate() => _wrap(_ptr.playbackRate);

  int get playbackState() => _wrap(_ptr.playbackState);

  void noteGrainOn(num when, num grainOffset, num grainDuration) {
    _ptr.noteGrainOn(_unwrap(when), _unwrap(grainOffset), _unwrap(grainDuration));
    return;
  }

  void noteOff(num when) {
    _ptr.noteOff(_unwrap(when));
    return;
  }

  void noteOn(num when) {
    _ptr.noteOn(_unwrap(when));
    return;
  }
}

class _AudioChannelMergerImpl extends _AudioNodeImpl implements AudioChannelMerger {
  _AudioChannelMergerImpl._wrap(ptr) : super._wrap(ptr);
}

class _AudioChannelSplitterImpl extends _AudioNodeImpl implements AudioChannelSplitter {
  _AudioChannelSplitterImpl._wrap(ptr) : super._wrap(ptr);
}

class _AudioContextImpl extends _DOMTypeBase implements AudioContext {
  _AudioContextImpl._wrap(ptr) : super._wrap(ptr);

  int get activeSourceCount() => _wrap(_ptr.activeSourceCount);

  num get currentTime() => _wrap(_ptr.currentTime);

  AudioDestinationNode get destination() => _wrap(_ptr.destination);

  AudioListener get listener() => _wrap(_ptr.listener);

  EventListener get oncomplete() => _wrap(_ptr.oncomplete);

  void set oncomplete(EventListener value) { _ptr.oncomplete = _unwrap(value); }

  num get sampleRate() => _wrap(_ptr.sampleRate);

  RealtimeAnalyserNode createAnalyser() {
    return _wrap(_ptr.createAnalyser());
  }

  BiquadFilterNode createBiquadFilter() {
    return _wrap(_ptr.createBiquadFilter());
  }

  AudioBuffer createBuffer(var buffer_OR_numberOfChannels, var mixToMono_OR_numberOfFrames, [num sampleRate = null]) {
    if (buffer_OR_numberOfChannels is ArrayBuffer) {
      if (mixToMono_OR_numberOfFrames is bool) {
        if (sampleRate === null) {
          return _wrap(_ptr.createBuffer(_unwrap(buffer_OR_numberOfChannels), _unwrap(mixToMono_OR_numberOfFrames)));
        }
      }
    } else {
      if (buffer_OR_numberOfChannels is int) {
        if (mixToMono_OR_numberOfFrames is int) {
          return _wrap(_ptr.createBuffer(_unwrap(buffer_OR_numberOfChannels), _unwrap(mixToMono_OR_numberOfFrames), _unwrap(sampleRate)));
        }
      }
    }
    throw "Incorrect number or type of arguments";
  }

  AudioBufferSourceNode createBufferSource() {
    return _wrap(_ptr.createBufferSource());
  }

  AudioChannelMerger createChannelMerger() {
    return _wrap(_ptr.createChannelMerger());
  }

  AudioChannelSplitter createChannelSplitter() {
    return _wrap(_ptr.createChannelSplitter());
  }

  ConvolverNode createConvolver() {
    return _wrap(_ptr.createConvolver());
  }

  DelayNode createDelayNode([num maxDelayTime = null]) {
    if (maxDelayTime === null) {
      return _wrap(_ptr.createDelayNode());
    } else {
      return _wrap(_ptr.createDelayNode(_unwrap(maxDelayTime)));
    }
  }

  DynamicsCompressorNode createDynamicsCompressor() {
    return _wrap(_ptr.createDynamicsCompressor());
  }

  AudioGainNode createGainNode() {
    return _wrap(_ptr.createGainNode());
  }

  HighPass2FilterNode createHighPass2Filter() {
    return _wrap(_ptr.createHighPass2Filter());
  }

  JavaScriptAudioNode createJavaScriptNode(int bufferSize) {
    return _wrap(_ptr.createJavaScriptNode(_unwrap(bufferSize)));
  }

  LowPass2FilterNode createLowPass2Filter() {
    return _wrap(_ptr.createLowPass2Filter());
  }

  MediaElementAudioSourceNode createMediaElementSource(MediaElement mediaElement) {
    return _wrap(_ptr.createMediaElementSource(_unwrap(mediaElement)));
  }

  AudioPannerNode createPanner() {
    return _wrap(_ptr.createPanner());
  }

  WaveShaperNode createWaveShaper() {
    return _wrap(_ptr.createWaveShaper());
  }

  void decodeAudioData(ArrayBuffer audioData, AudioBufferCallback successCallback, [AudioBufferCallback errorCallback = null]) {
    if (errorCallback === null) {
      _ptr.decodeAudioData(_unwrap(audioData), _unwrap(successCallback));
      return;
    } else {
      _ptr.decodeAudioData(_unwrap(audioData), _unwrap(successCallback), _unwrap(errorCallback));
      return;
    }
  }

  void startRendering() {
    _ptr.startRendering();
    return;
  }
}

class _AudioDestinationNodeImpl extends _AudioNodeImpl implements AudioDestinationNode {
  _AudioDestinationNodeImpl._wrap(ptr) : super._wrap(ptr);

  int get numberOfChannels() => _wrap(_ptr.numberOfChannels);
}

class _AudioElementImpl extends _MediaElementImpl implements AudioElement {
  _AudioElementImpl._wrap(ptr) : super._wrap(ptr);
}

class _AudioGainImpl extends _AudioParamImpl implements AudioGain {
  _AudioGainImpl._wrap(ptr) : super._wrap(ptr);
}

class _AudioGainNodeImpl extends _AudioNodeImpl implements AudioGainNode {
  _AudioGainNodeImpl._wrap(ptr) : super._wrap(ptr);

  AudioGain get gain() => _wrap(_ptr.gain);
}

class _AudioListenerImpl extends _DOMTypeBase implements AudioListener {
  _AudioListenerImpl._wrap(ptr) : super._wrap(ptr);

  num get dopplerFactor() => _wrap(_ptr.dopplerFactor);

  void set dopplerFactor(num value) { _ptr.dopplerFactor = _unwrap(value); }

  num get speedOfSound() => _wrap(_ptr.speedOfSound);

  void set speedOfSound(num value) { _ptr.speedOfSound = _unwrap(value); }

  void setOrientation(num x, num y, num z, num xUp, num yUp, num zUp) {
    _ptr.setOrientation(_unwrap(x), _unwrap(y), _unwrap(z), _unwrap(xUp), _unwrap(yUp), _unwrap(zUp));
    return;
  }

  void setPosition(num x, num y, num z) {
    _ptr.setPosition(_unwrap(x), _unwrap(y), _unwrap(z));
    return;
  }

  void setVelocity(num x, num y, num z) {
    _ptr.setVelocity(_unwrap(x), _unwrap(y), _unwrap(z));
    return;
  }
}

class _AudioNodeImpl extends _DOMTypeBase implements AudioNode {
  _AudioNodeImpl._wrap(ptr) : super._wrap(ptr);

  AudioContext get context() => _wrap(_ptr.context);

  int get numberOfInputs() => _wrap(_ptr.numberOfInputs);

  int get numberOfOutputs() => _wrap(_ptr.numberOfOutputs);

  void connect(AudioNode destination, int output, int input) {
    _ptr.connect(_unwrap(destination), _unwrap(output), _unwrap(input));
    return;
  }

  void disconnect(int output) {
    _ptr.disconnect(_unwrap(output));
    return;
  }
}

class _AudioPannerNodeImpl extends _AudioNodeImpl implements AudioPannerNode {
  _AudioPannerNodeImpl._wrap(ptr) : super._wrap(ptr);

  AudioGain get coneGain() => _wrap(_ptr.coneGain);

  num get coneInnerAngle() => _wrap(_ptr.coneInnerAngle);

  void set coneInnerAngle(num value) { _ptr.coneInnerAngle = _unwrap(value); }

  num get coneOuterAngle() => _wrap(_ptr.coneOuterAngle);

  void set coneOuterAngle(num value) { _ptr.coneOuterAngle = _unwrap(value); }

  num get coneOuterGain() => _wrap(_ptr.coneOuterGain);

  void set coneOuterGain(num value) { _ptr.coneOuterGain = _unwrap(value); }

  AudioGain get distanceGain() => _wrap(_ptr.distanceGain);

  int get distanceModel() => _wrap(_ptr.distanceModel);

  void set distanceModel(int value) { _ptr.distanceModel = _unwrap(value); }

  num get maxDistance() => _wrap(_ptr.maxDistance);

  void set maxDistance(num value) { _ptr.maxDistance = _unwrap(value); }

  int get panningModel() => _wrap(_ptr.panningModel);

  void set panningModel(int value) { _ptr.panningModel = _unwrap(value); }

  num get refDistance() => _wrap(_ptr.refDistance);

  void set refDistance(num value) { _ptr.refDistance = _unwrap(value); }

  num get rolloffFactor() => _wrap(_ptr.rolloffFactor);

  void set rolloffFactor(num value) { _ptr.rolloffFactor = _unwrap(value); }

  void setOrientation(num x, num y, num z) {
    _ptr.setOrientation(_unwrap(x), _unwrap(y), _unwrap(z));
    return;
  }

  void setPosition(num x, num y, num z) {
    _ptr.setPosition(_unwrap(x), _unwrap(y), _unwrap(z));
    return;
  }

  void setVelocity(num x, num y, num z) {
    _ptr.setVelocity(_unwrap(x), _unwrap(y), _unwrap(z));
    return;
  }
}

class _AudioParamImpl extends _DOMTypeBase implements AudioParam {
  _AudioParamImpl._wrap(ptr) : super._wrap(ptr);

  num get defaultValue() => _wrap(_ptr.defaultValue);

  num get maxValue() => _wrap(_ptr.maxValue);

  num get minValue() => _wrap(_ptr.minValue);

  String get name() => _wrap(_ptr.name);

  int get units() => _wrap(_ptr.units);

  num get value() => _wrap(_ptr.value);

  void set value(num value) { _ptr.value = _unwrap(value); }

  void cancelScheduledValues(num startTime) {
    _ptr.cancelScheduledValues(_unwrap(startTime));
    return;
  }

  void exponentialRampToValueAtTime(num value, num time) {
    _ptr.exponentialRampToValueAtTime(_unwrap(value), _unwrap(time));
    return;
  }

  void linearRampToValueAtTime(num value, num time) {
    _ptr.linearRampToValueAtTime(_unwrap(value), _unwrap(time));
    return;
  }

  void setTargetValueAtTime(num targetValue, num time, num timeConstant) {
    _ptr.setTargetValueAtTime(_unwrap(targetValue), _unwrap(time), _unwrap(timeConstant));
    return;
  }

  void setValueAtTime(num value, num time) {
    _ptr.setValueAtTime(_unwrap(value), _unwrap(time));
    return;
  }

  void setValueCurveAtTime(Float32Array values, num time, num duration) {
    _ptr.setValueCurveAtTime(_unwrap(values), _unwrap(time), _unwrap(duration));
    return;
  }
}

class _AudioProcessingEventImpl extends _EventImpl implements AudioProcessingEvent {
  _AudioProcessingEventImpl._wrap(ptr) : super._wrap(ptr);

  AudioBuffer get inputBuffer() => _wrap(_ptr.inputBuffer);

  AudioBuffer get outputBuffer() => _wrap(_ptr.outputBuffer);
}

class _AudioSourceNodeImpl extends _AudioNodeImpl implements AudioSourceNode {
  _AudioSourceNodeImpl._wrap(ptr) : super._wrap(ptr);
}

class _BRElementImpl extends _ElementImpl implements BRElement {
  _BRElementImpl._wrap(ptr) : super._wrap(ptr);

  String get clear() => _wrap(_ptr.clear);

  void set clear(String value) { _ptr.clear = _unwrap(value); }
}

class _BarInfoImpl extends _DOMTypeBase implements BarInfo {
  _BarInfoImpl._wrap(ptr) : super._wrap(ptr);

  bool get visible() => _wrap(_ptr.visible);
}

class _BaseElementImpl extends _ElementImpl implements BaseElement {
  _BaseElementImpl._wrap(ptr) : super._wrap(ptr);

  String get href() => _wrap(_ptr.href);

  void set href(String value) { _ptr.href = _unwrap(value); }

  String get target() => _wrap(_ptr.target);

  void set target(String value) { _ptr.target = _unwrap(value); }
}

class _BaseFontElementImpl extends _ElementImpl implements BaseFontElement {
  _BaseFontElementImpl._wrap(ptr) : super._wrap(ptr);

  String get color() => _wrap(_ptr.color);

  void set color(String value) { _ptr.color = _unwrap(value); }

  String get face() => _wrap(_ptr.face);

  void set face(String value) { _ptr.face = _unwrap(value); }

  int get size() => _wrap(_ptr.size);

  void set size(int value) { _ptr.size = _unwrap(value); }
}

class _BeforeLoadEventImpl extends _EventImpl implements BeforeLoadEvent {
  _BeforeLoadEventImpl._wrap(ptr) : super._wrap(ptr);

  String get url() => _wrap(_ptr.url);
}

class _BiquadFilterNodeImpl extends _AudioNodeImpl implements BiquadFilterNode {
  _BiquadFilterNodeImpl._wrap(ptr) : super._wrap(ptr);

  AudioParam get Q() => _wrap(_ptr.Q);

  AudioParam get frequency() => _wrap(_ptr.frequency);

  AudioParam get gain() => _wrap(_ptr.gain);

  int get type() => _wrap(_ptr.type);

  void set type(int value) { _ptr.type = _unwrap(value); }

  void getFrequencyResponse(Float32Array frequencyHz, Float32Array magResponse, Float32Array phaseResponse) {
    _ptr.getFrequencyResponse(_unwrap(frequencyHz), _unwrap(magResponse), _unwrap(phaseResponse));
    return;
  }
}

class _BlobImpl extends _DOMTypeBase implements Blob {
  _BlobImpl._wrap(ptr) : super._wrap(ptr);

  int get size() => _wrap(_ptr.size);

  String get type() => _wrap(_ptr.type);

  Blob webkitSlice([int start = null, int end = null, String contentType = null]) {
    if (start === null) {
      if (end === null) {
        if (contentType === null) {
          return _wrap(_ptr.webkitSlice());
        }
      }
    } else {
      if (end === null) {
        if (contentType === null) {
          return _wrap(_ptr.webkitSlice(_unwrap(start)));
        }
      } else {
        if (contentType === null) {
          return _wrap(_ptr.webkitSlice(_unwrap(start), _unwrap(end)));
        } else {
          return _wrap(_ptr.webkitSlice(_unwrap(start), _unwrap(end), _unwrap(contentType)));
        }
      }
    }
    throw "Incorrect number or type of arguments";
  }
}

class _BlobBuilderImpl extends _DOMTypeBase implements BlobBuilder {
  _BlobBuilderImpl._wrap(ptr) : super._wrap(ptr);

  void append(var arrayBuffer_OR_blob_OR_value, [String endings = null]) {
    if (arrayBuffer_OR_blob_OR_value is Blob) {
      if (endings === null) {
        _ptr.append(_unwrap(arrayBuffer_OR_blob_OR_value));
        return;
      }
    } else {
      if (arrayBuffer_OR_blob_OR_value is ArrayBuffer) {
        if (endings === null) {
          _ptr.append(_unwrap(arrayBuffer_OR_blob_OR_value));
          return;
        }
      } else {
        if (arrayBuffer_OR_blob_OR_value is String) {
          if (endings === null) {
            _ptr.append(_unwrap(arrayBuffer_OR_blob_OR_value));
            return;
          } else {
            _ptr.append(_unwrap(arrayBuffer_OR_blob_OR_value), _unwrap(endings));
            return;
          }
        }
      }
    }
    throw "Incorrect number or type of arguments";
  }

  Blob getBlob([String contentType = null]) {
    if (contentType === null) {
      return _wrap(_ptr.getBlob());
    } else {
      return _wrap(_ptr.getBlob(_unwrap(contentType)));
    }
  }
}

class _BodyElementImpl extends _ElementImpl implements BodyElement {
  _BodyElementImpl._wrap(ptr) : super._wrap(ptr);

  _BodyElementEventsImpl get on() {
    if (_on == null) _on = new _BodyElementEventsImpl(this);
    return _on;
  }

  String get aLink() => _wrap(_ptr.aLink);

  void set aLink(String value) { _ptr.aLink = _unwrap(value); }

  String get background() => _wrap(_ptr.background);

  void set background(String value) { _ptr.background = _unwrap(value); }

  String get bgColor() => _wrap(_ptr.bgColor);

  void set bgColor(String value) { _ptr.bgColor = _unwrap(value); }

  String get link() => _wrap(_ptr.link);

  void set link(String value) { _ptr.link = _unwrap(value); }

  String get vLink() => _wrap(_ptr.vLink);

  void set vLink(String value) { _ptr.vLink = _unwrap(value); }
}

class _BodyElementEventsImpl extends _ElementEventsImpl implements BodyElementEvents {
  _BodyElementEventsImpl(_ptr) : super(_ptr);

  EventListenerList get beforeUnload() => _get('beforeunload');

  EventListenerList get blur() => _get('blur');

  EventListenerList get error() => _get('error');

  EventListenerList get focus() => _get('focus');

  EventListenerList get hashChange() => _get('hashchange');

  EventListenerList get load() => _get('load');

  EventListenerList get message() => _get('message');

  EventListenerList get offline() => _get('offline');

  EventListenerList get online() => _get('online');

  EventListenerList get popState() => _get('popstate');

  EventListenerList get resize() => _get('resize');

  EventListenerList get storage() => _get('storage');

  EventListenerList get unload() => _get('unload');
}

class _ButtonElementImpl extends _ElementImpl implements ButtonElement {
  _ButtonElementImpl._wrap(ptr) : super._wrap(ptr);

  bool get autofocus() => _wrap(_ptr.autofocus);

  void set autofocus(bool value) { _ptr.autofocus = _unwrap(value); }

  bool get disabled() => _wrap(_ptr.disabled);

  void set disabled(bool value) { _ptr.disabled = _unwrap(value); }

  FormElement get form() => _wrap(_ptr.form);

  String get formAction() => _wrap(_ptr.formAction);

  void set formAction(String value) { _ptr.formAction = _unwrap(value); }

  String get formEnctype() => _wrap(_ptr.formEnctype);

  void set formEnctype(String value) { _ptr.formEnctype = _unwrap(value); }

  String get formMethod() => _wrap(_ptr.formMethod);

  void set formMethod(String value) { _ptr.formMethod = _unwrap(value); }

  bool get formNoValidate() => _wrap(_ptr.formNoValidate);

  void set formNoValidate(bool value) { _ptr.formNoValidate = _unwrap(value); }

  String get formTarget() => _wrap(_ptr.formTarget);

  void set formTarget(String value) { _ptr.formTarget = _unwrap(value); }

  NodeList get labels() => _wrap(_ptr.labels);

  String get name() => _wrap(_ptr.name);

  void set name(String value) { _ptr.name = _unwrap(value); }

  String get type() => _wrap(_ptr.type);

  String get validationMessage() => _wrap(_ptr.validationMessage);

  ValidityState get validity() => _wrap(_ptr.validity);

  String get value() => _wrap(_ptr.value);

  void set value(String value) { _ptr.value = _unwrap(value); }

  bool get willValidate() => _wrap(_ptr.willValidate);

  bool checkValidity() {
    return _wrap(_ptr.checkValidity());
  }

  void setCustomValidity(String error) {
    _ptr.setCustomValidity(_unwrap(error));
    return;
  }
}

class _CDATASectionImpl extends _TextImpl implements CDATASection {
  _CDATASectionImpl._wrap(ptr) : super._wrap(ptr);
}

class _CSSCharsetRuleImpl extends _CSSRuleImpl implements CSSCharsetRule {
  _CSSCharsetRuleImpl._wrap(ptr) : super._wrap(ptr);

  String get encoding() => _wrap(_ptr.encoding);

  void set encoding(String value) { _ptr.encoding = _unwrap(value); }
}

class _CSSFontFaceRuleImpl extends _CSSRuleImpl implements CSSFontFaceRule {
  _CSSFontFaceRuleImpl._wrap(ptr) : super._wrap(ptr);

  CSSStyleDeclaration get style() => _wrap(_ptr.style);
}

class _CSSImportRuleImpl extends _CSSRuleImpl implements CSSImportRule {
  _CSSImportRuleImpl._wrap(ptr) : super._wrap(ptr);

  String get href() => _wrap(_ptr.href);

  MediaList get media() => _wrap(_ptr.media);

  CSSStyleSheet get styleSheet() => _wrap(_ptr.styleSheet);
}

class _CSSKeyframeRuleImpl extends _CSSRuleImpl implements CSSKeyframeRule {
  _CSSKeyframeRuleImpl._wrap(ptr) : super._wrap(ptr);

  String get keyText() => _wrap(_ptr.keyText);

  void set keyText(String value) { _ptr.keyText = _unwrap(value); }

  CSSStyleDeclaration get style() => _wrap(_ptr.style);
}

class _CSSKeyframesRuleImpl extends _CSSRuleImpl implements CSSKeyframesRule {
  _CSSKeyframesRuleImpl._wrap(ptr) : super._wrap(ptr);

  CSSRuleList get cssRules() => _wrap(_ptr.cssRules);

  String get name() => _wrap(_ptr.name);

  void set name(String value) { _ptr.name = _unwrap(value); }

  void deleteRule(String key) {
    _ptr.deleteRule(_unwrap(key));
    return;
  }

  CSSKeyframeRule findRule(String key) {
    return _wrap(_ptr.findRule(_unwrap(key)));
  }

  void insertRule(String rule) {
    _ptr.insertRule(_unwrap(rule));
    return;
  }
}

class _CSSMatrixImpl extends _DOMTypeBase implements CSSMatrix {
  _CSSMatrixImpl._wrap(ptr) : super._wrap(ptr);

  num get a() => _wrap(_ptr.a);

  void set a(num value) { _ptr.a = _unwrap(value); }

  num get b() => _wrap(_ptr.b);

  void set b(num value) { _ptr.b = _unwrap(value); }

  num get c() => _wrap(_ptr.c);

  void set c(num value) { _ptr.c = _unwrap(value); }

  num get d() => _wrap(_ptr.d);

  void set d(num value) { _ptr.d = _unwrap(value); }

  num get e() => _wrap(_ptr.e);

  void set e(num value) { _ptr.e = _unwrap(value); }

  num get f() => _wrap(_ptr.f);

  void set f(num value) { _ptr.f = _unwrap(value); }

  num get m11() => _wrap(_ptr.m11);

  void set m11(num value) { _ptr.m11 = _unwrap(value); }

  num get m12() => _wrap(_ptr.m12);

  void set m12(num value) { _ptr.m12 = _unwrap(value); }

  num get m13() => _wrap(_ptr.m13);

  void set m13(num value) { _ptr.m13 = _unwrap(value); }

  num get m14() => _wrap(_ptr.m14);

  void set m14(num value) { _ptr.m14 = _unwrap(value); }

  num get m21() => _wrap(_ptr.m21);

  void set m21(num value) { _ptr.m21 = _unwrap(value); }

  num get m22() => _wrap(_ptr.m22);

  void set m22(num value) { _ptr.m22 = _unwrap(value); }

  num get m23() => _wrap(_ptr.m23);

  void set m23(num value) { _ptr.m23 = _unwrap(value); }

  num get m24() => _wrap(_ptr.m24);

  void set m24(num value) { _ptr.m24 = _unwrap(value); }

  num get m31() => _wrap(_ptr.m31);

  void set m31(num value) { _ptr.m31 = _unwrap(value); }

  num get m32() => _wrap(_ptr.m32);

  void set m32(num value) { _ptr.m32 = _unwrap(value); }

  num get m33() => _wrap(_ptr.m33);

  void set m33(num value) { _ptr.m33 = _unwrap(value); }

  num get m34() => _wrap(_ptr.m34);

  void set m34(num value) { _ptr.m34 = _unwrap(value); }

  num get m41() => _wrap(_ptr.m41);

  void set m41(num value) { _ptr.m41 = _unwrap(value); }

  num get m42() => _wrap(_ptr.m42);

  void set m42(num value) { _ptr.m42 = _unwrap(value); }

  num get m43() => _wrap(_ptr.m43);

  void set m43(num value) { _ptr.m43 = _unwrap(value); }

  num get m44() => _wrap(_ptr.m44);

  void set m44(num value) { _ptr.m44 = _unwrap(value); }

  CSSMatrix inverse() {
    return _wrap(_ptr.inverse());
  }

  CSSMatrix multiply(CSSMatrix secondMatrix) {
    return _wrap(_ptr.multiply(_unwrap(secondMatrix)));
  }

  CSSMatrix rotate(num rotX, num rotY, num rotZ) {
    return _wrap(_ptr.rotate(_unwrap(rotX), _unwrap(rotY), _unwrap(rotZ)));
  }

  CSSMatrix rotateAxisAngle(num x, num y, num z, num angle) {
    return _wrap(_ptr.rotateAxisAngle(_unwrap(x), _unwrap(y), _unwrap(z), _unwrap(angle)));
  }

  CSSMatrix scale(num scaleX, num scaleY, num scaleZ) {
    return _wrap(_ptr.scale(_unwrap(scaleX), _unwrap(scaleY), _unwrap(scaleZ)));
  }

  void setMatrixValue(String string) {
    _ptr.setMatrixValue(_unwrap(string));
    return;
  }

  CSSMatrix skewX(num angle) {
    return _wrap(_ptr.skewX(_unwrap(angle)));
  }

  CSSMatrix skewY(num angle) {
    return _wrap(_ptr.skewY(_unwrap(angle)));
  }

  String toString() {
    return _wrap(_ptr.toString());
  }

  CSSMatrix translate(num x, num y, num z) {
    return _wrap(_ptr.translate(_unwrap(x), _unwrap(y), _unwrap(z)));
  }
}

class _CSSMediaRuleImpl extends _CSSRuleImpl implements CSSMediaRule {
  _CSSMediaRuleImpl._wrap(ptr) : super._wrap(ptr);

  CSSRuleList get cssRules() => _wrap(_ptr.cssRules);

  MediaList get media() => _wrap(_ptr.media);

  void deleteRule(int index) {
    _ptr.deleteRule(_unwrap(index));
    return;
  }

  int insertRule(String rule, int index) {
    return _wrap(_ptr.insertRule(_unwrap(rule), _unwrap(index)));
  }
}

class _CSSPageRuleImpl extends _CSSRuleImpl implements CSSPageRule {
  _CSSPageRuleImpl._wrap(ptr) : super._wrap(ptr);

  String get selectorText() => _wrap(_ptr.selectorText);

  void set selectorText(String value) { _ptr.selectorText = _unwrap(value); }

  CSSStyleDeclaration get style() => _wrap(_ptr.style);
}

class _CSSPrimitiveValueImpl extends _CSSValueImpl implements CSSPrimitiveValue {
  _CSSPrimitiveValueImpl._wrap(ptr) : super._wrap(ptr);

  int get primitiveType() => _wrap(_ptr.primitiveType);

  Counter getCounterValue() {
    return _wrap(_ptr.getCounterValue());
  }

  num getFloatValue(int unitType) {
    return _wrap(_ptr.getFloatValue(_unwrap(unitType)));
  }

  RGBColor getRGBColorValue() {
    return _wrap(_ptr.getRGBColorValue());
  }

  Rect getRectValue() {
    return _wrap(_ptr.getRectValue());
  }

  String getStringValue() {
    return _wrap(_ptr.getStringValue());
  }

  void setFloatValue(int unitType, num floatValue) {
    _ptr.setFloatValue(_unwrap(unitType), _unwrap(floatValue));
    return;
  }

  void setStringValue(int stringType, String stringValue) {
    _ptr.setStringValue(_unwrap(stringType), _unwrap(stringValue));
    return;
  }
}

class _CSSRuleImpl extends _DOMTypeBase implements CSSRule {
  _CSSRuleImpl._wrap(ptr) : super._wrap(ptr);

  String get cssText() => _wrap(_ptr.cssText);

  void set cssText(String value) { _ptr.cssText = _unwrap(value); }

  CSSRule get parentRule() => _wrap(_ptr.parentRule);

  CSSStyleSheet get parentStyleSheet() => _wrap(_ptr.parentStyleSheet);

  int get type() => _wrap(_ptr.type);
}

class _CSSRuleListImpl extends _DOMTypeBase implements CSSRuleList {
  _CSSRuleListImpl._wrap(ptr) : super._wrap(ptr);

  int get length() => _wrap(_ptr.length);

  CSSRule item(int index) {
    return _wrap(_ptr.item(_unwrap(index)));
  }
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

String _cachedBrowserPrefix;

String get _browserPrefix() {
  if (_cachedBrowserPrefix === null) {
    if (_Device.isFirefox) {
      _cachedBrowserPrefix = '-moz-';
    } else {
      _cachedBrowserPrefix = '-webkit-';
    }
    // TODO(jacobr): support IE 9.0 and Opera as well.
  }
  return _cachedBrowserPrefix;
}

class _CSSStyleDeclarationImpl extends _DOMTypeBase implements CSSStyleDeclaration {

  _CSSStyleDeclarationImpl._wrap(ptr) : super._wrap(ptr);

  String get cssText() => _wrap(_ptr.cssText);

  void set cssText(String value) { _ptr.cssText = _unwrap(value); }

  int get length() => _wrap(_ptr.length);

  CSSRule get parentRule() => _wrap(_ptr.parentRule);

  CSSValue getPropertyCSSValue(String propertyName) {
    return _wrap(_ptr.getPropertyCSSValue(_unwrap(propertyName)));
  }

  String getPropertyPriority(String propertyName) {
    return _wrap(_ptr.getPropertyPriority(_unwrap(propertyName)));
  }

  String getPropertyShorthand(String propertyName) {
    return _wrap(_ptr.getPropertyShorthand(_unwrap(propertyName)));
  }

  String getPropertyValue(String propertyName) {
    return _wrap(_ptr.getPropertyValue(_unwrap(propertyName)));
  }

  bool isPropertyImplicit(String propertyName) {
    return _wrap(_ptr.isPropertyImplicit(_unwrap(propertyName)));
  }

  String item(int index) {
    return _wrap(_ptr.item(_unwrap(index)));
  }

  String removeProperty(String propertyName) {
    return _wrap(_ptr.removeProperty(_unwrap(propertyName)));
  }

  void setProperty(String propertyName, String value, [String priority = null]) {
    if (priority === null) {
      _ptr.setProperty(_unwrap(propertyName), _unwrap(value));
      return;
    } else {
      _ptr.setProperty(_unwrap(propertyName), _unwrap(value), _unwrap(priority));
      return;
    }
  }


  // TODO(jacobr): generate this list of properties using the existing script.
    /** Gets the value of "animation" */
  String get animation() =>
    getPropertyValue('${_browserPrefix}animation');

  /** Sets the value of "animation" */
  void set animation(var value) {
    setProperty('${_browserPrefix}animation', value, '');
  }

  /** Gets the value of "animation-delay" */
  String get animationDelay() =>
    getPropertyValue('${_browserPrefix}animation-delay');

  /** Sets the value of "animation-delay" */
  void set animationDelay(var value) {
    setProperty('${_browserPrefix}animation-delay', value, '');
  }

  /** Gets the value of "animation-direction" */
  String get animationDirection() =>
    getPropertyValue('${_browserPrefix}animation-direction');

  /** Sets the value of "animation-direction" */
  void set animationDirection(var value) {
    setProperty('${_browserPrefix}animation-direction', value, '');
  }

  /** Gets the value of "animation-duration" */
  String get animationDuration() =>
    getPropertyValue('${_browserPrefix}animation-duration');

  /** Sets the value of "animation-duration" */
  void set animationDuration(var value) {
    setProperty('${_browserPrefix}animation-duration', value, '');
  }

  /** Gets the value of "animation-fill-mode" */
  String get animationFillMode() =>
    getPropertyValue('${_browserPrefix}animation-fill-mode');

  /** Sets the value of "animation-fill-mode" */
  void set animationFillMode(var value) {
    setProperty('${_browserPrefix}animation-fill-mode', value, '');
  }

  /** Gets the value of "animation-iteration-count" */
  String get animationIterationCount() =>
    getPropertyValue('${_browserPrefix}animation-iteration-count');

  /** Sets the value of "animation-iteration-count" */
  void set animationIterationCount(var value) {
    setProperty('${_browserPrefix}animation-iteration-count', value, '');
  }

  /** Gets the value of "animation-name" */
  String get animationName() =>
    getPropertyValue('${_browserPrefix}animation-name');

  /** Sets the value of "animation-name" */
  void set animationName(var value) {
    setProperty('${_browserPrefix}animation-name', value, '');
  }

  /** Gets the value of "animation-play-state" */
  String get animationPlayState() =>
    getPropertyValue('${_browserPrefix}animation-play-state');

  /** Sets the value of "animation-play-state" */
  void set animationPlayState(var value) {
    setProperty('${_browserPrefix}animation-play-state', value, '');
  }

  /** Gets the value of "animation-timing-function" */
  String get animationTimingFunction() =>
    getPropertyValue('${_browserPrefix}animation-timing-function');

  /** Sets the value of "animation-timing-function" */
  void set animationTimingFunction(var value) {
    setProperty('${_browserPrefix}animation-timing-function', value, '');
  }

  /** Gets the value of "appearance" */
  String get appearance() =>
    getPropertyValue('${_browserPrefix}appearance');

  /** Sets the value of "appearance" */
  void set appearance(var value) {
    setProperty('${_browserPrefix}appearance', value, '');
  }

  /** Gets the value of "backface-visibility" */
  String get backfaceVisibility() =>
    getPropertyValue('${_browserPrefix}backface-visibility');

  /** Sets the value of "backface-visibility" */
  void set backfaceVisibility(var value) {
    setProperty('${_browserPrefix}backface-visibility', value, '');
  }

  /** Gets the value of "background" */
  String get background() =>
    getPropertyValue('background');

  /** Sets the value of "background" */
  void set background(var value) {
    setProperty('background', value, '');
  }

  /** Gets the value of "background-attachment" */
  String get backgroundAttachment() =>
    getPropertyValue('background-attachment');

  /** Sets the value of "background-attachment" */
  void set backgroundAttachment(var value) {
    setProperty('background-attachment', value, '');
  }

  /** Gets the value of "background-clip" */
  String get backgroundClip() =>
    getPropertyValue('background-clip');

  /** Sets the value of "background-clip" */
  void set backgroundClip(var value) {
    setProperty('background-clip', value, '');
  }

  /** Gets the value of "background-color" */
  String get backgroundColor() =>
    getPropertyValue('background-color');

  /** Sets the value of "background-color" */
  void set backgroundColor(var value) {
    setProperty('background-color', value, '');
  }

  /** Gets the value of "background-composite" */
  String get backgroundComposite() =>
    getPropertyValue('${_browserPrefix}background-composite');

  /** Sets the value of "background-composite" */
  void set backgroundComposite(var value) {
    setProperty('${_browserPrefix}background-composite', value, '');
  }

  /** Gets the value of "background-image" */
  String get backgroundImage() =>
    getPropertyValue('background-image');

  /** Sets the value of "background-image" */
  void set backgroundImage(var value) {
    setProperty('background-image', value, '');
  }

  /** Gets the value of "background-origin" */
  String get backgroundOrigin() =>
    getPropertyValue('background-origin');

  /** Sets the value of "background-origin" */
  void set backgroundOrigin(var value) {
    setProperty('background-origin', value, '');
  }

  /** Gets the value of "background-position" */
  String get backgroundPosition() =>
    getPropertyValue('background-position');

  /** Sets the value of "background-position" */
  void set backgroundPosition(var value) {
    setProperty('background-position', value, '');
  }

  /** Gets the value of "background-position-x" */
  String get backgroundPositionX() =>
    getPropertyValue('background-position-x');

  /** Sets the value of "background-position-x" */
  void set backgroundPositionX(var value) {
    setProperty('background-position-x', value, '');
  }

  /** Gets the value of "background-position-y" */
  String get backgroundPositionY() =>
    getPropertyValue('background-position-y');

  /** Sets the value of "background-position-y" */
  void set backgroundPositionY(var value) {
    setProperty('background-position-y', value, '');
  }

  /** Gets the value of "background-repeat" */
  String get backgroundRepeat() =>
    getPropertyValue('background-repeat');

  /** Sets the value of "background-repeat" */
  void set backgroundRepeat(var value) {
    setProperty('background-repeat', value, '');
  }

  /** Gets the value of "background-repeat-x" */
  String get backgroundRepeatX() =>
    getPropertyValue('background-repeat-x');

  /** Sets the value of "background-repeat-x" */
  void set backgroundRepeatX(var value) {
    setProperty('background-repeat-x', value, '');
  }

  /** Gets the value of "background-repeat-y" */
  String get backgroundRepeatY() =>
    getPropertyValue('background-repeat-y');

  /** Sets the value of "background-repeat-y" */
  void set backgroundRepeatY(var value) {
    setProperty('background-repeat-y', value, '');
  }

  /** Gets the value of "background-size" */
  String get backgroundSize() =>
    getPropertyValue('background-size');

  /** Sets the value of "background-size" */
  void set backgroundSize(var value) {
    setProperty('background-size', value, '');
  }

  /** Gets the value of "border" */
  String get border() =>
    getPropertyValue('border');

  /** Sets the value of "border" */
  void set border(var value) {
    setProperty('border', value, '');
  }

  /** Gets the value of "border-after" */
  String get borderAfter() =>
    getPropertyValue('${_browserPrefix}border-after');

  /** Sets the value of "border-after" */
  void set borderAfter(var value) {
    setProperty('${_browserPrefix}border-after', value, '');
  }

  /** Gets the value of "border-after-color" */
  String get borderAfterColor() =>
    getPropertyValue('${_browserPrefix}border-after-color');

  /** Sets the value of "border-after-color" */
  void set borderAfterColor(var value) {
    setProperty('${_browserPrefix}border-after-color', value, '');
  }

  /** Gets the value of "border-after-style" */
  String get borderAfterStyle() =>
    getPropertyValue('${_browserPrefix}border-after-style');

  /** Sets the value of "border-after-style" */
  void set borderAfterStyle(var value) {
    setProperty('${_browserPrefix}border-after-style', value, '');
  }

  /** Gets the value of "border-after-width" */
  String get borderAfterWidth() =>
    getPropertyValue('${_browserPrefix}border-after-width');

  /** Sets the value of "border-after-width" */
  void set borderAfterWidth(var value) {
    setProperty('${_browserPrefix}border-after-width', value, '');
  }

  /** Gets the value of "border-before" */
  String get borderBefore() =>
    getPropertyValue('${_browserPrefix}border-before');

  /** Sets the value of "border-before" */
  void set borderBefore(var value) {
    setProperty('${_browserPrefix}border-before', value, '');
  }

  /** Gets the value of "border-before-color" */
  String get borderBeforeColor() =>
    getPropertyValue('${_browserPrefix}border-before-color');

  /** Sets the value of "border-before-color" */
  void set borderBeforeColor(var value) {
    setProperty('${_browserPrefix}border-before-color', value, '');
  }

  /** Gets the value of "border-before-style" */
  String get borderBeforeStyle() =>
    getPropertyValue('${_browserPrefix}border-before-style');

  /** Sets the value of "border-before-style" */
  void set borderBeforeStyle(var value) {
    setProperty('${_browserPrefix}border-before-style', value, '');
  }

  /** Gets the value of "border-before-width" */
  String get borderBeforeWidth() =>
    getPropertyValue('${_browserPrefix}border-before-width');

  /** Sets the value of "border-before-width" */
  void set borderBeforeWidth(var value) {
    setProperty('${_browserPrefix}border-before-width', value, '');
  }

  /** Gets the value of "border-bottom" */
  String get borderBottom() =>
    getPropertyValue('border-bottom');

  /** Sets the value of "border-bottom" */
  void set borderBottom(var value) {
    setProperty('border-bottom', value, '');
  }

  /** Gets the value of "border-bottom-color" */
  String get borderBottomColor() =>
    getPropertyValue('border-bottom-color');

  /** Sets the value of "border-bottom-color" */
  void set borderBottomColor(var value) {
    setProperty('border-bottom-color', value, '');
  }

  /** Gets the value of "border-bottom-left-radius" */
  String get borderBottomLeftRadius() =>
    getPropertyValue('border-bottom-left-radius');

  /** Sets the value of "border-bottom-left-radius" */
  void set borderBottomLeftRadius(var value) {
    setProperty('border-bottom-left-radius', value, '');
  }

  /** Gets the value of "border-bottom-right-radius" */
  String get borderBottomRightRadius() =>
    getPropertyValue('border-bottom-right-radius');

  /** Sets the value of "border-bottom-right-radius" */
  void set borderBottomRightRadius(var value) {
    setProperty('border-bottom-right-radius', value, '');
  }

  /** Gets the value of "border-bottom-style" */
  String get borderBottomStyle() =>
    getPropertyValue('border-bottom-style');

  /** Sets the value of "border-bottom-style" */
  void set borderBottomStyle(var value) {
    setProperty('border-bottom-style', value, '');
  }

  /** Gets the value of "border-bottom-width" */
  String get borderBottomWidth() =>
    getPropertyValue('border-bottom-width');

  /** Sets the value of "border-bottom-width" */
  void set borderBottomWidth(var value) {
    setProperty('border-bottom-width', value, '');
  }

  /** Gets the value of "border-collapse" */
  String get borderCollapse() =>
    getPropertyValue('border-collapse');

  /** Sets the value of "border-collapse" */
  void set borderCollapse(var value) {
    setProperty('border-collapse', value, '');
  }

  /** Gets the value of "border-color" */
  String get borderColor() =>
    getPropertyValue('border-color');

  /** Sets the value of "border-color" */
  void set borderColor(var value) {
    setProperty('border-color', value, '');
  }

  /** Gets the value of "border-end" */
  String get borderEnd() =>
    getPropertyValue('${_browserPrefix}border-end');

  /** Sets the value of "border-end" */
  void set borderEnd(var value) {
    setProperty('${_browserPrefix}border-end', value, '');
  }

  /** Gets the value of "border-end-color" */
  String get borderEndColor() =>
    getPropertyValue('${_browserPrefix}border-end-color');

  /** Sets the value of "border-end-color" */
  void set borderEndColor(var value) {
    setProperty('${_browserPrefix}border-end-color', value, '');
  }

  /** Gets the value of "border-end-style" */
  String get borderEndStyle() =>
    getPropertyValue('${_browserPrefix}border-end-style');

  /** Sets the value of "border-end-style" */
  void set borderEndStyle(var value) {
    setProperty('${_browserPrefix}border-end-style', value, '');
  }

  /** Gets the value of "border-end-width" */
  String get borderEndWidth() =>
    getPropertyValue('${_browserPrefix}border-end-width');

  /** Sets the value of "border-end-width" */
  void set borderEndWidth(var value) {
    setProperty('${_browserPrefix}border-end-width', value, '');
  }

  /** Gets the value of "border-fit" */
  String get borderFit() =>
    getPropertyValue('${_browserPrefix}border-fit');

  /** Sets the value of "border-fit" */
  void set borderFit(var value) {
    setProperty('${_browserPrefix}border-fit', value, '');
  }

  /** Gets the value of "border-horizontal-spacing" */
  String get borderHorizontalSpacing() =>
    getPropertyValue('${_browserPrefix}border-horizontal-spacing');

  /** Sets the value of "border-horizontal-spacing" */
  void set borderHorizontalSpacing(var value) {
    setProperty('${_browserPrefix}border-horizontal-spacing', value, '');
  }

  /** Gets the value of "border-image" */
  String get borderImage() =>
    getPropertyValue('border-image');

  /** Sets the value of "border-image" */
  void set borderImage(var value) {
    setProperty('border-image', value, '');
  }

  /** Gets the value of "border-image-outset" */
  String get borderImageOutset() =>
    getPropertyValue('border-image-outset');

  /** Sets the value of "border-image-outset" */
  void set borderImageOutset(var value) {
    setProperty('border-image-outset', value, '');
  }

  /** Gets the value of "border-image-repeat" */
  String get borderImageRepeat() =>
    getPropertyValue('border-image-repeat');

  /** Sets the value of "border-image-repeat" */
  void set borderImageRepeat(var value) {
    setProperty('border-image-repeat', value, '');
  }

  /** Gets the value of "border-image-slice" */
  String get borderImageSlice() =>
    getPropertyValue('border-image-slice');

  /** Sets the value of "border-image-slice" */
  void set borderImageSlice(var value) {
    setProperty('border-image-slice', value, '');
  }

  /** Gets the value of "border-image-source" */
  String get borderImageSource() =>
    getPropertyValue('border-image-source');

  /** Sets the value of "border-image-source" */
  void set borderImageSource(var value) {
    setProperty('border-image-source', value, '');
  }

  /** Gets the value of "border-image-width" */
  String get borderImageWidth() =>
    getPropertyValue('border-image-width');

  /** Sets the value of "border-image-width" */
  void set borderImageWidth(var value) {
    setProperty('border-image-width', value, '');
  }

  /** Gets the value of "border-left" */
  String get borderLeft() =>
    getPropertyValue('border-left');

  /** Sets the value of "border-left" */
  void set borderLeft(var value) {
    setProperty('border-left', value, '');
  }

  /** Gets the value of "border-left-color" */
  String get borderLeftColor() =>
    getPropertyValue('border-left-color');

  /** Sets the value of "border-left-color" */
  void set borderLeftColor(var value) {
    setProperty('border-left-color', value, '');
  }

  /** Gets the value of "border-left-style" */
  String get borderLeftStyle() =>
    getPropertyValue('border-left-style');

  /** Sets the value of "border-left-style" */
  void set borderLeftStyle(var value) {
    setProperty('border-left-style', value, '');
  }

  /** Gets the value of "border-left-width" */
  String get borderLeftWidth() =>
    getPropertyValue('border-left-width');

  /** Sets the value of "border-left-width" */
  void set borderLeftWidth(var value) {
    setProperty('border-left-width', value, '');
  }

  /** Gets the value of "border-radius" */
  String get borderRadius() =>
    getPropertyValue('border-radius');

  /** Sets the value of "border-radius" */
  void set borderRadius(var value) {
    setProperty('border-radius', value, '');
  }

  /** Gets the value of "border-right" */
  String get borderRight() =>
    getPropertyValue('border-right');

  /** Sets the value of "border-right" */
  void set borderRight(var value) {
    setProperty('border-right', value, '');
  }

  /** Gets the value of "border-right-color" */
  String get borderRightColor() =>
    getPropertyValue('border-right-color');

  /** Sets the value of "border-right-color" */
  void set borderRightColor(var value) {
    setProperty('border-right-color', value, '');
  }

  /** Gets the value of "border-right-style" */
  String get borderRightStyle() =>
    getPropertyValue('border-right-style');

  /** Sets the value of "border-right-style" */
  void set borderRightStyle(var value) {
    setProperty('border-right-style', value, '');
  }

  /** Gets the value of "border-right-width" */
  String get borderRightWidth() =>
    getPropertyValue('border-right-width');

  /** Sets the value of "border-right-width" */
  void set borderRightWidth(var value) {
    setProperty('border-right-width', value, '');
  }

  /** Gets the value of "border-spacing" */
  String get borderSpacing() =>
    getPropertyValue('border-spacing');

  /** Sets the value of "border-spacing" */
  void set borderSpacing(var value) {
    setProperty('border-spacing', value, '');
  }

  /** Gets the value of "border-start" */
  String get borderStart() =>
    getPropertyValue('${_browserPrefix}border-start');

  /** Sets the value of "border-start" */
  void set borderStart(var value) {
    setProperty('${_browserPrefix}border-start', value, '');
  }

  /** Gets the value of "border-start-color" */
  String get borderStartColor() =>
    getPropertyValue('${_browserPrefix}border-start-color');

  /** Sets the value of "border-start-color" */
  void set borderStartColor(var value) {
    setProperty('${_browserPrefix}border-start-color', value, '');
  }

  /** Gets the value of "border-start-style" */
  String get borderStartStyle() =>
    getPropertyValue('${_browserPrefix}border-start-style');

  /** Sets the value of "border-start-style" */
  void set borderStartStyle(var value) {
    setProperty('${_browserPrefix}border-start-style', value, '');
  }

  /** Gets the value of "border-start-width" */
  String get borderStartWidth() =>
    getPropertyValue('${_browserPrefix}border-start-width');

  /** Sets the value of "border-start-width" */
  void set borderStartWidth(var value) {
    setProperty('${_browserPrefix}border-start-width', value, '');
  }

  /** Gets the value of "border-style" */
  String get borderStyle() =>
    getPropertyValue('border-style');

  /** Sets the value of "border-style" */
  void set borderStyle(var value) {
    setProperty('border-style', value, '');
  }

  /** Gets the value of "border-top" */
  String get borderTop() =>
    getPropertyValue('border-top');

  /** Sets the value of "border-top" */
  void set borderTop(var value) {
    setProperty('border-top', value, '');
  }

  /** Gets the value of "border-top-color" */
  String get borderTopColor() =>
    getPropertyValue('border-top-color');

  /** Sets the value of "border-top-color" */
  void set borderTopColor(var value) {
    setProperty('border-top-color', value, '');
  }

  /** Gets the value of "border-top-left-radius" */
  String get borderTopLeftRadius() =>
    getPropertyValue('border-top-left-radius');

  /** Sets the value of "border-top-left-radius" */
  void set borderTopLeftRadius(var value) {
    setProperty('border-top-left-radius', value, '');
  }

  /** Gets the value of "border-top-right-radius" */
  String get borderTopRightRadius() =>
    getPropertyValue('border-top-right-radius');

  /** Sets the value of "border-top-right-radius" */
  void set borderTopRightRadius(var value) {
    setProperty('border-top-right-radius', value, '');
  }

  /** Gets the value of "border-top-style" */
  String get borderTopStyle() =>
    getPropertyValue('border-top-style');

  /** Sets the value of "border-top-style" */
  void set borderTopStyle(var value) {
    setProperty('border-top-style', value, '');
  }

  /** Gets the value of "border-top-width" */
  String get borderTopWidth() =>
    getPropertyValue('border-top-width');

  /** Sets the value of "border-top-width" */
  void set borderTopWidth(var value) {
    setProperty('border-top-width', value, '');
  }

  /** Gets the value of "border-vertical-spacing" */
  String get borderVerticalSpacing() =>
    getPropertyValue('${_browserPrefix}border-vertical-spacing');

  /** Sets the value of "border-vertical-spacing" */
  void set borderVerticalSpacing(var value) {
    setProperty('${_browserPrefix}border-vertical-spacing', value, '');
  }

  /** Gets the value of "border-width" */
  String get borderWidth() =>
    getPropertyValue('border-width');

  /** Sets the value of "border-width" */
  void set borderWidth(var value) {
    setProperty('border-width', value, '');
  }

  /** Gets the value of "bottom" */
  String get bottom() =>
    getPropertyValue('bottom');

  /** Sets the value of "bottom" */
  void set bottom(var value) {
    setProperty('bottom', value, '');
  }

  /** Gets the value of "box-align" */
  String get boxAlign() =>
    getPropertyValue('${_browserPrefix}box-align');

  /** Sets the value of "box-align" */
  void set boxAlign(var value) {
    setProperty('${_browserPrefix}box-align', value, '');
  }

  /** Gets the value of "box-direction" */
  String get boxDirection() =>
    getPropertyValue('${_browserPrefix}box-direction');

  /** Sets the value of "box-direction" */
  void set boxDirection(var value) {
    setProperty('${_browserPrefix}box-direction', value, '');
  }

  /** Gets the value of "box-flex" */
  String get boxFlex() =>
    getPropertyValue('${_browserPrefix}box-flex');

  /** Sets the value of "box-flex" */
  void set boxFlex(var value) {
    setProperty('${_browserPrefix}box-flex', value, '');
  }

  /** Gets the value of "box-flex-group" */
  String get boxFlexGroup() =>
    getPropertyValue('${_browserPrefix}box-flex-group');

  /** Sets the value of "box-flex-group" */
  void set boxFlexGroup(var value) {
    setProperty('${_browserPrefix}box-flex-group', value, '');
  }

  /** Gets the value of "box-lines" */
  String get boxLines() =>
    getPropertyValue('${_browserPrefix}box-lines');

  /** Sets the value of "box-lines" */
  void set boxLines(var value) {
    setProperty('${_browserPrefix}box-lines', value, '');
  }

  /** Gets the value of "box-ordinal-group" */
  String get boxOrdinalGroup() =>
    getPropertyValue('${_browserPrefix}box-ordinal-group');

  /** Sets the value of "box-ordinal-group" */
  void set boxOrdinalGroup(var value) {
    setProperty('${_browserPrefix}box-ordinal-group', value, '');
  }

  /** Gets the value of "box-orient" */
  String get boxOrient() =>
    getPropertyValue('${_browserPrefix}box-orient');

  /** Sets the value of "box-orient" */
  void set boxOrient(var value) {
    setProperty('${_browserPrefix}box-orient', value, '');
  }

  /** Gets the value of "box-pack" */
  String get boxPack() =>
    getPropertyValue('${_browserPrefix}box-pack');

  /** Sets the value of "box-pack" */
  void set boxPack(var value) {
    setProperty('${_browserPrefix}box-pack', value, '');
  }

  /** Gets the value of "box-reflect" */
  String get boxReflect() =>
    getPropertyValue('${_browserPrefix}box-reflect');

  /** Sets the value of "box-reflect" */
  void set boxReflect(var value) {
    setProperty('${_browserPrefix}box-reflect', value, '');
  }

  /** Gets the value of "box-shadow" */
  String get boxShadow() =>
    getPropertyValue('box-shadow');

  /** Sets the value of "box-shadow" */
  void set boxShadow(var value) {
    setProperty('box-shadow', value, '');
  }

  /** Gets the value of "box-sizing" */
  String get boxSizing() =>
    getPropertyValue('box-sizing');

  /** Sets the value of "box-sizing" */
  void set boxSizing(var value) {
    setProperty('box-sizing', value, '');
  }

  /** Gets the value of "caption-side" */
  String get captionSide() =>
    getPropertyValue('caption-side');

  /** Sets the value of "caption-side" */
  void set captionSide(var value) {
    setProperty('caption-side', value, '');
  }

  /** Gets the value of "clear" */
  String get clear() =>
    getPropertyValue('clear');

  /** Sets the value of "clear" */
  void set clear(var value) {
    setProperty('clear', value, '');
  }

  /** Gets the value of "clip" */
  String get clip() =>
    getPropertyValue('clip');

  /** Sets the value of "clip" */
  void set clip(var value) {
    setProperty('clip', value, '');
  }

  /** Gets the value of "color" */
  String get color() =>
    getPropertyValue('color');

  /** Sets the value of "color" */
  void set color(var value) {
    setProperty('color', value, '');
  }

  /** Gets the value of "color-correction" */
  String get colorCorrection() =>
    getPropertyValue('${_browserPrefix}color-correction');

  /** Sets the value of "color-correction" */
  void set colorCorrection(var value) {
    setProperty('${_browserPrefix}color-correction', value, '');
  }

  /** Gets the value of "column-break-after" */
  String get columnBreakAfter() =>
    getPropertyValue('${_browserPrefix}column-break-after');

  /** Sets the value of "column-break-after" */
  void set columnBreakAfter(var value) {
    setProperty('${_browserPrefix}column-break-after', value, '');
  }

  /** Gets the value of "column-break-before" */
  String get columnBreakBefore() =>
    getPropertyValue('${_browserPrefix}column-break-before');

  /** Sets the value of "column-break-before" */
  void set columnBreakBefore(var value) {
    setProperty('${_browserPrefix}column-break-before', value, '');
  }

  /** Gets the value of "column-break-inside" */
  String get columnBreakInside() =>
    getPropertyValue('${_browserPrefix}column-break-inside');

  /** Sets the value of "column-break-inside" */
  void set columnBreakInside(var value) {
    setProperty('${_browserPrefix}column-break-inside', value, '');
  }

  /** Gets the value of "column-count" */
  String get columnCount() =>
    getPropertyValue('${_browserPrefix}column-count');

  /** Sets the value of "column-count" */
  void set columnCount(var value) {
    setProperty('${_browserPrefix}column-count', value, '');
  }

  /** Gets the value of "column-gap" */
  String get columnGap() =>
    getPropertyValue('${_browserPrefix}column-gap');

  /** Sets the value of "column-gap" */
  void set columnGap(var value) {
    setProperty('${_browserPrefix}column-gap', value, '');
  }

  /** Gets the value of "column-rule" */
  String get columnRule() =>
    getPropertyValue('${_browserPrefix}column-rule');

  /** Sets the value of "column-rule" */
  void set columnRule(var value) {
    setProperty('${_browserPrefix}column-rule', value, '');
  }

  /** Gets the value of "column-rule-color" */
  String get columnRuleColor() =>
    getPropertyValue('${_browserPrefix}column-rule-color');

  /** Sets the value of "column-rule-color" */
  void set columnRuleColor(var value) {
    setProperty('${_browserPrefix}column-rule-color', value, '');
  }

  /** Gets the value of "column-rule-style" */
  String get columnRuleStyle() =>
    getPropertyValue('${_browserPrefix}column-rule-style');

  /** Sets the value of "column-rule-style" */
  void set columnRuleStyle(var value) {
    setProperty('${_browserPrefix}column-rule-style', value, '');
  }

  /** Gets the value of "column-rule-width" */
  String get columnRuleWidth() =>
    getPropertyValue('${_browserPrefix}column-rule-width');

  /** Sets the value of "column-rule-width" */
  void set columnRuleWidth(var value) {
    setProperty('${_browserPrefix}column-rule-width', value, '');
  }

  /** Gets the value of "column-span" */
  String get columnSpan() =>
    getPropertyValue('${_browserPrefix}column-span');

  /** Sets the value of "column-span" */
  void set columnSpan(var value) {
    setProperty('${_browserPrefix}column-span', value, '');
  }

  /** Gets the value of "column-width" */
  String get columnWidth() =>
    getPropertyValue('${_browserPrefix}column-width');

  /** Sets the value of "column-width" */
  void set columnWidth(var value) {
    setProperty('${_browserPrefix}column-width', value, '');
  }

  /** Gets the value of "columns" */
  String get columns() =>
    getPropertyValue('${_browserPrefix}columns');

  /** Sets the value of "columns" */
  void set columns(var value) {
    setProperty('${_browserPrefix}columns', value, '');
  }

  /** Gets the value of "content" */
  String get content() =>
    getPropertyValue('content');

  /** Sets the value of "content" */
  void set content(var value) {
    setProperty('content', value, '');
  }

  /** Gets the value of "counter-increment" */
  String get counterIncrement() =>
    getPropertyValue('counter-increment');

  /** Sets the value of "counter-increment" */
  void set counterIncrement(var value) {
    setProperty('counter-increment', value, '');
  }

  /** Gets the value of "counter-reset" */
  String get counterReset() =>
    getPropertyValue('counter-reset');

  /** Sets the value of "counter-reset" */
  void set counterReset(var value) {
    setProperty('counter-reset', value, '');
  }

  /** Gets the value of "cursor" */
  String get cursor() =>
    getPropertyValue('cursor');

  /** Sets the value of "cursor" */
  void set cursor(var value) {
    setProperty('cursor', value, '');
  }

  /** Gets the value of "direction" */
  String get direction() =>
    getPropertyValue('direction');

  /** Sets the value of "direction" */
  void set direction(var value) {
    setProperty('direction', value, '');
  }

  /** Gets the value of "display" */
  String get display() =>
    getPropertyValue('display');

  /** Sets the value of "display" */
  void set display(var value) {
    setProperty('display', value, '');
  }

  /** Gets the value of "empty-cells" */
  String get emptyCells() =>
    getPropertyValue('empty-cells');

  /** Sets the value of "empty-cells" */
  void set emptyCells(var value) {
    setProperty('empty-cells', value, '');
  }

  /** Gets the value of "filter" */
  String get filter() =>
    getPropertyValue('${_browserPrefix}filter');

  /** Sets the value of "filter" */
  void set filter(var value) {
    setProperty('${_browserPrefix}filter', value, '');
  }

  /** Gets the value of "flex-align" */
  String get flexAlign() =>
    getPropertyValue('${_browserPrefix}flex-align');

  /** Sets the value of "flex-align" */
  void set flexAlign(var value) {
    setProperty('${_browserPrefix}flex-align', value, '');
  }

  /** Gets the value of "flex-flow" */
  String get flexFlow() =>
    getPropertyValue('${_browserPrefix}flex-flow');

  /** Sets the value of "flex-flow" */
  void set flexFlow(var value) {
    setProperty('${_browserPrefix}flex-flow', value, '');
  }

  /** Gets the value of "flex-order" */
  String get flexOrder() =>
    getPropertyValue('${_browserPrefix}flex-order');

  /** Sets the value of "flex-order" */
  void set flexOrder(var value) {
    setProperty('${_browserPrefix}flex-order', value, '');
  }

  /** Gets the value of "flex-pack" */
  String get flexPack() =>
    getPropertyValue('${_browserPrefix}flex-pack');

  /** Sets the value of "flex-pack" */
  void set flexPack(var value) {
    setProperty('${_browserPrefix}flex-pack', value, '');
  }

  /** Gets the value of "float" */
  String get float() =>
    getPropertyValue('float');

  /** Sets the value of "float" */
  void set float(var value) {
    setProperty('float', value, '');
  }

  /** Gets the value of "flow-from" */
  String get flowFrom() =>
    getPropertyValue('${_browserPrefix}flow-from');

  /** Sets the value of "flow-from" */
  void set flowFrom(var value) {
    setProperty('${_browserPrefix}flow-from', value, '');
  }

  /** Gets the value of "flow-into" */
  String get flowInto() =>
    getPropertyValue('${_browserPrefix}flow-into');

  /** Sets the value of "flow-into" */
  void set flowInto(var value) {
    setProperty('${_browserPrefix}flow-into', value, '');
  }

  /** Gets the value of "font" */
  String get font() =>
    getPropertyValue('font');

  /** Sets the value of "font" */
  void set font(var value) {
    setProperty('font', value, '');
  }

  /** Gets the value of "font-family" */
  String get fontFamily() =>
    getPropertyValue('font-family');

  /** Sets the value of "font-family" */
  void set fontFamily(var value) {
    setProperty('font-family', value, '');
  }

  /** Gets the value of "font-feature-settings" */
  String get fontFeatureSettings() =>
    getPropertyValue('${_browserPrefix}font-feature-settings');

  /** Sets the value of "font-feature-settings" */
  void set fontFeatureSettings(var value) {
    setProperty('${_browserPrefix}font-feature-settings', value, '');
  }

  /** Gets the value of "font-size" */
  String get fontSize() =>
    getPropertyValue('font-size');

  /** Sets the value of "font-size" */
  void set fontSize(var value) {
    setProperty('font-size', value, '');
  }

  /** Gets the value of "font-size-delta" */
  String get fontSizeDelta() =>
    getPropertyValue('${_browserPrefix}font-size-delta');

  /** Sets the value of "font-size-delta" */
  void set fontSizeDelta(var value) {
    setProperty('${_browserPrefix}font-size-delta', value, '');
  }

  /** Gets the value of "font-smoothing" */
  String get fontSmoothing() =>
    getPropertyValue('${_browserPrefix}font-smoothing');

  /** Sets the value of "font-smoothing" */
  void set fontSmoothing(var value) {
    setProperty('${_browserPrefix}font-smoothing', value, '');
  }

  /** Gets the value of "font-stretch" */
  String get fontStretch() =>
    getPropertyValue('font-stretch');

  /** Sets the value of "font-stretch" */
  void set fontStretch(var value) {
    setProperty('font-stretch', value, '');
  }

  /** Gets the value of "font-style" */
  String get fontStyle() =>
    getPropertyValue('font-style');

  /** Sets the value of "font-style" */
  void set fontStyle(var value) {
    setProperty('font-style', value, '');
  }

  /** Gets the value of "font-variant" */
  String get fontVariant() =>
    getPropertyValue('font-variant');

  /** Sets the value of "font-variant" */
  void set fontVariant(var value) {
    setProperty('font-variant', value, '');
  }

  /** Gets the value of "font-weight" */
  String get fontWeight() =>
    getPropertyValue('font-weight');

  /** Sets the value of "font-weight" */
  void set fontWeight(var value) {
    setProperty('font-weight', value, '');
  }

  /** Gets the value of "height" */
  String get height() =>
    getPropertyValue('height');

  /** Sets the value of "height" */
  void set height(var value) {
    setProperty('height', value, '');
  }

  /** Gets the value of "highlight" */
  String get highlight() =>
    getPropertyValue('${_browserPrefix}highlight');

  /** Sets the value of "highlight" */
  void set highlight(var value) {
    setProperty('${_browserPrefix}highlight', value, '');
  }

  /** Gets the value of "hyphenate-character" */
  String get hyphenateCharacter() =>
    getPropertyValue('${_browserPrefix}hyphenate-character');

  /** Sets the value of "hyphenate-character" */
  void set hyphenateCharacter(var value) {
    setProperty('${_browserPrefix}hyphenate-character', value, '');
  }

  /** Gets the value of "hyphenate-limit-after" */
  String get hyphenateLimitAfter() =>
    getPropertyValue('${_browserPrefix}hyphenate-limit-after');

  /** Sets the value of "hyphenate-limit-after" */
  void set hyphenateLimitAfter(var value) {
    setProperty('${_browserPrefix}hyphenate-limit-after', value, '');
  }

  /** Gets the value of "hyphenate-limit-before" */
  String get hyphenateLimitBefore() =>
    getPropertyValue('${_browserPrefix}hyphenate-limit-before');

  /** Sets the value of "hyphenate-limit-before" */
  void set hyphenateLimitBefore(var value) {
    setProperty('${_browserPrefix}hyphenate-limit-before', value, '');
  }

  /** Gets the value of "hyphenate-limit-lines" */
  String get hyphenateLimitLines() =>
    getPropertyValue('${_browserPrefix}hyphenate-limit-lines');

  /** Sets the value of "hyphenate-limit-lines" */
  void set hyphenateLimitLines(var value) {
    setProperty('${_browserPrefix}hyphenate-limit-lines', value, '');
  }

  /** Gets the value of "hyphens" */
  String get hyphens() =>
    getPropertyValue('${_browserPrefix}hyphens');

  /** Sets the value of "hyphens" */
  void set hyphens(var value) {
    setProperty('${_browserPrefix}hyphens', value, '');
  }

  /** Gets the value of "image-rendering" */
  String get imageRendering() =>
    getPropertyValue('image-rendering');

  /** Sets the value of "image-rendering" */
  void set imageRendering(var value) {
    setProperty('image-rendering', value, '');
  }

  /** Gets the value of "left" */
  String get left() =>
    getPropertyValue('left');

  /** Sets the value of "left" */
  void set left(var value) {
    setProperty('left', value, '');
  }

  /** Gets the value of "letter-spacing" */
  String get letterSpacing() =>
    getPropertyValue('letter-spacing');

  /** Sets the value of "letter-spacing" */
  void set letterSpacing(var value) {
    setProperty('letter-spacing', value, '');
  }

  /** Gets the value of "line-box-contain" */
  String get lineBoxContain() =>
    getPropertyValue('${_browserPrefix}line-box-contain');

  /** Sets the value of "line-box-contain" */
  void set lineBoxContain(var value) {
    setProperty('${_browserPrefix}line-box-contain', value, '');
  }

  /** Gets the value of "line-break" */
  String get lineBreak() =>
    getPropertyValue('${_browserPrefix}line-break');

  /** Sets the value of "line-break" */
  void set lineBreak(var value) {
    setProperty('${_browserPrefix}line-break', value, '');
  }

  /** Gets the value of "line-clamp" */
  String get lineClamp() =>
    getPropertyValue('${_browserPrefix}line-clamp');

  /** Sets the value of "line-clamp" */
  void set lineClamp(var value) {
    setProperty('${_browserPrefix}line-clamp', value, '');
  }

  /** Gets the value of "line-height" */
  String get lineHeight() =>
    getPropertyValue('line-height');

  /** Sets the value of "line-height" */
  void set lineHeight(var value) {
    setProperty('line-height', value, '');
  }

  /** Gets the value of "list-style" */
  String get listStyle() =>
    getPropertyValue('list-style');

  /** Sets the value of "list-style" */
  void set listStyle(var value) {
    setProperty('list-style', value, '');
  }

  /** Gets the value of "list-style-image" */
  String get listStyleImage() =>
    getPropertyValue('list-style-image');

  /** Sets the value of "list-style-image" */
  void set listStyleImage(var value) {
    setProperty('list-style-image', value, '');
  }

  /** Gets the value of "list-style-position" */
  String get listStylePosition() =>
    getPropertyValue('list-style-position');

  /** Sets the value of "list-style-position" */
  void set listStylePosition(var value) {
    setProperty('list-style-position', value, '');
  }

  /** Gets the value of "list-style-type" */
  String get listStyleType() =>
    getPropertyValue('list-style-type');

  /** Sets the value of "list-style-type" */
  void set listStyleType(var value) {
    setProperty('list-style-type', value, '');
  }

  /** Gets the value of "locale" */
  String get locale() =>
    getPropertyValue('${_browserPrefix}locale');

  /** Sets the value of "locale" */
  void set locale(var value) {
    setProperty('${_browserPrefix}locale', value, '');
  }

  /** Gets the value of "logical-height" */
  String get logicalHeight() =>
    getPropertyValue('${_browserPrefix}logical-height');

  /** Sets the value of "logical-height" */
  void set logicalHeight(var value) {
    setProperty('${_browserPrefix}logical-height', value, '');
  }

  /** Gets the value of "logical-width" */
  String get logicalWidth() =>
    getPropertyValue('${_browserPrefix}logical-width');

  /** Sets the value of "logical-width" */
  void set logicalWidth(var value) {
    setProperty('${_browserPrefix}logical-width', value, '');
  }

  /** Gets the value of "margin" */
  String get margin() =>
    getPropertyValue('margin');

  /** Sets the value of "margin" */
  void set margin(var value) {
    setProperty('margin', value, '');
  }

  /** Gets the value of "margin-after" */
  String get marginAfter() =>
    getPropertyValue('${_browserPrefix}margin-after');

  /** Sets the value of "margin-after" */
  void set marginAfter(var value) {
    setProperty('${_browserPrefix}margin-after', value, '');
  }

  /** Gets the value of "margin-after-collapse" */
  String get marginAfterCollapse() =>
    getPropertyValue('${_browserPrefix}margin-after-collapse');

  /** Sets the value of "margin-after-collapse" */
  void set marginAfterCollapse(var value) {
    setProperty('${_browserPrefix}margin-after-collapse', value, '');
  }

  /** Gets the value of "margin-before" */
  String get marginBefore() =>
    getPropertyValue('${_browserPrefix}margin-before');

  /** Sets the value of "margin-before" */
  void set marginBefore(var value) {
    setProperty('${_browserPrefix}margin-before', value, '');
  }

  /** Gets the value of "margin-before-collapse" */
  String get marginBeforeCollapse() =>
    getPropertyValue('${_browserPrefix}margin-before-collapse');

  /** Sets the value of "margin-before-collapse" */
  void set marginBeforeCollapse(var value) {
    setProperty('${_browserPrefix}margin-before-collapse', value, '');
  }

  /** Gets the value of "margin-bottom" */
  String get marginBottom() =>
    getPropertyValue('margin-bottom');

  /** Sets the value of "margin-bottom" */
  void set marginBottom(var value) {
    setProperty('margin-bottom', value, '');
  }

  /** Gets the value of "margin-bottom-collapse" */
  String get marginBottomCollapse() =>
    getPropertyValue('${_browserPrefix}margin-bottom-collapse');

  /** Sets the value of "margin-bottom-collapse" */
  void set marginBottomCollapse(var value) {
    setProperty('${_browserPrefix}margin-bottom-collapse', value, '');
  }

  /** Gets the value of "margin-collapse" */
  String get marginCollapse() =>
    getPropertyValue('${_browserPrefix}margin-collapse');

  /** Sets the value of "margin-collapse" */
  void set marginCollapse(var value) {
    setProperty('${_browserPrefix}margin-collapse', value, '');
  }

  /** Gets the value of "margin-end" */
  String get marginEnd() =>
    getPropertyValue('${_browserPrefix}margin-end');

  /** Sets the value of "margin-end" */
  void set marginEnd(var value) {
    setProperty('${_browserPrefix}margin-end', value, '');
  }

  /** Gets the value of "margin-left" */
  String get marginLeft() =>
    getPropertyValue('margin-left');

  /** Sets the value of "margin-left" */
  void set marginLeft(var value) {
    setProperty('margin-left', value, '');
  }

  /** Gets the value of "margin-right" */
  String get marginRight() =>
    getPropertyValue('margin-right');

  /** Sets the value of "margin-right" */
  void set marginRight(var value) {
    setProperty('margin-right', value, '');
  }

  /** Gets the value of "margin-start" */
  String get marginStart() =>
    getPropertyValue('${_browserPrefix}margin-start');

  /** Sets the value of "margin-start" */
  void set marginStart(var value) {
    setProperty('${_browserPrefix}margin-start', value, '');
  }

  /** Gets the value of "margin-top" */
  String get marginTop() =>
    getPropertyValue('margin-top');

  /** Sets the value of "margin-top" */
  void set marginTop(var value) {
    setProperty('margin-top', value, '');
  }

  /** Gets the value of "margin-top-collapse" */
  String get marginTopCollapse() =>
    getPropertyValue('${_browserPrefix}margin-top-collapse');

  /** Sets the value of "margin-top-collapse" */
  void set marginTopCollapse(var value) {
    setProperty('${_browserPrefix}margin-top-collapse', value, '');
  }

  /** Gets the value of "marquee" */
  String get marquee() =>
    getPropertyValue('${_browserPrefix}marquee');

  /** Sets the value of "marquee" */
  void set marquee(var value) {
    setProperty('${_browserPrefix}marquee', value, '');
  }

  /** Gets the value of "marquee-direction" */
  String get marqueeDirection() =>
    getPropertyValue('${_browserPrefix}marquee-direction');

  /** Sets the value of "marquee-direction" */
  void set marqueeDirection(var value) {
    setProperty('${_browserPrefix}marquee-direction', value, '');
  }

  /** Gets the value of "marquee-increment" */
  String get marqueeIncrement() =>
    getPropertyValue('${_browserPrefix}marquee-increment');

  /** Sets the value of "marquee-increment" */
  void set marqueeIncrement(var value) {
    setProperty('${_browserPrefix}marquee-increment', value, '');
  }

  /** Gets the value of "marquee-repetition" */
  String get marqueeRepetition() =>
    getPropertyValue('${_browserPrefix}marquee-repetition');

  /** Sets the value of "marquee-repetition" */
  void set marqueeRepetition(var value) {
    setProperty('${_browserPrefix}marquee-repetition', value, '');
  }

  /** Gets the value of "marquee-speed" */
  String get marqueeSpeed() =>
    getPropertyValue('${_browserPrefix}marquee-speed');

  /** Sets the value of "marquee-speed" */
  void set marqueeSpeed(var value) {
    setProperty('${_browserPrefix}marquee-speed', value, '');
  }

  /** Gets the value of "marquee-style" */
  String get marqueeStyle() =>
    getPropertyValue('${_browserPrefix}marquee-style');

  /** Sets the value of "marquee-style" */
  void set marqueeStyle(var value) {
    setProperty('${_browserPrefix}marquee-style', value, '');
  }

  /** Gets the value of "mask" */
  String get mask() =>
    getPropertyValue('${_browserPrefix}mask');

  /** Sets the value of "mask" */
  void set mask(var value) {
    setProperty('${_browserPrefix}mask', value, '');
  }

  /** Gets the value of "mask-attachment" */
  String get maskAttachment() =>
    getPropertyValue('${_browserPrefix}mask-attachment');

  /** Sets the value of "mask-attachment" */
  void set maskAttachment(var value) {
    setProperty('${_browserPrefix}mask-attachment', value, '');
  }

  /** Gets the value of "mask-box-image" */
  String get maskBoxImage() =>
    getPropertyValue('${_browserPrefix}mask-box-image');

  /** Sets the value of "mask-box-image" */
  void set maskBoxImage(var value) {
    setProperty('${_browserPrefix}mask-box-image', value, '');
  }

  /** Gets the value of "mask-box-image-outset" */
  String get maskBoxImageOutset() =>
    getPropertyValue('${_browserPrefix}mask-box-image-outset');

  /** Sets the value of "mask-box-image-outset" */
  void set maskBoxImageOutset(var value) {
    setProperty('${_browserPrefix}mask-box-image-outset', value, '');
  }

  /** Gets the value of "mask-box-image-repeat" */
  String get maskBoxImageRepeat() =>
    getPropertyValue('${_browserPrefix}mask-box-image-repeat');

  /** Sets the value of "mask-box-image-repeat" */
  void set maskBoxImageRepeat(var value) {
    setProperty('${_browserPrefix}mask-box-image-repeat', value, '');
  }

  /** Gets the value of "mask-box-image-slice" */
  String get maskBoxImageSlice() =>
    getPropertyValue('${_browserPrefix}mask-box-image-slice');

  /** Sets the value of "mask-box-image-slice" */
  void set maskBoxImageSlice(var value) {
    setProperty('${_browserPrefix}mask-box-image-slice', value, '');
  }

  /** Gets the value of "mask-box-image-source" */
  String get maskBoxImageSource() =>
    getPropertyValue('${_browserPrefix}mask-box-image-source');

  /** Sets the value of "mask-box-image-source" */
  void set maskBoxImageSource(var value) {
    setProperty('${_browserPrefix}mask-box-image-source', value, '');
  }

  /** Gets the value of "mask-box-image-width" */
  String get maskBoxImageWidth() =>
    getPropertyValue('${_browserPrefix}mask-box-image-width');

  /** Sets the value of "mask-box-image-width" */
  void set maskBoxImageWidth(var value) {
    setProperty('${_browserPrefix}mask-box-image-width', value, '');
  }

  /** Gets the value of "mask-clip" */
  String get maskClip() =>
    getPropertyValue('${_browserPrefix}mask-clip');

  /** Sets the value of "mask-clip" */
  void set maskClip(var value) {
    setProperty('${_browserPrefix}mask-clip', value, '');
  }

  /** Gets the value of "mask-composite" */
  String get maskComposite() =>
    getPropertyValue('${_browserPrefix}mask-composite');

  /** Sets the value of "mask-composite" */
  void set maskComposite(var value) {
    setProperty('${_browserPrefix}mask-composite', value, '');
  }

  /** Gets the value of "mask-image" */
  String get maskImage() =>
    getPropertyValue('${_browserPrefix}mask-image');

  /** Sets the value of "mask-image" */
  void set maskImage(var value) {
    setProperty('${_browserPrefix}mask-image', value, '');
  }

  /** Gets the value of "mask-origin" */
  String get maskOrigin() =>
    getPropertyValue('${_browserPrefix}mask-origin');

  /** Sets the value of "mask-origin" */
  void set maskOrigin(var value) {
    setProperty('${_browserPrefix}mask-origin', value, '');
  }

  /** Gets the value of "mask-position" */
  String get maskPosition() =>
    getPropertyValue('${_browserPrefix}mask-position');

  /** Sets the value of "mask-position" */
  void set maskPosition(var value) {
    setProperty('${_browserPrefix}mask-position', value, '');
  }

  /** Gets the value of "mask-position-x" */
  String get maskPositionX() =>
    getPropertyValue('${_browserPrefix}mask-position-x');

  /** Sets the value of "mask-position-x" */
  void set maskPositionX(var value) {
    setProperty('${_browserPrefix}mask-position-x', value, '');
  }

  /** Gets the value of "mask-position-y" */
  String get maskPositionY() =>
    getPropertyValue('${_browserPrefix}mask-position-y');

  /** Sets the value of "mask-position-y" */
  void set maskPositionY(var value) {
    setProperty('${_browserPrefix}mask-position-y', value, '');
  }

  /** Gets the value of "mask-repeat" */
  String get maskRepeat() =>
    getPropertyValue('${_browserPrefix}mask-repeat');

  /** Sets the value of "mask-repeat" */
  void set maskRepeat(var value) {
    setProperty('${_browserPrefix}mask-repeat', value, '');
  }

  /** Gets the value of "mask-repeat-x" */
  String get maskRepeatX() =>
    getPropertyValue('${_browserPrefix}mask-repeat-x');

  /** Sets the value of "mask-repeat-x" */
  void set maskRepeatX(var value) {
    setProperty('${_browserPrefix}mask-repeat-x', value, '');
  }

  /** Gets the value of "mask-repeat-y" */
  String get maskRepeatY() =>
    getPropertyValue('${_browserPrefix}mask-repeat-y');

  /** Sets the value of "mask-repeat-y" */
  void set maskRepeatY(var value) {
    setProperty('${_browserPrefix}mask-repeat-y', value, '');
  }

  /** Gets the value of "mask-size" */
  String get maskSize() =>
    getPropertyValue('${_browserPrefix}mask-size');

  /** Sets the value of "mask-size" */
  void set maskSize(var value) {
    setProperty('${_browserPrefix}mask-size', value, '');
  }

  /** Gets the value of "match-nearest-mail-blockquote-color" */
  String get matchNearestMailBlockquoteColor() =>
    getPropertyValue('${_browserPrefix}match-nearest-mail-blockquote-color');

  /** Sets the value of "match-nearest-mail-blockquote-color" */
  void set matchNearestMailBlockquoteColor(var value) {
    setProperty('${_browserPrefix}match-nearest-mail-blockquote-color', value, '');
  }

  /** Gets the value of "max-height" */
  String get maxHeight() =>
    getPropertyValue('max-height');

  /** Sets the value of "max-height" */
  void set maxHeight(var value) {
    setProperty('max-height', value, '');
  }

  /** Gets the value of "max-logical-height" */
  String get maxLogicalHeight() =>
    getPropertyValue('${_browserPrefix}max-logical-height');

  /** Sets the value of "max-logical-height" */
  void set maxLogicalHeight(var value) {
    setProperty('${_browserPrefix}max-logical-height', value, '');
  }

  /** Gets the value of "max-logical-width" */
  String get maxLogicalWidth() =>
    getPropertyValue('${_browserPrefix}max-logical-width');

  /** Sets the value of "max-logical-width" */
  void set maxLogicalWidth(var value) {
    setProperty('${_browserPrefix}max-logical-width', value, '');
  }

  /** Gets the value of "max-width" */
  String get maxWidth() =>
    getPropertyValue('max-width');

  /** Sets the value of "max-width" */
  void set maxWidth(var value) {
    setProperty('max-width', value, '');
  }

  /** Gets the value of "min-height" */
  String get minHeight() =>
    getPropertyValue('min-height');

  /** Sets the value of "min-height" */
  void set minHeight(var value) {
    setProperty('min-height', value, '');
  }

  /** Gets the value of "min-logical-height" */
  String get minLogicalHeight() =>
    getPropertyValue('${_browserPrefix}min-logical-height');

  /** Sets the value of "min-logical-height" */
  void set minLogicalHeight(var value) {
    setProperty('${_browserPrefix}min-logical-height', value, '');
  }

  /** Gets the value of "min-logical-width" */
  String get minLogicalWidth() =>
    getPropertyValue('${_browserPrefix}min-logical-width');

  /** Sets the value of "min-logical-width" */
  void set minLogicalWidth(var value) {
    setProperty('${_browserPrefix}min-logical-width', value, '');
  }

  /** Gets the value of "min-width" */
  String get minWidth() =>
    getPropertyValue('min-width');

  /** Sets the value of "min-width" */
  void set minWidth(var value) {
    setProperty('min-width', value, '');
  }

  /** Gets the value of "nbsp-mode" */
  String get nbspMode() =>
    getPropertyValue('${_browserPrefix}nbsp-mode');

  /** Sets the value of "nbsp-mode" */
  void set nbspMode(var value) {
    setProperty('${_browserPrefix}nbsp-mode', value, '');
  }

  /** Gets the value of "opacity" */
  String get opacity() =>
    getPropertyValue('opacity');

  /** Sets the value of "opacity" */
  void set opacity(var value) {
    setProperty('opacity', value, '');
  }

  /** Gets the value of "orphans" */
  String get orphans() =>
    getPropertyValue('orphans');

  /** Sets the value of "orphans" */
  void set orphans(var value) {
    setProperty('orphans', value, '');
  }

  /** Gets the value of "outline" */
  String get outline() =>
    getPropertyValue('outline');

  /** Sets the value of "outline" */
  void set outline(var value) {
    setProperty('outline', value, '');
  }

  /** Gets the value of "outline-color" */
  String get outlineColor() =>
    getPropertyValue('outline-color');

  /** Sets the value of "outline-color" */
  void set outlineColor(var value) {
    setProperty('outline-color', value, '');
  }

  /** Gets the value of "outline-offset" */
  String get outlineOffset() =>
    getPropertyValue('outline-offset');

  /** Sets the value of "outline-offset" */
  void set outlineOffset(var value) {
    setProperty('outline-offset', value, '');
  }

  /** Gets the value of "outline-style" */
  String get outlineStyle() =>
    getPropertyValue('outline-style');

  /** Sets the value of "outline-style" */
  void set outlineStyle(var value) {
    setProperty('outline-style', value, '');
  }

  /** Gets the value of "outline-width" */
  String get outlineWidth() =>
    getPropertyValue('outline-width');

  /** Sets the value of "outline-width" */
  void set outlineWidth(var value) {
    setProperty('outline-width', value, '');
  }

  /** Gets the value of "overflow" */
  String get overflow() =>
    getPropertyValue('overflow');

  /** Sets the value of "overflow" */
  void set overflow(var value) {
    setProperty('overflow', value, '');
  }

  /** Gets the value of "overflow-x" */
  String get overflowX() =>
    getPropertyValue('overflow-x');

  /** Sets the value of "overflow-x" */
  void set overflowX(var value) {
    setProperty('overflow-x', value, '');
  }

  /** Gets the value of "overflow-y" */
  String get overflowY() =>
    getPropertyValue('overflow-y');

  /** Sets the value of "overflow-y" */
  void set overflowY(var value) {
    setProperty('overflow-y', value, '');
  }

  /** Gets the value of "padding" */
  String get padding() =>
    getPropertyValue('padding');

  /** Sets the value of "padding" */
  void set padding(var value) {
    setProperty('padding', value, '');
  }

  /** Gets the value of "padding-after" */
  String get paddingAfter() =>
    getPropertyValue('${_browserPrefix}padding-after');

  /** Sets the value of "padding-after" */
  void set paddingAfter(var value) {
    setProperty('${_browserPrefix}padding-after', value, '');
  }

  /** Gets the value of "padding-before" */
  String get paddingBefore() =>
    getPropertyValue('${_browserPrefix}padding-before');

  /** Sets the value of "padding-before" */
  void set paddingBefore(var value) {
    setProperty('${_browserPrefix}padding-before', value, '');
  }

  /** Gets the value of "padding-bottom" */
  String get paddingBottom() =>
    getPropertyValue('padding-bottom');

  /** Sets the value of "padding-bottom" */
  void set paddingBottom(var value) {
    setProperty('padding-bottom', value, '');
  }

  /** Gets the value of "padding-end" */
  String get paddingEnd() =>
    getPropertyValue('${_browserPrefix}padding-end');

  /** Sets the value of "padding-end" */
  void set paddingEnd(var value) {
    setProperty('${_browserPrefix}padding-end', value, '');
  }

  /** Gets the value of "padding-left" */
  String get paddingLeft() =>
    getPropertyValue('padding-left');

  /** Sets the value of "padding-left" */
  void set paddingLeft(var value) {
    setProperty('padding-left', value, '');
  }

  /** Gets the value of "padding-right" */
  String get paddingRight() =>
    getPropertyValue('padding-right');

  /** Sets the value of "padding-right" */
  void set paddingRight(var value) {
    setProperty('padding-right', value, '');
  }

  /** Gets the value of "padding-start" */
  String get paddingStart() =>
    getPropertyValue('${_browserPrefix}padding-start');

  /** Sets the value of "padding-start" */
  void set paddingStart(var value) {
    setProperty('${_browserPrefix}padding-start', value, '');
  }

  /** Gets the value of "padding-top" */
  String get paddingTop() =>
    getPropertyValue('padding-top');

  /** Sets the value of "padding-top" */
  void set paddingTop(var value) {
    setProperty('padding-top', value, '');
  }

  /** Gets the value of "page" */
  String get page() =>
    getPropertyValue('page');

  /** Sets the value of "page" */
  void set page(var value) {
    setProperty('page', value, '');
  }

  /** Gets the value of "page-break-after" */
  String get pageBreakAfter() =>
    getPropertyValue('page-break-after');

  /** Sets the value of "page-break-after" */
  void set pageBreakAfter(var value) {
    setProperty('page-break-after', value, '');
  }

  /** Gets the value of "page-break-before" */
  String get pageBreakBefore() =>
    getPropertyValue('page-break-before');

  /** Sets the value of "page-break-before" */
  void set pageBreakBefore(var value) {
    setProperty('page-break-before', value, '');
  }

  /** Gets the value of "page-break-inside" */
  String get pageBreakInside() =>
    getPropertyValue('page-break-inside');

  /** Sets the value of "page-break-inside" */
  void set pageBreakInside(var value) {
    setProperty('page-break-inside', value, '');
  }

  /** Gets the value of "perspective" */
  String get perspective() =>
    getPropertyValue('${_browserPrefix}perspective');

  /** Sets the value of "perspective" */
  void set perspective(var value) {
    setProperty('${_browserPrefix}perspective', value, '');
  }

  /** Gets the value of "perspective-origin" */
  String get perspectiveOrigin() =>
    getPropertyValue('${_browserPrefix}perspective-origin');

  /** Sets the value of "perspective-origin" */
  void set perspectiveOrigin(var value) {
    setProperty('${_browserPrefix}perspective-origin', value, '');
  }

  /** Gets the value of "perspective-origin-x" */
  String get perspectiveOriginX() =>
    getPropertyValue('${_browserPrefix}perspective-origin-x');

  /** Sets the value of "perspective-origin-x" */
  void set perspectiveOriginX(var value) {
    setProperty('${_browserPrefix}perspective-origin-x', value, '');
  }

  /** Gets the value of "perspective-origin-y" */
  String get perspectiveOriginY() =>
    getPropertyValue('${_browserPrefix}perspective-origin-y');

  /** Sets the value of "perspective-origin-y" */
  void set perspectiveOriginY(var value) {
    setProperty('${_browserPrefix}perspective-origin-y', value, '');
  }

  /** Gets the value of "pointer-events" */
  String get pointerEvents() =>
    getPropertyValue('pointer-events');

  /** Sets the value of "pointer-events" */
  void set pointerEvents(var value) {
    setProperty('pointer-events', value, '');
  }

  /** Gets the value of "position" */
  String get position() =>
    getPropertyValue('position');

  /** Sets the value of "position" */
  void set position(var value) {
    setProperty('position', value, '');
  }

  /** Gets the value of "quotes" */
  String get quotes() =>
    getPropertyValue('quotes');

  /** Sets the value of "quotes" */
  void set quotes(var value) {
    setProperty('quotes', value, '');
  }

  /** Gets the value of "region-break-after" */
  String get regionBreakAfter() =>
    getPropertyValue('${_browserPrefix}region-break-after');

  /** Sets the value of "region-break-after" */
  void set regionBreakAfter(var value) {
    setProperty('${_browserPrefix}region-break-after', value, '');
  }

  /** Gets the value of "region-break-before" */
  String get regionBreakBefore() =>
    getPropertyValue('${_browserPrefix}region-break-before');

  /** Sets the value of "region-break-before" */
  void set regionBreakBefore(var value) {
    setProperty('${_browserPrefix}region-break-before', value, '');
  }

  /** Gets the value of "region-break-inside" */
  String get regionBreakInside() =>
    getPropertyValue('${_browserPrefix}region-break-inside');

  /** Sets the value of "region-break-inside" */
  void set regionBreakInside(var value) {
    setProperty('${_browserPrefix}region-break-inside', value, '');
  }

  /** Gets the value of "region-overflow" */
  String get regionOverflow() =>
    getPropertyValue('${_browserPrefix}region-overflow');

  /** Sets the value of "region-overflow" */
  void set regionOverflow(var value) {
    setProperty('${_browserPrefix}region-overflow', value, '');
  }

  /** Gets the value of "resize" */
  String get resize() =>
    getPropertyValue('resize');

  /** Sets the value of "resize" */
  void set resize(var value) {
    setProperty('resize', value, '');
  }

  /** Gets the value of "right" */
  String get right() =>
    getPropertyValue('right');

  /** Sets the value of "right" */
  void set right(var value) {
    setProperty('right', value, '');
  }

  /** Gets the value of "rtl-ordering" */
  String get rtlOrdering() =>
    getPropertyValue('${_browserPrefix}rtl-ordering');

  /** Sets the value of "rtl-ordering" */
  void set rtlOrdering(var value) {
    setProperty('${_browserPrefix}rtl-ordering', value, '');
  }

  /** Gets the value of "size" */
  String get size() =>
    getPropertyValue('size');

  /** Sets the value of "size" */
  void set size(var value) {
    setProperty('size', value, '');
  }

  /** Gets the value of "speak" */
  String get speak() =>
    getPropertyValue('speak');

  /** Sets the value of "speak" */
  void set speak(var value) {
    setProperty('speak', value, '');
  }

  /** Gets the value of "src" */
  String get src() =>
    getPropertyValue('src');

  /** Sets the value of "src" */
  void set src(var value) {
    setProperty('src', value, '');
  }

  /** Gets the value of "table-layout" */
  String get tableLayout() =>
    getPropertyValue('table-layout');

  /** Sets the value of "table-layout" */
  void set tableLayout(var value) {
    setProperty('table-layout', value, '');
  }

  /** Gets the value of "tap-highlight-color" */
  String get tapHighlightColor() =>
    getPropertyValue('${_browserPrefix}tap-highlight-color');

  /** Sets the value of "tap-highlight-color" */
  void set tapHighlightColor(var value) {
    setProperty('${_browserPrefix}tap-highlight-color', value, '');
  }

  /** Gets the value of "text-align" */
  String get textAlign() =>
    getPropertyValue('text-align');

  /** Sets the value of "text-align" */
  void set textAlign(var value) {
    setProperty('text-align', value, '');
  }

  /** Gets the value of "text-combine" */
  String get textCombine() =>
    getPropertyValue('${_browserPrefix}text-combine');

  /** Sets the value of "text-combine" */
  void set textCombine(var value) {
    setProperty('${_browserPrefix}text-combine', value, '');
  }

  /** Gets the value of "text-decoration" */
  String get textDecoration() =>
    getPropertyValue('text-decoration');

  /** Sets the value of "text-decoration" */
  void set textDecoration(var value) {
    setProperty('text-decoration', value, '');
  }

  /** Gets the value of "text-decorations-in-effect" */
  String get textDecorationsInEffect() =>
    getPropertyValue('${_browserPrefix}text-decorations-in-effect');

  /** Sets the value of "text-decorations-in-effect" */
  void set textDecorationsInEffect(var value) {
    setProperty('${_browserPrefix}text-decorations-in-effect', value, '');
  }

  /** Gets the value of "text-emphasis" */
  String get textEmphasis() =>
    getPropertyValue('${_browserPrefix}text-emphasis');

  /** Sets the value of "text-emphasis" */
  void set textEmphasis(var value) {
    setProperty('${_browserPrefix}text-emphasis', value, '');
  }

  /** Gets the value of "text-emphasis-color" */
  String get textEmphasisColor() =>
    getPropertyValue('${_browserPrefix}text-emphasis-color');

  /** Sets the value of "text-emphasis-color" */
  void set textEmphasisColor(var value) {
    setProperty('${_browserPrefix}text-emphasis-color', value, '');
  }

  /** Gets the value of "text-emphasis-position" */
  String get textEmphasisPosition() =>
    getPropertyValue('${_browserPrefix}text-emphasis-position');

  /** Sets the value of "text-emphasis-position" */
  void set textEmphasisPosition(var value) {
    setProperty('${_browserPrefix}text-emphasis-position', value, '');
  }

  /** Gets the value of "text-emphasis-style" */
  String get textEmphasisStyle() =>
    getPropertyValue('${_browserPrefix}text-emphasis-style');

  /** Sets the value of "text-emphasis-style" */
  void set textEmphasisStyle(var value) {
    setProperty('${_browserPrefix}text-emphasis-style', value, '');
  }

  /** Gets the value of "text-fill-color" */
  String get textFillColor() =>
    getPropertyValue('${_browserPrefix}text-fill-color');

  /** Sets the value of "text-fill-color" */
  void set textFillColor(var value) {
    setProperty('${_browserPrefix}text-fill-color', value, '');
  }

  /** Gets the value of "text-indent" */
  String get textIndent() =>
    getPropertyValue('text-indent');

  /** Sets the value of "text-indent" */
  void set textIndent(var value) {
    setProperty('text-indent', value, '');
  }

  /** Gets the value of "text-line-through" */
  String get textLineThrough() =>
    getPropertyValue('text-line-through');

  /** Sets the value of "text-line-through" */
  void set textLineThrough(var value) {
    setProperty('text-line-through', value, '');
  }

  /** Gets the value of "text-line-through-color" */
  String get textLineThroughColor() =>
    getPropertyValue('text-line-through-color');

  /** Sets the value of "text-line-through-color" */
  void set textLineThroughColor(var value) {
    setProperty('text-line-through-color', value, '');
  }

  /** Gets the value of "text-line-through-mode" */
  String get textLineThroughMode() =>
    getPropertyValue('text-line-through-mode');

  /** Sets the value of "text-line-through-mode" */
  void set textLineThroughMode(var value) {
    setProperty('text-line-through-mode', value, '');
  }

  /** Gets the value of "text-line-through-style" */
  String get textLineThroughStyle() =>
    getPropertyValue('text-line-through-style');

  /** Sets the value of "text-line-through-style" */
  void set textLineThroughStyle(var value) {
    setProperty('text-line-through-style', value, '');
  }

  /** Gets the value of "text-line-through-width" */
  String get textLineThroughWidth() =>
    getPropertyValue('text-line-through-width');

  /** Sets the value of "text-line-through-width" */
  void set textLineThroughWidth(var value) {
    setProperty('text-line-through-width', value, '');
  }

  /** Gets the value of "text-orientation" */
  String get textOrientation() =>
    getPropertyValue('${_browserPrefix}text-orientation');

  /** Sets the value of "text-orientation" */
  void set textOrientation(var value) {
    setProperty('${_browserPrefix}text-orientation', value, '');
  }

  /** Gets the value of "text-overflow" */
  String get textOverflow() =>
    getPropertyValue('text-overflow');

  /** Sets the value of "text-overflow" */
  void set textOverflow(var value) {
    setProperty('text-overflow', value, '');
  }

  /** Gets the value of "text-overline" */
  String get textOverline() =>
    getPropertyValue('text-overline');

  /** Sets the value of "text-overline" */
  void set textOverline(var value) {
    setProperty('text-overline', value, '');
  }

  /** Gets the value of "text-overline-color" */
  String get textOverlineColor() =>
    getPropertyValue('text-overline-color');

  /** Sets the value of "text-overline-color" */
  void set textOverlineColor(var value) {
    setProperty('text-overline-color', value, '');
  }

  /** Gets the value of "text-overline-mode" */
  String get textOverlineMode() =>
    getPropertyValue('text-overline-mode');

  /** Sets the value of "text-overline-mode" */
  void set textOverlineMode(var value) {
    setProperty('text-overline-mode', value, '');
  }

  /** Gets the value of "text-overline-style" */
  String get textOverlineStyle() =>
    getPropertyValue('text-overline-style');

  /** Sets the value of "text-overline-style" */
  void set textOverlineStyle(var value) {
    setProperty('text-overline-style', value, '');
  }

  /** Gets the value of "text-overline-width" */
  String get textOverlineWidth() =>
    getPropertyValue('text-overline-width');

  /** Sets the value of "text-overline-width" */
  void set textOverlineWidth(var value) {
    setProperty('text-overline-width', value, '');
  }

  /** Gets the value of "text-rendering" */
  String get textRendering() =>
    getPropertyValue('text-rendering');

  /** Sets the value of "text-rendering" */
  void set textRendering(var value) {
    setProperty('text-rendering', value, '');
  }

  /** Gets the value of "text-security" */
  String get textSecurity() =>
    getPropertyValue('${_browserPrefix}text-security');

  /** Sets the value of "text-security" */
  void set textSecurity(var value) {
    setProperty('${_browserPrefix}text-security', value, '');
  }

  /** Gets the value of "text-shadow" */
  String get textShadow() =>
    getPropertyValue('text-shadow');

  /** Sets the value of "text-shadow" */
  void set textShadow(var value) {
    setProperty('text-shadow', value, '');
  }

  /** Gets the value of "text-size-adjust" */
  String get textSizeAdjust() =>
    getPropertyValue('${_browserPrefix}text-size-adjust');

  /** Sets the value of "text-size-adjust" */
  void set textSizeAdjust(var value) {
    setProperty('${_browserPrefix}text-size-adjust', value, '');
  }

  /** Gets the value of "text-stroke" */
  String get textStroke() =>
    getPropertyValue('${_browserPrefix}text-stroke');

  /** Sets the value of "text-stroke" */
  void set textStroke(var value) {
    setProperty('${_browserPrefix}text-stroke', value, '');
  }

  /** Gets the value of "text-stroke-color" */
  String get textStrokeColor() =>
    getPropertyValue('${_browserPrefix}text-stroke-color');

  /** Sets the value of "text-stroke-color" */
  void set textStrokeColor(var value) {
    setProperty('${_browserPrefix}text-stroke-color', value, '');
  }

  /** Gets the value of "text-stroke-width" */
  String get textStrokeWidth() =>
    getPropertyValue('${_browserPrefix}text-stroke-width');

  /** Sets the value of "text-stroke-width" */
  void set textStrokeWidth(var value) {
    setProperty('${_browserPrefix}text-stroke-width', value, '');
  }

  /** Gets the value of "text-transform" */
  String get textTransform() =>
    getPropertyValue('text-transform');

  /** Sets the value of "text-transform" */
  void set textTransform(var value) {
    setProperty('text-transform', value, '');
  }

  /** Gets the value of "text-underline" */
  String get textUnderline() =>
    getPropertyValue('text-underline');

  /** Sets the value of "text-underline" */
  void set textUnderline(var value) {
    setProperty('text-underline', value, '');
  }

  /** Gets the value of "text-underline-color" */
  String get textUnderlineColor() =>
    getPropertyValue('text-underline-color');

  /** Sets the value of "text-underline-color" */
  void set textUnderlineColor(var value) {
    setProperty('text-underline-color', value, '');
  }

  /** Gets the value of "text-underline-mode" */
  String get textUnderlineMode() =>
    getPropertyValue('text-underline-mode');

  /** Sets the value of "text-underline-mode" */
  void set textUnderlineMode(var value) {
    setProperty('text-underline-mode', value, '');
  }

  /** Gets the value of "text-underline-style" */
  String get textUnderlineStyle() =>
    getPropertyValue('text-underline-style');

  /** Sets the value of "text-underline-style" */
  void set textUnderlineStyle(var value) {
    setProperty('text-underline-style', value, '');
  }

  /** Gets the value of "text-underline-width" */
  String get textUnderlineWidth() =>
    getPropertyValue('text-underline-width');

  /** Sets the value of "text-underline-width" */
  void set textUnderlineWidth(var value) {
    setProperty('text-underline-width', value, '');
  }

  /** Gets the value of "top" */
  String get top() =>
    getPropertyValue('top');

  /** Sets the value of "top" */
  void set top(var value) {
    setProperty('top', value, '');
  }

  /** Gets the value of "transform" */
  String get transform() =>
    getPropertyValue('${_browserPrefix}transform');

  /** Sets the value of "transform" */
  void set transform(var value) {
    setProperty('${_browserPrefix}transform', value, '');
  }

  /** Gets the value of "transform-origin" */
  String get transformOrigin() =>
    getPropertyValue('${_browserPrefix}transform-origin');

  /** Sets the value of "transform-origin" */
  void set transformOrigin(var value) {
    setProperty('${_browserPrefix}transform-origin', value, '');
  }

  /** Gets the value of "transform-origin-x" */
  String get transformOriginX() =>
    getPropertyValue('${_browserPrefix}transform-origin-x');

  /** Sets the value of "transform-origin-x" */
  void set transformOriginX(var value) {
    setProperty('${_browserPrefix}transform-origin-x', value, '');
  }

  /** Gets the value of "transform-origin-y" */
  String get transformOriginY() =>
    getPropertyValue('${_browserPrefix}transform-origin-y');

  /** Sets the value of "transform-origin-y" */
  void set transformOriginY(var value) {
    setProperty('${_browserPrefix}transform-origin-y', value, '');
  }

  /** Gets the value of "transform-origin-z" */
  String get transformOriginZ() =>
    getPropertyValue('${_browserPrefix}transform-origin-z');

  /** Sets the value of "transform-origin-z" */
  void set transformOriginZ(var value) {
    setProperty('${_browserPrefix}transform-origin-z', value, '');
  }

  /** Gets the value of "transform-style" */
  String get transformStyle() =>
    getPropertyValue('${_browserPrefix}transform-style');

  /** Sets the value of "transform-style" */
  void set transformStyle(var value) {
    setProperty('${_browserPrefix}transform-style', value, '');
  }

  /** Gets the value of "transition" */
  String get transition() =>
    getPropertyValue('${_browserPrefix}transition');

  /** Sets the value of "transition" */
  void set transition(var value) {
    setProperty('${_browserPrefix}transition', value, '');
  }

  /** Gets the value of "transition-delay" */
  String get transitionDelay() =>
    getPropertyValue('${_browserPrefix}transition-delay');

  /** Sets the value of "transition-delay" */
  void set transitionDelay(var value) {
    setProperty('${_browserPrefix}transition-delay', value, '');
  }

  /** Gets the value of "transition-duration" */
  String get transitionDuration() =>
    getPropertyValue('${_browserPrefix}transition-duration');

  /** Sets the value of "transition-duration" */
  void set transitionDuration(var value) {
    setProperty('${_browserPrefix}transition-duration', value, '');
  }

  /** Gets the value of "transition-property" */
  String get transitionProperty() =>
    getPropertyValue('${_browserPrefix}transition-property');

  /** Sets the value of "transition-property" */
  void set transitionProperty(var value) {
    setProperty('${_browserPrefix}transition-property', value, '');
  }

  /** Gets the value of "transition-timing-function" */
  String get transitionTimingFunction() =>
    getPropertyValue('${_browserPrefix}transition-timing-function');

  /** Sets the value of "transition-timing-function" */
  void set transitionTimingFunction(var value) {
    setProperty('${_browserPrefix}transition-timing-function', value, '');
  }

  /** Gets the value of "unicode-bidi" */
  String get unicodeBidi() =>
    getPropertyValue('unicode-bidi');

  /** Sets the value of "unicode-bidi" */
  void set unicodeBidi(var value) {
    setProperty('unicode-bidi', value, '');
  }

  /** Gets the value of "unicode-range" */
  String get unicodeRange() =>
    getPropertyValue('unicode-range');

  /** Sets the value of "unicode-range" */
  void set unicodeRange(var value) {
    setProperty('unicode-range', value, '');
  }

  /** Gets the value of "user-drag" */
  String get userDrag() =>
    getPropertyValue('${_browserPrefix}user-drag');

  /** Sets the value of "user-drag" */
  void set userDrag(var value) {
    setProperty('${_browserPrefix}user-drag', value, '');
  }

  /** Gets the value of "user-modify" */
  String get userModify() =>
    getPropertyValue('${_browserPrefix}user-modify');

  /** Sets the value of "user-modify" */
  void set userModify(var value) {
    setProperty('${_browserPrefix}user-modify', value, '');
  }

  /** Gets the value of "user-select" */
  String get userSelect() =>
    getPropertyValue('${_browserPrefix}user-select');

  /** Sets the value of "user-select" */
  void set userSelect(var value) {
    setProperty('${_browserPrefix}user-select', value, '');
  }

  /** Gets the value of "vertical-align" */
  String get verticalAlign() =>
    getPropertyValue('vertical-align');

  /** Sets the value of "vertical-align" */
  void set verticalAlign(var value) {
    setProperty('vertical-align', value, '');
  }

  /** Gets the value of "visibility" */
  String get visibility() =>
    getPropertyValue('visibility');

  /** Sets the value of "visibility" */
  void set visibility(var value) {
    setProperty('visibility', value, '');
  }

  /** Gets the value of "white-space" */
  String get whiteSpace() =>
    getPropertyValue('white-space');

  /** Sets the value of "white-space" */
  void set whiteSpace(var value) {
    setProperty('white-space', value, '');
  }

  /** Gets the value of "widows" */
  String get widows() =>
    getPropertyValue('widows');

  /** Sets the value of "widows" */
  void set widows(var value) {
    setProperty('widows', value, '');
  }

  /** Gets the value of "width" */
  String get width() =>
    getPropertyValue('width');

  /** Sets the value of "width" */
  void set width(var value) {
    setProperty('width', value, '');
  }

  /** Gets the value of "word-break" */
  String get wordBreak() =>
    getPropertyValue('word-break');

  /** Sets the value of "word-break" */
  void set wordBreak(var value) {
    setProperty('word-break', value, '');
  }

  /** Gets the value of "word-spacing" */
  String get wordSpacing() =>
    getPropertyValue('word-spacing');

  /** Sets the value of "word-spacing" */
  void set wordSpacing(var value) {
    setProperty('word-spacing', value, '');
  }

  /** Gets the value of "word-wrap" */
  String get wordWrap() =>
    getPropertyValue('word-wrap');

  /** Sets the value of "word-wrap" */
  void set wordWrap(var value) {
    setProperty('word-wrap', value, '');
  }

  /** Gets the value of "wrap-shape" */
  String get wrapShape() =>
    getPropertyValue('${_browserPrefix}wrap-shape');

  /** Sets the value of "wrap-shape" */
  void set wrapShape(var value) {
    setProperty('${_browserPrefix}wrap-shape', value, '');
  }

  /** Gets the value of "writing-mode" */
  String get writingMode() =>
    getPropertyValue('${_browserPrefix}writing-mode');

  /** Sets the value of "writing-mode" */
  void set writingMode(var value) {
    setProperty('${_browserPrefix}writing-mode', value, '');
  }

  /** Gets the value of "z-index" */
  String get zIndex() =>
    getPropertyValue('z-index');

  /** Sets the value of "z-index" */
  void set zIndex(var value) {
    setProperty('z-index', value, '');
  }

  /** Gets the value of "zoom" */
  String get zoom() =>
    getPropertyValue('zoom');

  /** Sets the value of "zoom" */
  void set zoom(var value) {
    setProperty('zoom', value, '');
  }
}

class _CSSStyleRuleImpl extends _CSSRuleImpl implements CSSStyleRule {
  _CSSStyleRuleImpl._wrap(ptr) : super._wrap(ptr);

  String get selectorText() => _wrap(_ptr.selectorText);

  void set selectorText(String value) { _ptr.selectorText = _unwrap(value); }

  CSSStyleDeclaration get style() => _wrap(_ptr.style);
}

class _CSSStyleSheetImpl extends _StyleSheetImpl implements CSSStyleSheet {
  _CSSStyleSheetImpl._wrap(ptr) : super._wrap(ptr);

  CSSRuleList get cssRules() => _wrap(_ptr.cssRules);

  CSSRule get ownerRule() => _wrap(_ptr.ownerRule);

  CSSRuleList get rules() => _wrap(_ptr.rules);

  int addRule(String selector, String style, [int index = null]) {
    if (index === null) {
      return _wrap(_ptr.addRule(_unwrap(selector), _unwrap(style)));
    } else {
      return _wrap(_ptr.addRule(_unwrap(selector), _unwrap(style), _unwrap(index)));
    }
  }

  void deleteRule(int index) {
    _ptr.deleteRule(_unwrap(index));
    return;
  }

  int insertRule(String rule, int index) {
    return _wrap(_ptr.insertRule(_unwrap(rule), _unwrap(index)));
  }

  void removeRule(int index) {
    _ptr.removeRule(_unwrap(index));
    return;
  }
}

class _CSSTransformValueImpl extends _CSSValueListImpl implements CSSTransformValue {
  _CSSTransformValueImpl._wrap(ptr) : super._wrap(ptr);

  int get operationType() => _wrap(_ptr.operationType);
}

class _CSSUnknownRuleImpl extends _CSSRuleImpl implements CSSUnknownRule {
  _CSSUnknownRuleImpl._wrap(ptr) : super._wrap(ptr);
}

class _CSSValueImpl extends _DOMTypeBase implements CSSValue {
  _CSSValueImpl._wrap(ptr) : super._wrap(ptr);

  String get cssText() => _wrap(_ptr.cssText);

  void set cssText(String value) { _ptr.cssText = _unwrap(value); }

  int get cssValueType() => _wrap(_ptr.cssValueType);
}

class _CSSValueListImpl extends _CSSValueImpl implements CSSValueList {
  _CSSValueListImpl._wrap(ptr) : super._wrap(ptr);

  int get length() => _wrap(_ptr.length);

  CSSValue item(int index) {
    return _wrap(_ptr.item(_unwrap(index)));
  }
}

class _CanvasElementImpl extends _ElementImpl implements CanvasElement {
  _CanvasElementImpl._wrap(ptr) : super._wrap(ptr);

  int get height() => _wrap(_ptr.height);

  void set height(int value) { _ptr.height = _unwrap(value); }

  int get width() => _wrap(_ptr.width);

  void set width(int value) { _ptr.width = _unwrap(value); }

  Object getContext(String contextId) {
    return _wrap(_ptr.getContext(_unwrap(contextId)));
  }

  String toDataURL(String type) {
    return _wrap(_ptr.toDataURL(_unwrap(type)));
  }
}

class _CanvasGradientImpl extends _DOMTypeBase implements CanvasGradient {
  _CanvasGradientImpl._wrap(ptr) : super._wrap(ptr);

  void addColorStop(num offset, String color) {
    _ptr.addColorStop(_unwrap(offset), _unwrap(color));
    return;
  }
}

class _CanvasPatternImpl extends _DOMTypeBase implements CanvasPattern {
  _CanvasPatternImpl._wrap(ptr) : super._wrap(ptr);
}

class _CanvasPixelArrayImpl extends _DOMTypeBase implements CanvasPixelArray {
  _CanvasPixelArrayImpl._wrap(ptr) : super._wrap(ptr);

  int get length() => _wrap(_ptr.length);

  int operator[](int index) => _wrap(_ptr[index]);


  void operator[]=(int index, int value) {
    throw new UnsupportedOperationException("Cannot assign element of immutable List.");
  }

  void add(int value) {
    throw new UnsupportedOperationException("Cannot add to immutable List.");
  }

  void addLast(int value) {
    throw new UnsupportedOperationException("Cannot add to immutable List.");
  }

  void addAll(Collection<int> collection) {
    throw new UnsupportedOperationException("Cannot add to immutable List.");
  }

  void sort(int compare(int a, int b)) {
    throw new UnsupportedOperationException("Cannot sort immutable List.");
  }

  void copyFrom(List<Object> src, int srcStart, int dstStart, int count) {
    throw new UnsupportedOperationException("This object is immutable.");
  }

  int indexOf(int element, [int start = 0]) {
    return _Lists.indexOf(this, element, start, this.length);
  }

  int lastIndexOf(int element, [int start = null]) {
    if (start === null) start = length - 1;
    return _Lists.lastIndexOf(this, element, start);
  }

  int clear() {
    throw new UnsupportedOperationException("Cannot clear immutable List.");
  }

  int removeLast() {
    throw new UnsupportedOperationException("Cannot removeLast on immutable List.");
  }

  int last() {
    return this[length - 1];
  }

  void forEach(void f(int element)) {
    _Collections.forEach(this, f);
  }

  Collection map(f(int element)) {
    return _Collections.map(this, [], f);
  }

  Collection<int> filter(bool f(int element)) {
    return _Collections.filter(this, new List<int>(), f);
  }

  bool every(bool f(int element)) {
    return _Collections.every(this, f);
  }

  bool some(bool f(int element)) {
    return _Collections.some(this, f);
  }

  void setRange(int start, int length, List<int> from, [int startFrom]) {
    throw new UnsupportedOperationException("Cannot setRange on immutable List.");
  }

  void removeRange(int start, int length) {
    throw new UnsupportedOperationException("Cannot removeRange on immutable List.");
  }

  void insertRange(int start, int length, [int initialValue]) {
    throw new UnsupportedOperationException("Cannot insertRange on immutable List.");
  }

  List<int> getRange(int start, int length) {
    throw new NotImplementedException();
  }

  bool isEmpty() {
    return length == 0;
  }

  Iterator<int> iterator() {
    return new _FixedSizeListIterator<int>(this);
  }
}

class _CanvasRenderingContextImpl extends _DOMTypeBase implements CanvasRenderingContext {
  _CanvasRenderingContextImpl._wrap(ptr) : super._wrap(ptr);

  CanvasElement get canvas() => _wrap(_ptr.canvas);
}

class _CanvasRenderingContext2DImpl extends _CanvasRenderingContextImpl implements CanvasRenderingContext2D {
  _CanvasRenderingContext2DImpl._wrap(ptr) : super._wrap(ptr);

  Dynamic get fillStyle() => _wrap(_ptr.fillStyle);

  void set fillStyle(Dynamic value) { _ptr.fillStyle = _unwrap(value); }

  String get font() => _wrap(_ptr.font);

  void set font(String value) { _ptr.font = _unwrap(value); }

  num get globalAlpha() => _wrap(_ptr.globalAlpha);

  void set globalAlpha(num value) { _ptr.globalAlpha = _unwrap(value); }

  String get globalCompositeOperation() => _wrap(_ptr.globalCompositeOperation);

  void set globalCompositeOperation(String value) { _ptr.globalCompositeOperation = _unwrap(value); }

  String get lineCap() => _wrap(_ptr.lineCap);

  void set lineCap(String value) { _ptr.lineCap = _unwrap(value); }

  String get lineJoin() => _wrap(_ptr.lineJoin);

  void set lineJoin(String value) { _ptr.lineJoin = _unwrap(value); }

  num get lineWidth() => _wrap(_ptr.lineWidth);

  void set lineWidth(num value) { _ptr.lineWidth = _unwrap(value); }

  num get miterLimit() => _wrap(_ptr.miterLimit);

  void set miterLimit(num value) { _ptr.miterLimit = _unwrap(value); }

  num get shadowBlur() => _wrap(_ptr.shadowBlur);

  void set shadowBlur(num value) { _ptr.shadowBlur = _unwrap(value); }

  String get shadowColor() => _wrap(_ptr.shadowColor);

  void set shadowColor(String value) { _ptr.shadowColor = _unwrap(value); }

  num get shadowOffsetX() => _wrap(_ptr.shadowOffsetX);

  void set shadowOffsetX(num value) { _ptr.shadowOffsetX = _unwrap(value); }

  num get shadowOffsetY() => _wrap(_ptr.shadowOffsetY);

  void set shadowOffsetY(num value) { _ptr.shadowOffsetY = _unwrap(value); }

  Dynamic get strokeStyle() => _wrap(_ptr.strokeStyle);

  void set strokeStyle(Dynamic value) { _ptr.strokeStyle = _unwrap(value); }

  String get textAlign() => _wrap(_ptr.textAlign);

  void set textAlign(String value) { _ptr.textAlign = _unwrap(value); }

  String get textBaseline() => _wrap(_ptr.textBaseline);

  void set textBaseline(String value) { _ptr.textBaseline = _unwrap(value); }

  List get webkitLineDash() => _wrap(_ptr.webkitLineDash);

  void set webkitLineDash(List value) { _ptr.webkitLineDash = _unwrap(value); }

  num get webkitLineDashOffset() => _wrap(_ptr.webkitLineDashOffset);

  void set webkitLineDashOffset(num value) { _ptr.webkitLineDashOffset = _unwrap(value); }

  void arc(num x, num y, num radius, num startAngle, num endAngle, bool anticlockwise) {
    _ptr.arc(_unwrap(x), _unwrap(y), _unwrap(radius), _unwrap(startAngle), _unwrap(endAngle), _unwrap(anticlockwise));
    return;
  }

  void arcTo(num x1, num y1, num x2, num y2, num radius) {
    _ptr.arcTo(_unwrap(x1), _unwrap(y1), _unwrap(x2), _unwrap(y2), _unwrap(radius));
    return;
  }

  void beginPath() {
    _ptr.beginPath();
    return;
  }

  void bezierCurveTo(num cp1x, num cp1y, num cp2x, num cp2y, num x, num y) {
    _ptr.bezierCurveTo(_unwrap(cp1x), _unwrap(cp1y), _unwrap(cp2x), _unwrap(cp2y), _unwrap(x), _unwrap(y));
    return;
  }

  void clearRect(num x, num y, num width, num height) {
    _ptr.clearRect(_unwrap(x), _unwrap(y), _unwrap(width), _unwrap(height));
    return;
  }

  void clearShadow() {
    _ptr.clearShadow();
    return;
  }

  void clip() {
    _ptr.clip();
    return;
  }

  void closePath() {
    _ptr.closePath();
    return;
  }

  ImageData createImageData(var imagedata_OR_sw, [num sh = null]) {
    if (imagedata_OR_sw is ImageData) {
      if (sh === null) {
        return _wrap(_ptr.createImageData(_unwrap(imagedata_OR_sw)));
      }
    } else {
      if (imagedata_OR_sw is num) {
        return _wrap(_ptr.createImageData(_unwrap(imagedata_OR_sw), _unwrap(sh)));
      }
    }
    throw "Incorrect number or type of arguments";
  }

  CanvasGradient createLinearGradient(num x0, num y0, num x1, num y1) {
    return _wrap(_ptr.createLinearGradient(_unwrap(x0), _unwrap(y0), _unwrap(x1), _unwrap(y1)));
  }

  CanvasPattern createPattern(var canvas_OR_image, String repetitionType) {
    if (canvas_OR_image is CanvasElement) {
      return _wrap(_ptr.createPattern(_unwrap(canvas_OR_image), _unwrap(repetitionType)));
    } else {
      if (canvas_OR_image is ImageElement) {
        return _wrap(_ptr.createPattern(_unwrap(canvas_OR_image), _unwrap(repetitionType)));
      }
    }
    throw "Incorrect number or type of arguments";
  }

  CanvasGradient createRadialGradient(num x0, num y0, num r0, num x1, num y1, num r1) {
    return _wrap(_ptr.createRadialGradient(_unwrap(x0), _unwrap(y0), _unwrap(r0), _unwrap(x1), _unwrap(y1), _unwrap(r1)));
  }

  void drawImage(var canvas_OR_image_OR_video, num sx_OR_x, num sy_OR_y, [num sw_OR_width = null, num height_OR_sh = null, num dx = null, num dy = null, num dw = null, num dh = null]) {
    if (canvas_OR_image_OR_video is ImageElement) {
      if (sw_OR_width === null) {
        if (height_OR_sh === null) {
          if (dx === null) {
            if (dy === null) {
              if (dw === null) {
                if (dh === null) {
                  _ptr.drawImage(_unwrap(canvas_OR_image_OR_video), _unwrap(sx_OR_x), _unwrap(sy_OR_y));
                  return;
                }
              }
            }
          }
        }
      } else {
        if (dx === null) {
          if (dy === null) {
            if (dw === null) {
              if (dh === null) {
                _ptr.drawImage(_unwrap(canvas_OR_image_OR_video), _unwrap(sx_OR_x), _unwrap(sy_OR_y), _unwrap(sw_OR_width), _unwrap(height_OR_sh));
                return;
              }
            }
          }
        } else {
          _ptr.drawImage(_unwrap(canvas_OR_image_OR_video), _unwrap(sx_OR_x), _unwrap(sy_OR_y), _unwrap(sw_OR_width), _unwrap(height_OR_sh), _unwrap(dx), _unwrap(dy), _unwrap(dw), _unwrap(dh));
          return;
        }
      }
    } else {
      if (canvas_OR_image_OR_video is CanvasElement) {
        if (sw_OR_width === null) {
          if (height_OR_sh === null) {
            if (dx === null) {
              if (dy === null) {
                if (dw === null) {
                  if (dh === null) {
                    _ptr.drawImage(_unwrap(canvas_OR_image_OR_video), _unwrap(sx_OR_x), _unwrap(sy_OR_y));
                    return;
                  }
                }
              }
            }
          }
        } else {
          if (dx === null) {
            if (dy === null) {
              if (dw === null) {
                if (dh === null) {
                  _ptr.drawImage(_unwrap(canvas_OR_image_OR_video), _unwrap(sx_OR_x), _unwrap(sy_OR_y), _unwrap(sw_OR_width), _unwrap(height_OR_sh));
                  return;
                }
              }
            }
          } else {
            _ptr.drawImage(_unwrap(canvas_OR_image_OR_video), _unwrap(sx_OR_x), _unwrap(sy_OR_y), _unwrap(sw_OR_width), _unwrap(height_OR_sh), _unwrap(dx), _unwrap(dy), _unwrap(dw), _unwrap(dh));
            return;
          }
        }
      } else {
        if (canvas_OR_image_OR_video is VideoElement) {
          if (sw_OR_width === null) {
            if (height_OR_sh === null) {
              if (dx === null) {
                if (dy === null) {
                  if (dw === null) {
                    if (dh === null) {
                      _ptr.drawImage(_unwrap(canvas_OR_image_OR_video), _unwrap(sx_OR_x), _unwrap(sy_OR_y));
                      return;
                    }
                  }
                }
              }
            }
          } else {
            if (dx === null) {
              if (dy === null) {
                if (dw === null) {
                  if (dh === null) {
                    _ptr.drawImage(_unwrap(canvas_OR_image_OR_video), _unwrap(sx_OR_x), _unwrap(sy_OR_y), _unwrap(sw_OR_width), _unwrap(height_OR_sh));
                    return;
                  }
                }
              }
            } else {
              _ptr.drawImage(_unwrap(canvas_OR_image_OR_video), _unwrap(sx_OR_x), _unwrap(sy_OR_y), _unwrap(sw_OR_width), _unwrap(height_OR_sh), _unwrap(dx), _unwrap(dy), _unwrap(dw), _unwrap(dh));
              return;
            }
          }
        }
      }
    }
    throw "Incorrect number or type of arguments";
  }

  void drawImageFromRect(ImageElement image, [num sx = null, num sy = null, num sw = null, num sh = null, num dx = null, num dy = null, num dw = null, num dh = null, String compositeOperation = null]) {
    if (sx === null) {
      if (sy === null) {
        if (sw === null) {
          if (sh === null) {
            if (dx === null) {
              if (dy === null) {
                if (dw === null) {
                  if (dh === null) {
                    if (compositeOperation === null) {
                      _ptr.drawImageFromRect(_unwrap(image));
                      return;
                    }
                  }
                }
              }
            }
          }
        }
      }
    } else {
      if (sy === null) {
        if (sw === null) {
          if (sh === null) {
            if (dx === null) {
              if (dy === null) {
                if (dw === null) {
                  if (dh === null) {
                    if (compositeOperation === null) {
                      _ptr.drawImageFromRect(_unwrap(image), _unwrap(sx));
                      return;
                    }
                  }
                }
              }
            }
          }
        }
      } else {
        if (sw === null) {
          if (sh === null) {
            if (dx === null) {
              if (dy === null) {
                if (dw === null) {
                  if (dh === null) {
                    if (compositeOperation === null) {
                      _ptr.drawImageFromRect(_unwrap(image), _unwrap(sx), _unwrap(sy));
                      return;
                    }
                  }
                }
              }
            }
          }
        } else {
          if (sh === null) {
            if (dx === null) {
              if (dy === null) {
                if (dw === null) {
                  if (dh === null) {
                    if (compositeOperation === null) {
                      _ptr.drawImageFromRect(_unwrap(image), _unwrap(sx), _unwrap(sy), _unwrap(sw));
                      return;
                    }
                  }
                }
              }
            }
          } else {
            if (dx === null) {
              if (dy === null) {
                if (dw === null) {
                  if (dh === null) {
                    if (compositeOperation === null) {
                      _ptr.drawImageFromRect(_unwrap(image), _unwrap(sx), _unwrap(sy), _unwrap(sw), _unwrap(sh));
                      return;
                    }
                  }
                }
              }
            } else {
              if (dy === null) {
                if (dw === null) {
                  if (dh === null) {
                    if (compositeOperation === null) {
                      _ptr.drawImageFromRect(_unwrap(image), _unwrap(sx), _unwrap(sy), _unwrap(sw), _unwrap(sh), _unwrap(dx));
                      return;
                    }
                  }
                }
              } else {
                if (dw === null) {
                  if (dh === null) {
                    if (compositeOperation === null) {
                      _ptr.drawImageFromRect(_unwrap(image), _unwrap(sx), _unwrap(sy), _unwrap(sw), _unwrap(sh), _unwrap(dx), _unwrap(dy));
                      return;
                    }
                  }
                } else {
                  if (dh === null) {
                    if (compositeOperation === null) {
                      _ptr.drawImageFromRect(_unwrap(image), _unwrap(sx), _unwrap(sy), _unwrap(sw), _unwrap(sh), _unwrap(dx), _unwrap(dy), _unwrap(dw));
                      return;
                    }
                  } else {
                    if (compositeOperation === null) {
                      _ptr.drawImageFromRect(_unwrap(image), _unwrap(sx), _unwrap(sy), _unwrap(sw), _unwrap(sh), _unwrap(dx), _unwrap(dy), _unwrap(dw), _unwrap(dh));
                      return;
                    } else {
                      _ptr.drawImageFromRect(_unwrap(image), _unwrap(sx), _unwrap(sy), _unwrap(sw), _unwrap(sh), _unwrap(dx), _unwrap(dy), _unwrap(dw), _unwrap(dh), _unwrap(compositeOperation));
                      return;
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
    throw "Incorrect number or type of arguments";
  }

  void fill() {
    _ptr.fill();
    return;
  }

  void fillRect(num x, num y, num width, num height) {
    _ptr.fillRect(_unwrap(x), _unwrap(y), _unwrap(width), _unwrap(height));
    return;
  }

  void fillText(String text, num x, num y, [num maxWidth = null]) {
    if (maxWidth === null) {
      _ptr.fillText(_unwrap(text), _unwrap(x), _unwrap(y));
      return;
    } else {
      _ptr.fillText(_unwrap(text), _unwrap(x), _unwrap(y), _unwrap(maxWidth));
      return;
    }
  }

  ImageData getImageData(num sx, num sy, num sw, num sh) {
    return _wrap(_ptr.getImageData(_unwrap(sx), _unwrap(sy), _unwrap(sw), _unwrap(sh)));
  }

  bool isPointInPath(num x, num y) {
    return _wrap(_ptr.isPointInPath(_unwrap(x), _unwrap(y)));
  }

  void lineTo(num x, num y) {
    _ptr.lineTo(_unwrap(x), _unwrap(y));
    return;
  }

  TextMetrics measureText(String text) {
    return _wrap(_ptr.measureText(_unwrap(text)));
  }

  void moveTo(num x, num y) {
    _ptr.moveTo(_unwrap(x), _unwrap(y));
    return;
  }

  void putImageData(ImageData imagedata, num dx, num dy, [num dirtyX = null, num dirtyY = null, num dirtyWidth = null, num dirtyHeight = null]) {
    if (dirtyX === null) {
      if (dirtyY === null) {
        if (dirtyWidth === null) {
          if (dirtyHeight === null) {
            _ptr.putImageData(_unwrap(imagedata), _unwrap(dx), _unwrap(dy));
            return;
          }
        }
      }
    } else {
      _ptr.putImageData(_unwrap(imagedata), _unwrap(dx), _unwrap(dy), _unwrap(dirtyX), _unwrap(dirtyY), _unwrap(dirtyWidth), _unwrap(dirtyHeight));
      return;
    }
    throw "Incorrect number or type of arguments";
  }

  void quadraticCurveTo(num cpx, num cpy, num x, num y) {
    _ptr.quadraticCurveTo(_unwrap(cpx), _unwrap(cpy), _unwrap(x), _unwrap(y));
    return;
  }

  void rect(num x, num y, num width, num height) {
    _ptr.rect(_unwrap(x), _unwrap(y), _unwrap(width), _unwrap(height));
    return;
  }

  void restore() {
    _ptr.restore();
    return;
  }

  void rotate(num angle) {
    _ptr.rotate(_unwrap(angle));
    return;
  }

  void save() {
    _ptr.save();
    return;
  }

  void scale(num sx, num sy) {
    _ptr.scale(_unwrap(sx), _unwrap(sy));
    return;
  }

  void setAlpha(num alpha) {
    _ptr.setAlpha(_unwrap(alpha));
    return;
  }

  void setCompositeOperation(String compositeOperation) {
    _ptr.setCompositeOperation(_unwrap(compositeOperation));
    return;
  }

  void setFillColor(var c_OR_color_OR_grayLevel_OR_r, [num alpha_OR_g_OR_m = null, num b_OR_y = null, num a_OR_k = null, num a = null]) {
    if (c_OR_color_OR_grayLevel_OR_r is String) {
      if (alpha_OR_g_OR_m === null) {
        if (b_OR_y === null) {
          if (a_OR_k === null) {
            if (a === null) {
              _ptr.setFillColor(_unwrap(c_OR_color_OR_grayLevel_OR_r));
              return;
            }
          }
        }
      } else {
        if (b_OR_y === null) {
          if (a_OR_k === null) {
            if (a === null) {
              _ptr.setFillColor(_unwrap(c_OR_color_OR_grayLevel_OR_r), _unwrap(alpha_OR_g_OR_m));
              return;
            }
          }
        }
      }
    } else {
      if (c_OR_color_OR_grayLevel_OR_r is num) {
        if (alpha_OR_g_OR_m === null) {
          if (b_OR_y === null) {
            if (a_OR_k === null) {
              if (a === null) {
                _ptr.setFillColor(_unwrap(c_OR_color_OR_grayLevel_OR_r));
                return;
              }
            }
          }
        } else {
          if (b_OR_y === null) {
            if (a_OR_k === null) {
              if (a === null) {
                _ptr.setFillColor(_unwrap(c_OR_color_OR_grayLevel_OR_r), _unwrap(alpha_OR_g_OR_m));
                return;
              }
            }
          } else {
            if (a === null) {
              _ptr.setFillColor(_unwrap(c_OR_color_OR_grayLevel_OR_r), _unwrap(alpha_OR_g_OR_m), _unwrap(b_OR_y), _unwrap(a_OR_k));
              return;
            } else {
              _ptr.setFillColor(_unwrap(c_OR_color_OR_grayLevel_OR_r), _unwrap(alpha_OR_g_OR_m), _unwrap(b_OR_y), _unwrap(a_OR_k), _unwrap(a));
              return;
            }
          }
        }
      }
    }
    throw "Incorrect number or type of arguments";
  }

  void setLineCap(String cap) {
    _ptr.setLineCap(_unwrap(cap));
    return;
  }

  void setLineJoin(String join) {
    _ptr.setLineJoin(_unwrap(join));
    return;
  }

  void setLineWidth(num width) {
    _ptr.setLineWidth(_unwrap(width));
    return;
  }

  void setMiterLimit(num limit) {
    _ptr.setMiterLimit(_unwrap(limit));
    return;
  }

  void setShadow(num width, num height, num blur, [var c_OR_color_OR_grayLevel_OR_r = null, num alpha_OR_g_OR_m = null, num b_OR_y = null, num a_OR_k = null, num a = null]) {
    if (c_OR_color_OR_grayLevel_OR_r === null) {
      if (alpha_OR_g_OR_m === null) {
        if (b_OR_y === null) {
          if (a_OR_k === null) {
            if (a === null) {
              _ptr.setShadow(_unwrap(width), _unwrap(height), _unwrap(blur));
              return;
            }
          }
        }
      }
    } else {
      if (c_OR_color_OR_grayLevel_OR_r is String) {
        if (alpha_OR_g_OR_m === null) {
          if (b_OR_y === null) {
            if (a_OR_k === null) {
              if (a === null) {
                _ptr.setShadow(_unwrap(width), _unwrap(height), _unwrap(blur), _unwrap(c_OR_color_OR_grayLevel_OR_r));
                return;
              }
            }
          }
        } else {
          if (b_OR_y === null) {
            if (a_OR_k === null) {
              if (a === null) {
                _ptr.setShadow(_unwrap(width), _unwrap(height), _unwrap(blur), _unwrap(c_OR_color_OR_grayLevel_OR_r), _unwrap(alpha_OR_g_OR_m));
                return;
              }
            }
          }
        }
      } else {
        if (c_OR_color_OR_grayLevel_OR_r is num) {
          if (alpha_OR_g_OR_m === null) {
            if (b_OR_y === null) {
              if (a_OR_k === null) {
                if (a === null) {
                  _ptr.setShadow(_unwrap(width), _unwrap(height), _unwrap(blur), _unwrap(c_OR_color_OR_grayLevel_OR_r));
                  return;
                }
              }
            }
          } else {
            if (b_OR_y === null) {
              if (a_OR_k === null) {
                if (a === null) {
                  _ptr.setShadow(_unwrap(width), _unwrap(height), _unwrap(blur), _unwrap(c_OR_color_OR_grayLevel_OR_r), _unwrap(alpha_OR_g_OR_m));
                  return;
                }
              }
            } else {
              if (a === null) {
                _ptr.setShadow(_unwrap(width), _unwrap(height), _unwrap(blur), _unwrap(c_OR_color_OR_grayLevel_OR_r), _unwrap(alpha_OR_g_OR_m), _unwrap(b_OR_y), _unwrap(a_OR_k));
                return;
              } else {
                _ptr.setShadow(_unwrap(width), _unwrap(height), _unwrap(blur), _unwrap(c_OR_color_OR_grayLevel_OR_r), _unwrap(alpha_OR_g_OR_m), _unwrap(b_OR_y), _unwrap(a_OR_k), _unwrap(a));
                return;
              }
            }
          }
        }
      }
    }
    throw "Incorrect number or type of arguments";
  }

  void setStrokeColor(var c_OR_color_OR_grayLevel_OR_r, [num alpha_OR_g_OR_m = null, num b_OR_y = null, num a_OR_k = null, num a = null]) {
    if (c_OR_color_OR_grayLevel_OR_r is String) {
      if (alpha_OR_g_OR_m === null) {
        if (b_OR_y === null) {
          if (a_OR_k === null) {
            if (a === null) {
              _ptr.setStrokeColor(_unwrap(c_OR_color_OR_grayLevel_OR_r));
              return;
            }
          }
        }
      } else {
        if (b_OR_y === null) {
          if (a_OR_k === null) {
            if (a === null) {
              _ptr.setStrokeColor(_unwrap(c_OR_color_OR_grayLevel_OR_r), _unwrap(alpha_OR_g_OR_m));
              return;
            }
          }
        }
      }
    } else {
      if (c_OR_color_OR_grayLevel_OR_r is num) {
        if (alpha_OR_g_OR_m === null) {
          if (b_OR_y === null) {
            if (a_OR_k === null) {
              if (a === null) {
                _ptr.setStrokeColor(_unwrap(c_OR_color_OR_grayLevel_OR_r));
                return;
              }
            }
          }
        } else {
          if (b_OR_y === null) {
            if (a_OR_k === null) {
              if (a === null) {
                _ptr.setStrokeColor(_unwrap(c_OR_color_OR_grayLevel_OR_r), _unwrap(alpha_OR_g_OR_m));
                return;
              }
            }
          } else {
            if (a === null) {
              _ptr.setStrokeColor(_unwrap(c_OR_color_OR_grayLevel_OR_r), _unwrap(alpha_OR_g_OR_m), _unwrap(b_OR_y), _unwrap(a_OR_k));
              return;
            } else {
              _ptr.setStrokeColor(_unwrap(c_OR_color_OR_grayLevel_OR_r), _unwrap(alpha_OR_g_OR_m), _unwrap(b_OR_y), _unwrap(a_OR_k), _unwrap(a));
              return;
            }
          }
        }
      }
    }
    throw "Incorrect number or type of arguments";
  }

  void setTransform(num m11, num m12, num m21, num m22, num dx, num dy) {
    _ptr.setTransform(_unwrap(m11), _unwrap(m12), _unwrap(m21), _unwrap(m22), _unwrap(dx), _unwrap(dy));
    return;
  }

  void stroke() {
    _ptr.stroke();
    return;
  }

  void strokeRect(num x, num y, num width, num height, [num lineWidth = null]) {
    if (lineWidth === null) {
      _ptr.strokeRect(_unwrap(x), _unwrap(y), _unwrap(width), _unwrap(height));
      return;
    } else {
      _ptr.strokeRect(_unwrap(x), _unwrap(y), _unwrap(width), _unwrap(height), _unwrap(lineWidth));
      return;
    }
  }

  void strokeText(String text, num x, num y, [num maxWidth = null]) {
    if (maxWidth === null) {
      _ptr.strokeText(_unwrap(text), _unwrap(x), _unwrap(y));
      return;
    } else {
      _ptr.strokeText(_unwrap(text), _unwrap(x), _unwrap(y), _unwrap(maxWidth));
      return;
    }
  }

  void transform(num m11, num m12, num m21, num m22, num dx, num dy) {
    _ptr.transform(_unwrap(m11), _unwrap(m12), _unwrap(m21), _unwrap(m22), _unwrap(dx), _unwrap(dy));
    return;
  }

  void translate(num tx, num ty) {
    _ptr.translate(_unwrap(tx), _unwrap(ty));
    return;
  }
}

class _CharacterDataImpl extends _NodeImpl implements CharacterData {
  _CharacterDataImpl._wrap(ptr) : super._wrap(ptr);

  String get data() => _wrap(_ptr.data);

  void set data(String value) { _ptr.data = _unwrap(value); }

  int get length() => _wrap(_ptr.length);

  void appendData(String data) {
    _ptr.appendData(_unwrap(data));
    return;
  }

  void deleteData(int offset, int length) {
    _ptr.deleteData(_unwrap(offset), _unwrap(length));
    return;
  }

  void insertData(int offset, String data) {
    _ptr.insertData(_unwrap(offset), _unwrap(data));
    return;
  }

  void replaceData(int offset, int length, String data) {
    _ptr.replaceData(_unwrap(offset), _unwrap(length), _unwrap(data));
    return;
  }

  String substringData(int offset, int length) {
    return _wrap(_ptr.substringData(_unwrap(offset), _unwrap(length)));
  }
}

class _ClientRectImpl extends _DOMTypeBase implements ClientRect {
  _ClientRectImpl._wrap(ptr) : super._wrap(ptr);

  num get bottom() => _wrap(_ptr.bottom);

  num get height() => _wrap(_ptr.height);

  num get left() => _wrap(_ptr.left);

  num get right() => _wrap(_ptr.right);

  num get top() => _wrap(_ptr.top);

  num get width() => _wrap(_ptr.width);
}

class _ClientRectListImpl extends _DOMTypeBase implements ClientRectList {
  _ClientRectListImpl._wrap(ptr) : super._wrap(ptr);

  int get length() => _wrap(_ptr.length);

  ClientRect item(int index) {
    return _wrap(_ptr.item(_unwrap(index)));
  }
}

class _ClipboardImpl extends _DOMTypeBase implements Clipboard {
  _ClipboardImpl._wrap(ptr) : super._wrap(ptr);

  String get dropEffect() => _wrap(_ptr.dropEffect);

  void set dropEffect(String value) { _ptr.dropEffect = _unwrap(value); }

  String get effectAllowed() => _wrap(_ptr.effectAllowed);

  void set effectAllowed(String value) { _ptr.effectAllowed = _unwrap(value); }

  FileList get files() => _wrap(_ptr.files);

  DataTransferItemList get items() => _wrap(_ptr.items);

  List get types() => _wrap(_ptr.types);

  void clearData([String type = null]) {
    if (type === null) {
      _ptr.clearData();
      return;
    } else {
      _ptr.clearData(_unwrap(type));
      return;
    }
  }

  String getData(String type) {
    return _wrap(_ptr.getData(_unwrap(type)));
  }

  bool setData(String type, String data) {
    return _wrap(_ptr.setData(_unwrap(type), _unwrap(data)));
  }

  void setDragImage(ImageElement image, int x, int y) {
    _ptr.setDragImage(_unwrap(image), _unwrap(x), _unwrap(y));
    return;
  }
}

class _CloseEventImpl extends _EventImpl implements CloseEvent {
  _CloseEventImpl._wrap(ptr) : super._wrap(ptr);

  int get code() => _wrap(_ptr.code);

  String get reason() => _wrap(_ptr.reason);

  bool get wasClean() => _wrap(_ptr.wasClean);
}

class _CommentImpl extends _CharacterDataImpl implements Comment {
  _CommentImpl._wrap(ptr) : super._wrap(ptr);
}

class _CompositionEventImpl extends _UIEventImpl implements CompositionEvent {
  _CompositionEventImpl._wrap(ptr) : super._wrap(ptr);

  String get data() => _wrap(_ptr.data);

  void initCompositionEvent(String typeArg, bool canBubbleArg, bool cancelableArg, Window viewArg, String dataArg) {
    _ptr.initCompositionEvent(_unwrap(typeArg), _unwrap(canBubbleArg), _unwrap(cancelableArg), _unwrap(viewArg), _unwrap(dataArg));
    return;
  }
}

class _ConsoleImpl extends _DOMTypeBase implements Console {
  _ConsoleImpl._wrap(ptr) : super._wrap(ptr);

  MemoryInfo get memory() => _wrap(_ptr.memory);

  void assertCondition(bool condition, Object arg) {
    _ptr.assertCondition(_unwrap(condition), _unwrap(arg));
    return;
  }

  void count() {
    _ptr.count();
    return;
  }

  void debug(Object arg) {
    _ptr.debug(_unwrap(arg));
    return;
  }

  void dir() {
    _ptr.dir();
    return;
  }

  void dirxml() {
    _ptr.dirxml();
    return;
  }

  void error(Object arg) {
    _ptr.error(_unwrap(arg));
    return;
  }

  void group(Object arg) {
    _ptr.group(_unwrap(arg));
    return;
  }

  void groupCollapsed(Object arg) {
    _ptr.groupCollapsed(_unwrap(arg));
    return;
  }

  void groupEnd() {
    _ptr.groupEnd();
    return;
  }

  void info(Object arg) {
    _ptr.info(_unwrap(arg));
    return;
  }

  void log(Object arg) {
    _ptr.log(_unwrap(arg));
    return;
  }

  void markTimeline() {
    _ptr.markTimeline();
    return;
  }

  void profile(String title) {
    _ptr.profile(_unwrap(title));
    return;
  }

  void profileEnd(String title) {
    _ptr.profileEnd(_unwrap(title));
    return;
  }

  void time(String title) {
    _ptr.time(_unwrap(title));
    return;
  }

  void timeEnd(String title, Object arg) {
    _ptr.timeEnd(_unwrap(title), _unwrap(arg));
    return;
  }

  void timeStamp(Object arg) {
    _ptr.timeStamp(_unwrap(arg));
    return;
  }

  void trace(Object arg) {
    _ptr.trace(_unwrap(arg));
    return;
  }

  void warn(Object arg) {
    _ptr.warn(_unwrap(arg));
    return;
  }
}

class _ContentElementImpl extends _ElementImpl implements ContentElement {
  _ContentElementImpl._wrap(ptr) : super._wrap(ptr);

  String get select() => _wrap(_ptr.select);

  void set select(String value) { _ptr.select = _unwrap(value); }
}

class _ConvolverNodeImpl extends _AudioNodeImpl implements ConvolverNode {
  _ConvolverNodeImpl._wrap(ptr) : super._wrap(ptr);

  AudioBuffer get buffer() => _wrap(_ptr.buffer);

  void set buffer(AudioBuffer value) { _ptr.buffer = _unwrap(value); }

  bool get normalize() => _wrap(_ptr.normalize);

  void set normalize(bool value) { _ptr.normalize = _unwrap(value); }
}

class _CoordinatesImpl extends _DOMTypeBase implements Coordinates {
  _CoordinatesImpl._wrap(ptr) : super._wrap(ptr);

  num get accuracy() => _wrap(_ptr.accuracy);

  num get altitude() => _wrap(_ptr.altitude);

  num get altitudeAccuracy() => _wrap(_ptr.altitudeAccuracy);

  num get heading() => _wrap(_ptr.heading);

  num get latitude() => _wrap(_ptr.latitude);

  num get longitude() => _wrap(_ptr.longitude);

  num get speed() => _wrap(_ptr.speed);
}

class _CounterImpl extends _DOMTypeBase implements Counter {
  _CounterImpl._wrap(ptr) : super._wrap(ptr);

  String get identifier() => _wrap(_ptr.identifier);

  String get listStyle() => _wrap(_ptr.listStyle);

  String get separator() => _wrap(_ptr.separator);
}

class _CryptoImpl extends _DOMTypeBase implements Crypto {
  _CryptoImpl._wrap(ptr) : super._wrap(ptr);

  void getRandomValues(ArrayBufferView array) {
    _ptr.getRandomValues(_unwrap(array));
    return;
  }
}

class _CustomEventImpl extends _EventImpl implements CustomEvent {
  _CustomEventImpl._wrap(ptr) : super._wrap(ptr);

  Object get detail() => _wrap(_ptr.detail);

  void initCustomEvent(String typeArg, bool canBubbleArg, bool cancelableArg, Object detailArg) {
    _ptr.initCustomEvent(_unwrap(typeArg), _unwrap(canBubbleArg), _unwrap(cancelableArg), _unwrap(detailArg));
    return;
  }
}

class _DListElementImpl extends _ElementImpl implements DListElement {
  _DListElementImpl._wrap(ptr) : super._wrap(ptr);

  bool get compact() => _wrap(_ptr.compact);

  void set compact(bool value) { _ptr.compact = _unwrap(value); }
}

class _DOMApplicationCacheImpl extends _EventTargetImpl implements DOMApplicationCache {
  _DOMApplicationCacheImpl._wrap(ptr) : super._wrap(ptr);

  _DOMApplicationCacheEventsImpl get on() {
    if (_on == null) _on = new _DOMApplicationCacheEventsImpl(this);
    return _on;
  }

  int get status() => _wrap(_ptr.status);

  void abort() {
    _ptr.abort();
    return;
  }

  void _addEventListener(String type, EventListener listener, [bool useCapture = null]) {
    if (useCapture === null) {
      _ptr.addEventListener(_unwrap(type), _unwrap(listener));
      return;
    } else {
      _ptr.addEventListener(_unwrap(type), _unwrap(listener), _unwrap(useCapture));
      return;
    }
  }

  bool _dispatchEvent(Event evt) {
    return _wrap(_ptr.dispatchEvent(_unwrap(evt)));
  }

  void _removeEventListener(String type, EventListener listener, [bool useCapture = null]) {
    if (useCapture === null) {
      _ptr.removeEventListener(_unwrap(type), _unwrap(listener));
      return;
    } else {
      _ptr.removeEventListener(_unwrap(type), _unwrap(listener), _unwrap(useCapture));
      return;
    }
  }

  void swapCache() {
    _ptr.swapCache();
    return;
  }

  void update() {
    _ptr.update();
    return;
  }
}

class _DOMApplicationCacheEventsImpl extends _EventsImpl implements DOMApplicationCacheEvents {
  _DOMApplicationCacheEventsImpl(_ptr) : super(_ptr);

  EventListenerList get cached() => _get('cached');

  EventListenerList get checking() => _get('checking');

  EventListenerList get downloading() => _get('downloading');

  EventListenerList get error() => _get('error');

  EventListenerList get noUpdate() => _get('noupdate');

  EventListenerList get obsolete() => _get('obsolete');

  EventListenerList get progress() => _get('progress');

  EventListenerList get updateReady() => _get('updateready');
}

class _DOMExceptionImpl extends _DOMTypeBase implements DOMException {
  _DOMExceptionImpl._wrap(ptr) : super._wrap(ptr);

  int get code() => _wrap(_ptr.code);

  String get message() => _wrap(_ptr.message);

  String get name() => _wrap(_ptr.name);

  String toString() {
    return _wrap(_ptr.toString());
  }
}

class _DOMFileSystemImpl extends _DOMTypeBase implements DOMFileSystem {
  _DOMFileSystemImpl._wrap(ptr) : super._wrap(ptr);

  String get name() => _wrap(_ptr.name);

  DirectoryEntry get root() => _wrap(_ptr.root);
}

class _DOMFileSystemSyncImpl extends _DOMTypeBase implements DOMFileSystemSync {
  _DOMFileSystemSyncImpl._wrap(ptr) : super._wrap(ptr);

  String get name() => _wrap(_ptr.name);

  DirectoryEntrySync get root() => _wrap(_ptr.root);
}

class _DOMFormDataImpl extends _DOMTypeBase implements DOMFormData {
  _DOMFormDataImpl._wrap(ptr) : super._wrap(ptr);

  void append(String name, String value, String filename) {
    _ptr.append(_unwrap(name), _unwrap(value), _unwrap(filename));
    return;
  }
}

class _DOMImplementationImpl extends _DOMTypeBase implements DOMImplementation {
  _DOMImplementationImpl._wrap(ptr) : super._wrap(ptr);

  CSSStyleSheet createCSSStyleSheet(String title, String media) {
    return _wrap(_ptr.createCSSStyleSheet(_unwrap(title), _unwrap(media)));
  }

  Document createDocument(String namespaceURI, String qualifiedName, DocumentType doctype) {
    return _FixHtmlDocumentReference(_wrap(_ptr.createDocument(_unwrap(namespaceURI), _unwrap(qualifiedName), _unwrap(doctype))));
  }

  DocumentType createDocumentType(String qualifiedName, String publicId, String systemId) {
    return _wrap(_ptr.createDocumentType(_unwrap(qualifiedName), _unwrap(publicId), _unwrap(systemId)));
  }

  Document createHTMLDocument(String title) {
    return _FixHtmlDocumentReference(_wrap(_ptr.createHTMLDocument(_unwrap(title))));
  }

  bool hasFeature(String feature, String version) {
    return _wrap(_ptr.hasFeature(_unwrap(feature), _unwrap(version)));
  }
}

class _DOMMimeTypeImpl extends _DOMTypeBase implements DOMMimeType {
  _DOMMimeTypeImpl._wrap(ptr) : super._wrap(ptr);

  String get description() => _wrap(_ptr.description);

  DOMPlugin get enabledPlugin() => _wrap(_ptr.enabledPlugin);

  String get suffixes() => _wrap(_ptr.suffixes);

  String get type() => _wrap(_ptr.type);
}

class _DOMMimeTypeArrayImpl extends _DOMTypeBase implements DOMMimeTypeArray {
  _DOMMimeTypeArrayImpl._wrap(ptr) : super._wrap(ptr);

  int get length() => _wrap(_ptr.length);

  DOMMimeType item(int index) {
    return _wrap(_ptr.item(_unwrap(index)));
  }

  DOMMimeType namedItem(String name) {
    return _wrap(_ptr.namedItem(_unwrap(name)));
  }
}

class _DOMParserImpl extends _DOMTypeBase implements DOMParser {
  _DOMParserImpl._wrap(ptr) : super._wrap(ptr);

  Document parseFromString(String str, String contentType) {
    return _FixHtmlDocumentReference(_wrap(_ptr.parseFromString(_unwrap(str), _unwrap(contentType))));
  }
}

class _DOMPluginImpl extends _DOMTypeBase implements DOMPlugin {
  _DOMPluginImpl._wrap(ptr) : super._wrap(ptr);

  String get description() => _wrap(_ptr.description);

  String get filename() => _wrap(_ptr.filename);

  int get length() => _wrap(_ptr.length);

  String get name() => _wrap(_ptr.name);

  DOMMimeType item(int index) {
    return _wrap(_ptr.item(_unwrap(index)));
  }

  DOMMimeType namedItem(String name) {
    return _wrap(_ptr.namedItem(_unwrap(name)));
  }
}

class _DOMPluginArrayImpl extends _DOMTypeBase implements DOMPluginArray {
  _DOMPluginArrayImpl._wrap(ptr) : super._wrap(ptr);

  int get length() => _wrap(_ptr.length);

  DOMPlugin item(int index) {
    return _wrap(_ptr.item(_unwrap(index)));
  }

  DOMPlugin namedItem(String name) {
    return _wrap(_ptr.namedItem(_unwrap(name)));
  }

  void refresh(bool reload) {
    _ptr.refresh(_unwrap(reload));
    return;
  }
}

class _DOMSelectionImpl extends _DOMTypeBase implements DOMSelection {
  _DOMSelectionImpl._wrap(ptr) : super._wrap(ptr);

  Node get anchorNode() => _wrap(_ptr.anchorNode);

  int get anchorOffset() => _wrap(_ptr.anchorOffset);

  Node get baseNode() => _wrap(_ptr.baseNode);

  int get baseOffset() => _wrap(_ptr.baseOffset);

  Node get extentNode() => _wrap(_ptr.extentNode);

  int get extentOffset() => _wrap(_ptr.extentOffset);

  Node get focusNode() => _wrap(_ptr.focusNode);

  int get focusOffset() => _wrap(_ptr.focusOffset);

  bool get isCollapsed() => _wrap(_ptr.isCollapsed);

  int get rangeCount() => _wrap(_ptr.rangeCount);

  String get type() => _wrap(_ptr.type);

  void addRange(Range range) {
    _ptr.addRange(_unwrap(range));
    return;
  }

  void collapse(Node node, int index) {
    _ptr.collapse(_unwrap(node), _unwrap(index));
    return;
  }

  void collapseToEnd() {
    _ptr.collapseToEnd();
    return;
  }

  void collapseToStart() {
    _ptr.collapseToStart();
    return;
  }

  bool containsNode(Node node, bool allowPartial) {
    return _wrap(_ptr.containsNode(_unwrap(node), _unwrap(allowPartial)));
  }

  void deleteFromDocument() {
    _ptr.deleteFromDocument();
    return;
  }

  void empty() {
    _ptr.empty();
    return;
  }

  void extend(Node node, int offset) {
    _ptr.extend(_unwrap(node), _unwrap(offset));
    return;
  }

  Range getRangeAt(int index) {
    return _wrap(_ptr.getRangeAt(_unwrap(index)));
  }

  void modify(String alter, String direction, String granularity) {
    _ptr.modify(_unwrap(alter), _unwrap(direction), _unwrap(granularity));
    return;
  }

  void removeAllRanges() {
    _ptr.removeAllRanges();
    return;
  }

  void selectAllChildren(Node node) {
    _ptr.selectAllChildren(_unwrap(node));
    return;
  }

  void setBaseAndExtent(Node baseNode, int baseOffset, Node extentNode, int extentOffset) {
    _ptr.setBaseAndExtent(_unwrap(baseNode), _unwrap(baseOffset), _unwrap(extentNode), _unwrap(extentOffset));
    return;
  }

  void setPosition(Node node, int offset) {
    _ptr.setPosition(_unwrap(node), _unwrap(offset));
    return;
  }

  String toString() {
    return _wrap(_ptr.toString());
  }
}

class _DOMSettableTokenListImpl extends _DOMTokenListImpl implements DOMSettableTokenList {
  _DOMSettableTokenListImpl._wrap(ptr) : super._wrap(ptr);

  String get value() => _wrap(_ptr.value);

  void set value(String value) { _ptr.value = _unwrap(value); }
}

class _DOMTokenListImpl extends _DOMTypeBase implements DOMTokenList {
  _DOMTokenListImpl._wrap(ptr) : super._wrap(ptr);

  int get length() => _wrap(_ptr.length);

  void add(String token) {
    _ptr.add(_unwrap(token));
    return;
  }

  bool contains(String token) {
    return _wrap(_ptr.contains(_unwrap(token)));
  }

  String item(int index) {
    return _wrap(_ptr.item(_unwrap(index)));
  }

  void remove(String token) {
    _ptr.remove(_unwrap(token));
    return;
  }

  String toString() {
    return _wrap(_ptr.toString());
  }

  bool toggle(String token) {
    return _wrap(_ptr.toggle(_unwrap(token)));
  }
}

class _DOMURLImpl extends _DOMTypeBase implements DOMURL {
  _DOMURLImpl._wrap(ptr) : super._wrap(ptr);

  String createObjectURL(var blob_OR_stream) {
    if (blob_OR_stream is MediaStream) {
      return _wrap(_ptr.createObjectURL(_unwrap(blob_OR_stream)));
    } else {
      if (blob_OR_stream is Blob) {
        return _wrap(_ptr.createObjectURL(_unwrap(blob_OR_stream)));
      }
    }
    throw "Incorrect number or type of arguments";
  }

  void revokeObjectURL(String url) {
    _ptr.revokeObjectURL(_unwrap(url));
    return;
  }
}

class _DataTransferItemImpl extends _DOMTypeBase implements DataTransferItem {
  _DataTransferItemImpl._wrap(ptr) : super._wrap(ptr);

  String get kind() => _wrap(_ptr.kind);

  String get type() => _wrap(_ptr.type);

  Blob getAsFile() {
    return _wrap(_ptr.getAsFile());
  }

  void getAsString([StringCallback callback = null]) {
    if (callback === null) {
      _ptr.getAsString();
      return;
    } else {
      _ptr.getAsString(_unwrap(callback));
      return;
    }
  }
}

class _DataTransferItemListImpl extends _DOMTypeBase implements DataTransferItemList {
  _DataTransferItemListImpl._wrap(ptr) : super._wrap(ptr);

  int get length() => _wrap(_ptr.length);

  void add(var data_OR_file, [String type = null]) {
    if (data_OR_file is File) {
      if (type === null) {
        _ptr.add(_unwrap(data_OR_file));
        return;
      }
    } else {
      if (data_OR_file is String) {
        _ptr.add(_unwrap(data_OR_file), _unwrap(type));
        return;
      }
    }
    throw "Incorrect number or type of arguments";
  }

  void clear() {
    _ptr.clear();
    return;
  }

  DataTransferItem item(int index) {
    return _wrap(_ptr.item(_unwrap(index)));
  }
}

class _DataViewImpl extends _ArrayBufferViewImpl implements DataView {
  _DataViewImpl._wrap(ptr) : super._wrap(ptr);

  num getFloat32(int byteOffset, [bool littleEndian = null]) {
    if (littleEndian === null) {
      return _wrap(_ptr.getFloat32(_unwrap(byteOffset)));
    } else {
      return _wrap(_ptr.getFloat32(_unwrap(byteOffset), _unwrap(littleEndian)));
    }
  }

  num getFloat64(int byteOffset, [bool littleEndian = null]) {
    if (littleEndian === null) {
      return _wrap(_ptr.getFloat64(_unwrap(byteOffset)));
    } else {
      return _wrap(_ptr.getFloat64(_unwrap(byteOffset), _unwrap(littleEndian)));
    }
  }

  int getInt16(int byteOffset, [bool littleEndian = null]) {
    if (littleEndian === null) {
      return _wrap(_ptr.getInt16(_unwrap(byteOffset)));
    } else {
      return _wrap(_ptr.getInt16(_unwrap(byteOffset), _unwrap(littleEndian)));
    }
  }

  int getInt32(int byteOffset, [bool littleEndian = null]) {
    if (littleEndian === null) {
      return _wrap(_ptr.getInt32(_unwrap(byteOffset)));
    } else {
      return _wrap(_ptr.getInt32(_unwrap(byteOffset), _unwrap(littleEndian)));
    }
  }

  Object getInt8() {
    return _wrap(_ptr.getInt8());
  }

  int getUint16(int byteOffset, [bool littleEndian = null]) {
    if (littleEndian === null) {
      return _wrap(_ptr.getUint16(_unwrap(byteOffset)));
    } else {
      return _wrap(_ptr.getUint16(_unwrap(byteOffset), _unwrap(littleEndian)));
    }
  }

  int getUint32(int byteOffset, [bool littleEndian = null]) {
    if (littleEndian === null) {
      return _wrap(_ptr.getUint32(_unwrap(byteOffset)));
    } else {
      return _wrap(_ptr.getUint32(_unwrap(byteOffset), _unwrap(littleEndian)));
    }
  }

  Object getUint8() {
    return _wrap(_ptr.getUint8());
  }

  void setFloat32(int byteOffset, num value, [bool littleEndian = null]) {
    if (littleEndian === null) {
      _ptr.setFloat32(_unwrap(byteOffset), _unwrap(value));
      return;
    } else {
      _ptr.setFloat32(_unwrap(byteOffset), _unwrap(value), _unwrap(littleEndian));
      return;
    }
  }

  void setFloat64(int byteOffset, num value, [bool littleEndian = null]) {
    if (littleEndian === null) {
      _ptr.setFloat64(_unwrap(byteOffset), _unwrap(value));
      return;
    } else {
      _ptr.setFloat64(_unwrap(byteOffset), _unwrap(value), _unwrap(littleEndian));
      return;
    }
  }

  void setInt16(int byteOffset, int value, [bool littleEndian = null]) {
    if (littleEndian === null) {
      _ptr.setInt16(_unwrap(byteOffset), _unwrap(value));
      return;
    } else {
      _ptr.setInt16(_unwrap(byteOffset), _unwrap(value), _unwrap(littleEndian));
      return;
    }
  }

  void setInt32(int byteOffset, int value, [bool littleEndian = null]) {
    if (littleEndian === null) {
      _ptr.setInt32(_unwrap(byteOffset), _unwrap(value));
      return;
    } else {
      _ptr.setInt32(_unwrap(byteOffset), _unwrap(value), _unwrap(littleEndian));
      return;
    }
  }

  void setInt8() {
    _ptr.setInt8();
    return;
  }

  void setUint16(int byteOffset, int value, [bool littleEndian = null]) {
    if (littleEndian === null) {
      _ptr.setUint16(_unwrap(byteOffset), _unwrap(value));
      return;
    } else {
      _ptr.setUint16(_unwrap(byteOffset), _unwrap(value), _unwrap(littleEndian));
      return;
    }
  }

  void setUint32(int byteOffset, int value, [bool littleEndian = null]) {
    if (littleEndian === null) {
      _ptr.setUint32(_unwrap(byteOffset), _unwrap(value));
      return;
    } else {
      _ptr.setUint32(_unwrap(byteOffset), _unwrap(value), _unwrap(littleEndian));
      return;
    }
  }

  void setUint8() {
    _ptr.setUint8();
    return;
  }
}

class _DatabaseImpl extends _DOMTypeBase implements Database {
  _DatabaseImpl._wrap(ptr) : super._wrap(ptr);

  String get version() => _wrap(_ptr.version);

  void changeVersion(String oldVersion, String newVersion, [SQLTransactionCallback callback = null, SQLTransactionErrorCallback errorCallback = null, VoidCallback successCallback = null]) {
    if (callback === null) {
      if (errorCallback === null) {
        if (successCallback === null) {
          _ptr.changeVersion(_unwrap(oldVersion), _unwrap(newVersion));
          return;
        }
      }
    } else {
      if (errorCallback === null) {
        if (successCallback === null) {
          _ptr.changeVersion(_unwrap(oldVersion), _unwrap(newVersion), _unwrap(callback));
          return;
        }
      } else {
        if (successCallback === null) {
          _ptr.changeVersion(_unwrap(oldVersion), _unwrap(newVersion), _unwrap(callback), _unwrap(errorCallback));
          return;
        } else {
          _ptr.changeVersion(_unwrap(oldVersion), _unwrap(newVersion), _unwrap(callback), _unwrap(errorCallback), _unwrap(successCallback));
          return;
        }
      }
    }
    throw "Incorrect number or type of arguments";
  }

  void readTransaction(SQLTransactionCallback callback, [SQLTransactionErrorCallback errorCallback = null, VoidCallback successCallback = null]) {
    if (errorCallback === null) {
      if (successCallback === null) {
        _ptr.readTransaction(_unwrap(callback));
        return;
      }
    } else {
      if (successCallback === null) {
        _ptr.readTransaction(_unwrap(callback), _unwrap(errorCallback));
        return;
      } else {
        _ptr.readTransaction(_unwrap(callback), _unwrap(errorCallback), _unwrap(successCallback));
        return;
      }
    }
    throw "Incorrect number or type of arguments";
  }

  void transaction(SQLTransactionCallback callback, [SQLTransactionErrorCallback errorCallback = null, VoidCallback successCallback = null]) {
    if (errorCallback === null) {
      if (successCallback === null) {
        _ptr.transaction(_unwrap(callback));
        return;
      }
    } else {
      if (successCallback === null) {
        _ptr.transaction(_unwrap(callback), _unwrap(errorCallback));
        return;
      } else {
        _ptr.transaction(_unwrap(callback), _unwrap(errorCallback), _unwrap(successCallback));
        return;
      }
    }
    throw "Incorrect number or type of arguments";
  }
}

class _DatabaseSyncImpl extends _DOMTypeBase implements DatabaseSync {
  _DatabaseSyncImpl._wrap(ptr) : super._wrap(ptr);

  String get lastErrorMessage() => _wrap(_ptr.lastErrorMessage);

  String get version() => _wrap(_ptr.version);

  void changeVersion(String oldVersion, String newVersion, [SQLTransactionSyncCallback callback = null]) {
    if (callback === null) {
      _ptr.changeVersion(_unwrap(oldVersion), _unwrap(newVersion));
      return;
    } else {
      _ptr.changeVersion(_unwrap(oldVersion), _unwrap(newVersion), _unwrap(callback));
      return;
    }
  }

  void readTransaction(SQLTransactionSyncCallback callback) {
    _ptr.readTransaction(_unwrap(callback));
    return;
  }

  void transaction(SQLTransactionSyncCallback callback) {
    _ptr.transaction(_unwrap(callback));
    return;
  }
}

class _DedicatedWorkerContextImpl extends _WorkerContextImpl implements DedicatedWorkerContext {
  _DedicatedWorkerContextImpl._wrap(ptr) : super._wrap(ptr);

  EventListener get onmessage() => _wrap(_ptr.onmessage);

  void set onmessage(EventListener value) { _ptr.onmessage = _unwrap(value); }

  void postMessage(Object message, [List messagePorts = null]) {
    if (messagePorts === null) {
      _ptr.postMessage(_unwrap(message));
      return;
    } else {
      _ptr.postMessage(_unwrap(message), _unwrap(messagePorts));
      return;
    }
  }

  void webkitPostMessage(Object message, [List transferList = null]) {
    if (transferList === null) {
      _ptr.webkitPostMessage(_unwrap(message));
      return;
    } else {
      _ptr.webkitPostMessage(_unwrap(message), _unwrap(transferList));
      return;
    }
  }
}

class _DelayNodeImpl extends _AudioNodeImpl implements DelayNode {
  _DelayNodeImpl._wrap(ptr) : super._wrap(ptr);

  AudioParam get delayTime() => _wrap(_ptr.delayTime);
}

class _DeprecatedPeerConnectionImpl extends _DOMTypeBase implements DeprecatedPeerConnection {
  _DeprecatedPeerConnectionImpl._wrap(ptr) : super._wrap(ptr);

  MediaStreamList get localStreams() => _wrap(_ptr.localStreams);

  EventListener get onaddstream() => _wrap(_ptr.onaddstream);

  void set onaddstream(EventListener value) { _ptr.onaddstream = _unwrap(value); }

  EventListener get onconnecting() => _wrap(_ptr.onconnecting);

  void set onconnecting(EventListener value) { _ptr.onconnecting = _unwrap(value); }

  EventListener get onmessage() => _wrap(_ptr.onmessage);

  void set onmessage(EventListener value) { _ptr.onmessage = _unwrap(value); }

  EventListener get onopen() => _wrap(_ptr.onopen);

  void set onopen(EventListener value) { _ptr.onopen = _unwrap(value); }

  EventListener get onremovestream() => _wrap(_ptr.onremovestream);

  void set onremovestream(EventListener value) { _ptr.onremovestream = _unwrap(value); }

  EventListener get onstatechange() => _wrap(_ptr.onstatechange);

  void set onstatechange(EventListener value) { _ptr.onstatechange = _unwrap(value); }

  int get readyState() => _wrap(_ptr.readyState);

  MediaStreamList get remoteStreams() => _wrap(_ptr.remoteStreams);

  void addEventListener(String type, EventListener listener, [bool useCapture = null]) {
    if (useCapture === null) {
      _ptr.addEventListener(_unwrap(type), _unwrap(listener));
      return;
    } else {
      _ptr.addEventListener(_unwrap(type), _unwrap(listener), _unwrap(useCapture));
      return;
    }
  }

  void addStream(MediaStream stream) {
    _ptr.addStream(_unwrap(stream));
    return;
  }

  void close() {
    _ptr.close();
    return;
  }

  bool dispatchEvent(Event event) {
    return _wrap(_ptr.dispatchEvent(_unwrap(event)));
  }

  void processSignalingMessage(String message) {
    _ptr.processSignalingMessage(_unwrap(message));
    return;
  }

  void removeEventListener(String type, EventListener listener, [bool useCapture = null]) {
    if (useCapture === null) {
      _ptr.removeEventListener(_unwrap(type), _unwrap(listener));
      return;
    } else {
      _ptr.removeEventListener(_unwrap(type), _unwrap(listener), _unwrap(useCapture));
      return;
    }
  }

  void removeStream(MediaStream stream) {
    _ptr.removeStream(_unwrap(stream));
    return;
  }

  void send(String text) {
    _ptr.send(_unwrap(text));
    return;
  }
}

class _DetailsElementImpl extends _ElementImpl implements DetailsElement {
  _DetailsElementImpl._wrap(ptr) : super._wrap(ptr);

  bool get open() => _wrap(_ptr.open);

  void set open(bool value) { _ptr.open = _unwrap(value); }
}

class _DeviceMotionEventImpl extends _EventImpl implements DeviceMotionEvent {
  _DeviceMotionEventImpl._wrap(ptr) : super._wrap(ptr);

  num get interval() => _wrap(_ptr.interval);
}

class _DeviceOrientationEventImpl extends _EventImpl implements DeviceOrientationEvent {
  _DeviceOrientationEventImpl._wrap(ptr) : super._wrap(ptr);

  bool get absolute() => _wrap(_ptr.absolute);

  num get alpha() => _wrap(_ptr.alpha);

  num get beta() => _wrap(_ptr.beta);

  num get gamma() => _wrap(_ptr.gamma);

  void initDeviceOrientationEvent(String type, bool bubbles, bool cancelable, num alpha, num beta, num gamma, bool absolute) {
    _ptr.initDeviceOrientationEvent(_unwrap(type), _unwrap(bubbles), _unwrap(cancelable), _unwrap(alpha), _unwrap(beta), _unwrap(gamma), _unwrap(absolute));
    return;
  }
}

class _DirectoryElementImpl extends _ElementImpl implements DirectoryElement {
  _DirectoryElementImpl._wrap(ptr) : super._wrap(ptr);

  bool get compact() => _wrap(_ptr.compact);

  void set compact(bool value) { _ptr.compact = _unwrap(value); }
}

class _DirectoryEntryImpl extends _EntryImpl implements DirectoryEntry {
  _DirectoryEntryImpl._wrap(ptr) : super._wrap(ptr);

  DirectoryReader createReader() {
    return _wrap(_ptr.createReader());
  }

  void getDirectory(String path, [Object flags = null, EntryCallback successCallback = null, ErrorCallback errorCallback = null]) {
    if (flags === null) {
      if (successCallback === null) {
        if (errorCallback === null) {
          _ptr.getDirectory(_unwrap(path));
          return;
        }
      }
    } else {
      if (successCallback === null) {
        if (errorCallback === null) {
          _ptr.getDirectory(_unwrap(path), _unwrap(flags));
          return;
        }
      } else {
        if (errorCallback === null) {
          _ptr.getDirectory(_unwrap(path), _unwrap(flags), _unwrap(successCallback));
          return;
        } else {
          _ptr.getDirectory(_unwrap(path), _unwrap(flags), _unwrap(successCallback), _unwrap(errorCallback));
          return;
        }
      }
    }
    throw "Incorrect number or type of arguments";
  }

  void getFile(String path, [Object flags = null, EntryCallback successCallback = null, ErrorCallback errorCallback = null]) {
    if (flags === null) {
      if (successCallback === null) {
        if (errorCallback === null) {
          _ptr.getFile(_unwrap(path));
          return;
        }
      }
    } else {
      if (successCallback === null) {
        if (errorCallback === null) {
          _ptr.getFile(_unwrap(path), _unwrap(flags));
          return;
        }
      } else {
        if (errorCallback === null) {
          _ptr.getFile(_unwrap(path), _unwrap(flags), _unwrap(successCallback));
          return;
        } else {
          _ptr.getFile(_unwrap(path), _unwrap(flags), _unwrap(successCallback), _unwrap(errorCallback));
          return;
        }
      }
    }
    throw "Incorrect number or type of arguments";
  }

  void removeRecursively(VoidCallback successCallback, [ErrorCallback errorCallback = null]) {
    if (errorCallback === null) {
      _ptr.removeRecursively(_unwrap(successCallback));
      return;
    } else {
      _ptr.removeRecursively(_unwrap(successCallback), _unwrap(errorCallback));
      return;
    }
  }
}

class _DirectoryEntrySyncImpl extends _EntrySyncImpl implements DirectoryEntrySync {
  _DirectoryEntrySyncImpl._wrap(ptr) : super._wrap(ptr);

  DirectoryReaderSync createReader() {
    return _wrap(_ptr.createReader());
  }

  DirectoryEntrySync getDirectory(String path, Object flags) {
    return _wrap(_ptr.getDirectory(_unwrap(path), _unwrap(flags)));
  }

  FileEntrySync getFile(String path, Object flags) {
    return _wrap(_ptr.getFile(_unwrap(path), _unwrap(flags)));
  }

  void removeRecursively() {
    _ptr.removeRecursively();
    return;
  }
}

class _DirectoryReaderImpl extends _DOMTypeBase implements DirectoryReader {
  _DirectoryReaderImpl._wrap(ptr) : super._wrap(ptr);

  void readEntries(EntriesCallback successCallback, [ErrorCallback errorCallback = null]) {
    if (errorCallback === null) {
      _ptr.readEntries(_unwrap(successCallback));
      return;
    } else {
      _ptr.readEntries(_unwrap(successCallback), _unwrap(errorCallback));
      return;
    }
  }
}

class _DirectoryReaderSyncImpl extends _DOMTypeBase implements DirectoryReaderSync {
  _DirectoryReaderSyncImpl._wrap(ptr) : super._wrap(ptr);

  EntryArraySync readEntries() {
    return _wrap(_ptr.readEntries());
  }
}

class _DivElementImpl extends _ElementImpl implements DivElement {
  _DivElementImpl._wrap(ptr) : super._wrap(ptr);

  String get align() => _wrap(_ptr.align);

  void set align(String value) { _ptr.align = _unwrap(value); }
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

class _DocumentImpl extends _ElementImpl
    implements Document {

  _DocumentEventsImpl get on() {
    if (_on == null) _on = new _DocumentEventsImpl(_wrappedDocumentPtr);
    return _on;
  }

  Element get activeElement() => _wrap(_documentPtr.activeElement);

  Element get body() => _wrap(_documentPtr.body);

  void set body(Element value) { _documentPtr.body = _unwrap(value); }

  String get charset() => _wrap(_documentPtr.charset);

  void set charset(String value) { _documentPtr.charset = _unwrap(value); }

  String get cookie() => _wrap(_documentPtr.cookie);

  void set cookie(String value) { _documentPtr.cookie = _unwrap(value); }

  Window get window() => _wrap(_documentPtr.defaultView);

  String get domain() => _wrap(_documentPtr.domain);

  HeadElement get head() => _wrap(_documentPtr.head);

  String get lastModified() => _wrap(_documentPtr.lastModified);

  String get preferredStylesheetSet() => _wrap(_documentPtr.preferredStylesheetSet);

  String get readyState() => _wrap(_documentPtr.readyState);

  String get referrer() => _wrap(_documentPtr.referrer);

  String get selectedStylesheetSet() => _wrap(_documentPtr.selectedStylesheetSet);

  void set selectedStylesheetSet(String value) { _documentPtr.selectedStylesheetSet = _unwrap(value); }

  StyleSheetList get styleSheets() => _wrap(_documentPtr.styleSheets);

  String get title() => _wrap(_documentPtr.title);

  void set title(String value) { _documentPtr.title = _unwrap(value); }

  Element get webkitCurrentFullScreenElement() => _wrap(_documentPtr.webkitCurrentFullScreenElement);

  bool get webkitFullScreenKeyboardInputAllowed() => _wrap(_documentPtr.webkitFullScreenKeyboardInputAllowed);

  Element get webkitFullscreenElement() => _wrap(_documentPtr.webkitFullscreenElement);

  bool get webkitFullscreenEnabled() => _wrap(_documentPtr.webkitFullscreenEnabled);

  bool get webkitHidden() => _wrap(_documentPtr.webkitHidden);

  bool get webkitIsFullScreen() => _wrap(_documentPtr.webkitIsFullScreen);

  String get webkitVisibilityState() => _wrap(_documentPtr.webkitVisibilityState);

  Range caretRangeFromPoint(int x, int y) {
    return _wrap(_documentPtr.caretRangeFromPoint(_unwrap(x), _unwrap(y)));
  }

  CDATASection createCDATASection(String data) {
    return _wrap(_documentPtr.createCDATASection(_unwrap(data)));
  }

  DocumentFragment createDocumentFragment() {
    return _wrap(_documentPtr.createDocumentFragment());
  }

  Element _createElement(String tagName) {
    return _wrap(_documentPtr.createElement(_unwrap(tagName)));
  }

  Element _createElementNS(String namespaceURI, String qualifiedName) {
    return _wrap(_documentPtr.createElementNS(_unwrap(namespaceURI), _unwrap(qualifiedName)));
  }

  Event _createEvent(String eventType) {
    return _wrap(_documentPtr.createEvent(_unwrap(eventType)));
  }

  Range createRange() {
    return _wrap(_documentPtr.createRange());
  }

  Text _createTextNode(String data) {
    return _wrap(_documentPtr.createTextNode(_unwrap(data)));
  }

  Touch createTouch(Window window, EventTarget target, int identifier, int pageX, int pageY, int screenX, int screenY, int webkitRadiusX, int webkitRadiusY, num webkitRotationAngle, num webkitForce) {
    return _wrap(_documentPtr.createTouch(_unwrap(window), _unwrap(target), _unwrap(identifier), _unwrap(pageX), _unwrap(pageY), _unwrap(screenX), _unwrap(screenY), _unwrap(webkitRadiusX), _unwrap(webkitRadiusY), _unwrap(webkitRotationAngle), _unwrap(webkitForce)));
  }

  TouchList _createTouchList() {
    return _wrap(_documentPtr.createTouchList());
  }

  Element elementFromPoint(int x, int y) {
    return _wrap(_documentPtr.elementFromPoint(_unwrap(x), _unwrap(y)));
  }

  bool execCommand(String command, bool userInterface, String value) {
    return _wrap(_documentPtr.execCommand(_unwrap(command), _unwrap(userInterface), _unwrap(value)));
  }

  CanvasRenderingContext getCSSCanvasContext(String contextId, String name, int width, int height) {
    return _wrap(_documentPtr.getCSSCanvasContext(_unwrap(contextId), _unwrap(name), _unwrap(width), _unwrap(height)));
  }

  bool queryCommandEnabled(String command) {
    return _wrap(_documentPtr.queryCommandEnabled(_unwrap(command)));
  }

  bool queryCommandIndeterm(String command) {
    return _wrap(_documentPtr.queryCommandIndeterm(_unwrap(command)));
  }

  bool queryCommandState(String command) {
    return _wrap(_documentPtr.queryCommandState(_unwrap(command)));
  }

  bool queryCommandSupported(String command) {
    return _wrap(_documentPtr.queryCommandSupported(_unwrap(command)));
  }

  String queryCommandValue(String command) {
    return _wrap(_documentPtr.queryCommandValue(_unwrap(command)));
  }

  void webkitCancelFullScreen() {
    _documentPtr.webkitCancelFullScreen();
    return;
  }

  void webkitExitFullscreen() {
    _documentPtr.webkitExitFullscreen();
    return;
  }

  WebKitNamedFlow webkitGetFlowByName(String name) {
    return _wrap(_documentPtr.webkitGetFlowByName(_unwrap(name)));
  }


  final dom.HTMLDocument _documentPtr;
  final _NodeImpl _wrappedDocumentPtr;
 
_DocumentImpl._wrap(ptr) :
  super._wrap(ptr),
  _documentPtr = ptr.parentNode,
  _wrappedDocumentPtr = ptr.parentNode != null ?
      new _SecretHtmlDocumentImpl._wrap(ptr.parentNode) : null;

  // For efficiency and simplicity, we always use the HtmlElement as the
  // Document but sometimes internally we need the real JS document object.
  _NodeImpl get _rawDocument() => _wrappedDocumentPtr;

  // The document doesn't have a parent element.
  _ElementImpl get parent() => null;
}

// This class should not be externally visible.  If a user ever gets access to
// a _SecretHtmlDocumentImpl object that is a bug.  This object is hidden by
// adding checks to all methods that could an HTMLDocument.  We believe that
// list is limited to Event.target, and HTMLHtmlElement.parent.
// In a wrapper based world there isn't a need for this complexity but we
// use this design for consistency with the wrapperless implementation so
// that bugs show up in both cases.
class _SecretHtmlDocumentImpl extends _NodeImpl implements Node {

  _SecretHtmlDocumentImpl._wrap(ptr) : super._wrap(ptr);

  _DocumentImpl get _documentElement() => _wrap(_ptr.documentElement);
}

EventTarget _FixHtmlDocumentReference(EventTarget eventTarget) {
  if (eventTarget is _SecretHtmlDocumentImpl) {
    _SecretHtmlDocumentImpl secretDocument = eventTarget;
    return secretDocument._documentElement;
  } else {
    return eventTarget;
  }
}

class _DocumentEventsImpl extends _ElementEventsImpl implements DocumentEvents {
  _DocumentEventsImpl(_ptr) : super(_ptr);

  EventListenerList get abort() => _get('abort');

  EventListenerList get beforeCopy() => _get('beforecopy');

  EventListenerList get beforeCut() => _get('beforecut');

  EventListenerList get beforePaste() => _get('beforepaste');

  EventListenerList get blur() => _get('blur');

  EventListenerList get change() => _get('change');

  EventListenerList get click() => _get('click');

  EventListenerList get contextMenu() => _get('contextmenu');

  EventListenerList get copy() => _get('copy');

  EventListenerList get cut() => _get('cut');

  EventListenerList get doubleClick() => _get('dblclick');

  EventListenerList get drag() => _get('drag');

  EventListenerList get dragEnd() => _get('dragend');

  EventListenerList get dragEnter() => _get('dragenter');

  EventListenerList get dragLeave() => _get('dragleave');

  EventListenerList get dragOver() => _get('dragover');

  EventListenerList get dragStart() => _get('dragstart');

  EventListenerList get drop() => _get('drop');

  EventListenerList get error() => _get('error');

  EventListenerList get focus() => _get('focus');

  EventListenerList get fullscreenChange() => _get('webkitfullscreenchange');

  EventListenerList get fullscreenError() => _get('webkitfullscreenerror');

  EventListenerList get input() => _get('input');

  EventListenerList get invalid() => _get('invalid');

  EventListenerList get keyDown() => _get('keydown');

  EventListenerList get keyPress() => _get('keypress');

  EventListenerList get keyUp() => _get('keyup');

  EventListenerList get load() => _get('load');

  EventListenerList get mouseDown() => _get('mousedown');

  EventListenerList get mouseMove() => _get('mousemove');

  EventListenerList get mouseOut() => _get('mouseout');

  EventListenerList get mouseOver() => _get('mouseover');

  EventListenerList get mouseUp() => _get('mouseup');

  EventListenerList get mouseWheel() => _get('mousewheel');

  EventListenerList get paste() => _get('paste');

  EventListenerList get readyStateChange() => _get('readystatechange');

  EventListenerList get reset() => _get('reset');

  EventListenerList get scroll() => _get('scroll');

  EventListenerList get search() => _get('search');

  EventListenerList get select() => _get('select');

  EventListenerList get selectStart() => _get('selectstart');

  EventListenerList get selectionChange() => _get('selectionchange');

  EventListenerList get submit() => _get('submit');

  EventListenerList get touchCancel() => _get('touchcancel');

  EventListenerList get touchEnd() => _get('touchend');

  EventListenerList get touchMove() => _get('touchmove');

  EventListenerList get touchStart() => _get('touchstart');
}
// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

class FilteredElementList implements ElementList {
  final Node _node;
  final NodeList _childNodes;

  FilteredElementList(Node node): _childNodes = node.nodes, _node = node;

  // We can't memoize this, since it's possible that children will be messed
  // with externally to this class.
  //
  // TODO(nweiz): Do we really need to copy the list to make the types work out?
  List<Element> get _filtered() =>
    new List.from(_childNodes.filter((n) => n is Element));

  // Don't use _filtered.first so we can short-circuit once we find an element.
  Element get first() {
    for (final node in _childNodes) {
      if (node is Element) {
        return node;
      }
    }
    return null;
  }

  void forEach(void f(Element element)) {
    _filtered.forEach(f);
  }

  void operator []=(int index, Element value) {
    this[index].replaceWith(value);
  }

  void set length(int newLength) {
    final len = this.length;
    if (newLength >= len) {
      return;
    } else if (newLength < 0) {
      throw const IllegalArgumentException("Invalid list length");
    }

    removeRange(newLength - 1, len - newLength);
  }

  void add(Element value) {
    _childNodes.add(value);
  }

  void addAll(Collection<Element> collection) {
    collection.forEach(add);
  }

  void addLast(Element value) {
    add(value);
  }

  void sort(int compare(Element a, Element b)) {
    throw const UnsupportedOperationException('TODO(jacobr): should we impl?');
  }

  void copyFrom(List<Object> src, int srcStart, int dstStart, int count) {
    throw const NotImplementedException();
  }

  void setRange(int start, int length, List from, [int startFrom = 0]) {
    throw const NotImplementedException();
  }

  void removeRange(int start, int length) {
    _filtered.getRange(start, length).forEach((el) => el.remove());
  }

  void insertRange(int start, int length, [initialValue = null]) {
    throw const NotImplementedException();
  }

  void clear() {
    // Currently, ElementList#clear clears even non-element nodes, so we follow
    // that behavior.
    _childNodes.clear();
  }

  Element removeLast() {
    final last = this.last();
    if (last != null) {
      last.remove();
    }
    return last;
  }

  Collection map(f(Element element)) => _filtered.map(f);
  Collection<Element> filter(bool f(Element element)) => _filtered.filter(f);
  bool every(bool f(Element element)) => _filtered.every(f);
  bool some(bool f(Element element)) => _filtered.some(f);
  bool isEmpty() => _filtered.isEmpty();
  int get length() => _filtered.length;
  Element operator [](int index) => _filtered[index];
  Iterator<Element> iterator() => _filtered.iterator();
  List<Element> getRange(int start, int length) =>
    _filtered.getRange(start, length);
  int indexOf(Element element, [int start = 0]) =>
    _filtered.indexOf(element, start);

  int lastIndexOf(Element element, [int start = null]) {
    if (start === null) start = length - 1;
    return _filtered.lastIndexOf(element, start);
  }

  Element last() => _filtered.last();
}

Future<CSSStyleDeclaration> _emptyStyleFuture() {
  return _createMeasurementFuture(() => new Element.tag('div').style,
                                  new Completer<CSSStyleDeclaration>());
}

class EmptyElementRect implements ElementRect {
  final ClientRect client = const _SimpleClientRect(0, 0, 0, 0);
  final ClientRect offset = const _SimpleClientRect(0, 0, 0, 0);
  final ClientRect scroll = const _SimpleClientRect(0, 0, 0, 0);
  final ClientRect bounding = const _SimpleClientRect(0, 0, 0, 0);
  final List<ClientRect> clientRects = const <ClientRect>[];

  const EmptyElementRect();
}

class _DocumentFragmentImpl extends _NodeImpl implements DocumentFragment {
  ElementList _elements;

  ElementList get elements() {
    if (_elements == null) {
      _elements = new FilteredElementList(this);
    }
    return _elements;
  }

  // TODO: The type of value should be Collection<Element>. See http://b/5392897
  void set elements(value) {
    // Copy list first since we don't want liveness during iteration.
    List copy = new List.from(value);
    final elements = this.elements;
    elements.clear();
    elements.addAll(copy);
  }

  ElementList queryAll(String selectors) =>
    new _FrozenElementList._wrap(_querySelectorAll(selectors));

  String get innerHTML() {
    final e = new Element.tag("div");
    e.nodes.add(this.clone(true));
    return e.innerHTML;
  }

  String get outerHTML() => innerHTML;

  // TODO(nweiz): Do we want to support some variant of innerHTML for XML and/or
  // SVG strings?
  void set innerHTML(String value) {
    this.nodes.clear();

    final e = new Element.tag("div");
    e.innerHTML = value;

    // Copy list first since we don't want liveness during iteration.
    List nodes = new List.from(e.nodes);
    this.nodes.addAll(nodes);
  }

  Node _insertAdjacentNode(String where, Node node) {
    switch (where.toLowerCase()) {
      case "beforebegin": return null;
      case "afterend": return null;
      case "afterbegin":
        this.insertBefore(node, this.nodes.first);
        return node;
      case "beforeend":
        this.nodes.add(node);
        return node;
      default:
        throw new IllegalArgumentException("Invalid position ${where}");
    }
  }

  Element insertAdjacentElement(String where, Element element)
    => this._insertAdjacentNode(where, element);

  void insertAdjacentText(String where, String text) {
    this._insertAdjacentNode(where, new Text(text));
  }

  void insertAdjacentHTML(String where, String text) {
    this._insertAdjacentNode(where, new DocumentFragment.html(text));
  }

  Future<ElementRect> get rect() {
    return _createMeasurementFuture(() => const EmptyElementRect(),
                                    new Completer<ElementRect>());
  }

  // If we can come up with a semi-reasonable default value for an Element
  // getter, we'll use it. In general, these return the same values as an
  // element that has no parent.
  String get contentEditable() => "false";
  bool get isContentEditable() => false;
  bool get draggable() => false;
  bool get hidden() => false;
  bool get spellcheck() => false;
  bool get translate() => false;
  int get tabIndex() => -1;
  String get id() => "";
  String get title() => "";
  String get tagName() => "";
  String get webkitdropzone() => "";
  String get webkitRegionOverflow() => "";
  Element get firstElementChild() => elements.first();
  Element get lastElementChild() => elements.last();
  Element get nextElementSibling() => null;
  Element get previousElementSibling() => null;
  Element get offsetParent() => null;
  Element get parent() => null;
  Map<String, String> get attributes() => const {};
  // Issue 174: this should be a const set.
  Set<String> get classes() => new Set<String>();
  Map<String, String> get dataAttributes() => const {};
  CSSStyleDeclaration get style() => new Element.tag('div').style;
  Future<CSSStyleDeclaration> get computedStyle() =>
      _emptyStyleFuture();
  Future<CSSStyleDeclaration> getComputedStyle(String pseudoElement) =>
      _emptyStyleFuture();
  bool matchesSelector(String selectors) => false;

  // Imperative Element methods are made into no-ops, as they are on parentless
  // elements.
  void blur() {}
  void focus() {}
  void click() {}
  void scrollByLines(int lines) {}
  void scrollByPages(int pages) {}
  void scrollIntoView([bool centerIfNeeded]) {}
  void webkitRequestFullScreen(int flags) {}
  void webkitRequestFullscreen() {}

  // Setters throw errors rather than being no-ops because we aren't going to
  // retain the values that were set, and erroring out seems clearer.
  void set attributes(Map<String, String> value) {
    throw new UnsupportedOperationException(
      "Attributes can't be set for document fragments.");
  }

  void set classes(Collection<String> value) {
    throw new UnsupportedOperationException(
      "Classes can't be set for document fragments.");
  }

  void set dataAttributes(Map<String, String> value) {
    throw new UnsupportedOperationException(
      "Data attributes can't be set for document fragments.");
  }

  void set contentEditable(String value) {
    throw new UnsupportedOperationException(
      "Content editable can't be set for document fragments.");
  }

  String get dir() {
    throw new UnsupportedOperationException(
      "Document fragments don't support text direction.");
  }

  void set dir(String value) {
    throw new UnsupportedOperationException(
      "Document fragments don't support text direction.");
  }

  void set draggable(bool value) {
    throw new UnsupportedOperationException(
      "Draggable can't be set for document fragments.");
  }

  void set hidden(bool value) {
    throw new UnsupportedOperationException(
      "Hidden can't be set for document fragments.");
  }

  void set id(String value) {
    throw new UnsupportedOperationException(
      "ID can't be set for document fragments.");
  }

  String get lang() {
    throw new UnsupportedOperationException(
      "Document fragments don't support language.");
  }

  void set lang(String value) {
    throw new UnsupportedOperationException(
      "Document fragments don't support language.");
  }

  void set scrollLeft(int value) {
    throw new UnsupportedOperationException(
      "Document fragments don't support scrolling.");
  }

  void set scrollTop(int value) {
    throw new UnsupportedOperationException(
      "Document fragments don't support scrolling.");
  }

  void set spellcheck(bool value) {
     throw new UnsupportedOperationException(
      "Spellcheck can't be set for document fragments.");
  }

  void set translate(bool value) {
     throw new UnsupportedOperationException(
      "Spellcheck can't be set for document fragments.");
  }

  void set tabIndex(int value) {
    throw new UnsupportedOperationException(
      "Tab index can't be set for document fragments.");
  }

  void set title(String value) {
    throw new UnsupportedOperationException(
      "Title can't be set for document fragments.");
  }

  void set webkitdropzone(String value) {
    throw new UnsupportedOperationException(
      "WebKit drop zone can't be set for document fragments.");
  }

  void set webkitRegionOverflow(String value) {
    throw new UnsupportedOperationException(
      "WebKit region overflow can't be set for document fragments.");
  }

  _DocumentFragmentImpl._wrap(ptr) : super._wrap(ptr);

  _ElementEventsImpl get on() {
    if (_on == null) _on = new _ElementEventsImpl(this);
    return _on;
  }

  Element query(String selectors) {
    return _wrap(_ptr.querySelector(_unwrap(selectors)));
  }

  NodeList _querySelectorAll(String selectors) {
    return _wrap(_ptr.querySelectorAll(_unwrap(selectors)));
  }

}

class _DocumentTypeImpl extends _NodeImpl implements DocumentType {
  _DocumentTypeImpl._wrap(ptr) : super._wrap(ptr);

  NamedNodeMap get entities() => _wrap(_ptr.entities);

  String get internalSubset() => _wrap(_ptr.internalSubset);

  String get name() => _wrap(_ptr.name);

  NamedNodeMap get notations() => _wrap(_ptr.notations);

  String get publicId() => _wrap(_ptr.publicId);

  String get systemId() => _wrap(_ptr.systemId);
}

class _DynamicsCompressorNodeImpl extends _AudioNodeImpl implements DynamicsCompressorNode {
  _DynamicsCompressorNodeImpl._wrap(ptr) : super._wrap(ptr);

  AudioParam get knee() => _wrap(_ptr.knee);

  AudioParam get ratio() => _wrap(_ptr.ratio);

  AudioParam get reduction() => _wrap(_ptr.reduction);

  AudioParam get threshold() => _wrap(_ptr.threshold);
}

class _EXTTextureFilterAnisotropicImpl extends _DOMTypeBase implements EXTTextureFilterAnisotropic {
  _EXTTextureFilterAnisotropicImpl._wrap(ptr) : super._wrap(ptr);
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// TODO(jacobr): use _Lists.dart to remove some of the duplicated
// functionality.
class _ChildrenElementList implements ElementList {
  // Raw Element.
  final _ElementImpl _element;
  final _HTMLCollectionImpl _childElements;

  _ChildrenElementList._wrap(_ElementImpl element)
    : _childElements = element._children,
      _element = element;

  List<Element> _toList() {
    final output = new List(_childElements.length);
    for (int i = 0, len = _childElements.length; i < len; i++) {
      output[i] = _childElements[i];
    }
    return output;
  }

  _ElementImpl get first() {
    return _element._firstElementChild;
  }

  void forEach(void f(Element element)) {
    for (_ElementImpl element in _childElements) {
      f(element);
    }
  }

  ElementList filter(bool f(Element element)) {
    final output = <Element>[];
    forEach((Element element) {
      if (f(element)) {
        output.add(element);
      }
    });
    return new _FrozenElementList._wrap(output);
  }

  bool every(bool f(Element element)) {
    for(Element element in this) {
      if (!f(element)) {
        return false;
      }
    };
    return true;
  }

  bool some(bool f(Element element)) {
    for(Element element in this) {
      if (f(element)) {
        return true;
      }
    };
    return false;
  }

  Collection map(f(Element element)) {
    final out = [];
    for (Element el in this) {
      out.add(f(el));
    }
    return out;
  }

  bool isEmpty() {
    return _element._firstElementChild == null;
  }

  int get length() {
    return _childElements.length;
  }

  _ElementImpl operator [](int index) {
    return _childElements[index];
  }

  void operator []=(int index, _ElementImpl value) {
    _element._replaceChild(value, _childElements[index]);
  }

   void set length(int newLength) {
     // TODO(jacobr): remove children when length is reduced.
     throw const UnsupportedOperationException('');
   }

  Element add(_ElementImpl value) {
    _element._appendChild(value);
    return value;
  }

  Element addLast(_ElementImpl value) => add(value);

  Iterator<Element> iterator() => _toList().iterator();

  void addAll(Collection<Element> collection) {
    for (_ElementImpl element in collection) {
      _element._appendChild(element);
    }
  }

  void sort(int compare(Element a, Element b)) {
    throw const UnsupportedOperationException('TODO(jacobr): should we impl?');
  }

  void copyFrom(List<Object> src, int srcStart, int dstStart, int count) {
    throw 'Not impl yet. todo(jacobr)';
  }

  void setRange(int start, int length, List from, [int startFrom = 0]) {
    throw const NotImplementedException();
  }

  void removeRange(int start, int length) {
    throw const NotImplementedException();
  }

  void insertRange(int start, int length, [initialValue = null]) {
    throw const NotImplementedException();
  }

  List getRange(int start, int length) =>
    new _FrozenElementList._wrap(_Lists.getRange(this, start, length,
        <Element>[]));

  int indexOf(Element element, [int start = 0]) {
    return _Lists.indexOf(this, element, start, this.length);
  }

  int lastIndexOf(Element element, [int start = null]) {
    if (start === null) start = length - 1;
    return _Lists.lastIndexOf(this, element, start);
  }

  void clear() {
    // It is unclear if we want to keep non element nodes?
    _element.text = '';
  }

  Element removeLast() {
    final last = this.last();
    if (last != null) {
      _element._removeChild(last);
    }
    return last;
  }

  Element last() {
    return _element.lastElementChild;
  }
}

// TODO(jacobr): this is an inefficient implementation but it is hard to see
// a better option given that we cannot quite force NodeList to be an
// ElementList as there are valid cases where a NodeList JavaScript object
// contains Node objects that are not Elements.
class _FrozenElementList implements ElementList {
  final List<Node> _nodeList;

  _FrozenElementList._wrap(this._nodeList);

  Element get first() {
    return _nodeList[0];
  }

  void forEach(void f(Element element)) {
    for (Element el in this) {
      f(el);
    }
  }

  Collection map(f(Element element)) {
    final out = [];
    for (Element el in this) {
      out.add(f(el));
    }
    return out;
  }

  ElementList filter(bool f(Element element)) {
    final out = new _ElementList([]);
    for (Element el in this) {
      if (f(el)) out.add(el);
    }
    return out;
  }

  bool every(bool f(Element element)) {
    for(Element element in this) {
      if (!f(element)) {
        return false;
      }
    };
    return true;
  }

  bool some(bool f(Element element)) {
    for(Element element in this) {
      if (f(element)) {
        return true;
      }
    };
    return false;
  }

  bool isEmpty() => _nodeList.isEmpty();

  int get length() => _nodeList.length;

  Element operator [](int index) => _nodeList[index];

  void operator []=(int index, Element value) {
    throw const UnsupportedOperationException('');
  }

  void set length(int newLength) {
    _nodeList.length = newLength;
  }

  void add(Element value) {
    throw const UnsupportedOperationException('');
  }

  void addLast(Element value) {
    throw const UnsupportedOperationException('');
  }

  Iterator<Element> iterator() => new _FrozenElementListIterator(this);

  void addAll(Collection<Element> collection) {
    throw const UnsupportedOperationException('');
  }

  void sort(int compare(Element a, Element b)) {
    throw const UnsupportedOperationException('');
  }

  void setRange(int start, int length, List from, [int startFrom = 0]) {
    throw const UnsupportedOperationException('');
  }

  void removeRange(int start, int length) {
    throw const UnsupportedOperationException('');
  }

  void insertRange(int start, int length, [initialValue = null]) {
    throw const UnsupportedOperationException('');
  }

  ElementList getRange(int start, int length) =>
    new _FrozenElementList._wrap(_nodeList.getRange(start, length));

  int indexOf(Element element, [int start = 0]) =>
    _nodeList.indexOf(element, start);

  int lastIndexOf(Element element, [int start = null]) =>
    _nodeList.lastIndexOf(element, start);

  void clear() {
    throw const UnsupportedOperationException('');
  }

  Element removeLast() {
    throw const UnsupportedOperationException('');
  }

  Element last() => _nodeList.last();
}

class _FrozenElementListIterator implements Iterator<Element> {
  final _FrozenElementList _list;
  int _index = 0;

  _FrozenElementListIterator(this._list);

  /**
   * Gets the next element in the iteration. Throws a
   * [NoMoreElementsException] if no element is left.
   */
  Element next() {
    if (!hasNext()) {
      throw const NoMoreElementsException();
    }

    return _list[_index++];
  }

  /**
   * Returns whether the [Iterator] has elements left.
   */
  bool hasNext() => _index < _list.length;
}

class _ElementList extends _ListWrapper<Element> implements ElementList {
  _ElementList(List<Element> list) : super(list);

  ElementList filter(bool f(Element element)) =>
    new _ElementList(super.filter(f));

  ElementList getRange(int start, int length) =>
    new _ElementList(super.getRange(start, length));
}

class ElementAttributeMap implements Map<String, String> {

  final _ElementImpl _element;

  ElementAttributeMap._wrap(this._element);

  bool containsValue(String value) {
    final attributes = _element._attributes;
    for (int i = 0, len = attributes.length; i < len; i++) {
      if(value == attributes[i].value) {
        return true;
      }
    }
    return false;
  }

  bool containsKey(String key) {
    return _element._hasAttribute(key);
  }

  String operator [](String key) {
    return _element._getAttribute(key);
  }

  void operator []=(String key, String value) {
    _element._setAttribute(key, value);
  }

  String putIfAbsent(String key, String ifAbsent()) {
    if (!containsKey(key)) {
      this[key] = ifAbsent();
    }
  }

  String remove(String key) {
    _element._removeAttribute(key);
  }

  void clear() {
    final attributes = _element._attributes;
    for (int i = attributes.length - 1; i >= 0; i--) {
      remove(attributes[i].name);
    }
  }

  void forEach(void f(String key, String value)) {
    final attributes = _element._attributes;
    for (int i = 0, len = attributes.length; i < len; i++) {
      final item = attributes[i];
      f(item.name, item.value);
    }
  }

  Collection<String> getKeys() {
    // TODO(jacobr): generate a lazy collection instead.
    final attributes = _element._attributes;
    final keys = new List<String>(attributes.length);
    for (int i = 0, len = attributes.length; i < len; i++) {
      keys[i] = attributes[i].name;
    }
    return keys;
  }

  Collection<String> getValues() {
    // TODO(jacobr): generate a lazy collection instead.
    final attributes = _element._attributes;
    final values = new List<String>(attributes.length);
    for (int i = 0, len = attributes.length; i < len; i++) {
      values[i] = attributes[i].value;
    }
    return values;
  }

  /**
   * The number of {key, value} pairs in the map.
   */
  int get length() {
    return _element._attributes.length;
  }

  /**
   * Returns true if there is no {key, value} pair in the map.
   */
  bool isEmpty() {
    return length == 0;
  }
}

class _SimpleClientRect implements ClientRect {
  final num left;
  final num top;
  final num width;
  final num height;
  num get right() => left + width;
  num get bottom() => top + height;

  const _SimpleClientRect(this.left, this.top, this.width, this.height);

  bool operator ==(ClientRect other) {
    return other !== null && left == other.left && top == other.top
        && width == other.width && height == other.height;
  }

  String toString() => "($left, $top, $width, $height)";
}

// TODO(jacobr): we cannot currently be lazy about calculating the client
// rects as we must perform all measurement queries at a safe point to avoid
// triggering unneeded layouts.
/**
 * All your element measurement needs in one place
 * @domName none
 */
class _ElementRectImpl implements ElementRect {
  final ClientRect client;
  final ClientRect offset;
  final ClientRect scroll;

  // TODO(jacobr): should we move these outside of ElementRect to avoid the
  // overhead of computing them every time even though they are rarely used.
  final _ClientRectImpl _boundingClientRect; 
  final _ClientRectListImpl _clientRects;

  _ElementRectImpl(_ElementImpl element) :
    client = new _SimpleClientRect(element._clientLeft,
                                  element._clientTop,
                                  element._clientWidth, 
                                  element._clientHeight), 
    offset = new _SimpleClientRect(element._offsetLeft,
                                  element._offsetTop,
                                  element._offsetWidth,
                                  element._offsetHeight),
    scroll = new _SimpleClientRect(element._scrollLeft,
                                  element._scrollTop,
                                  element._scrollWidth,
                                  element._scrollHeight),
    _boundingClientRect = element._getBoundingClientRect(),
    _clientRects = element._getClientRects();

  _ClientRectImpl get bounding() => _boundingClientRect;

  // TODO(jacobr): cleanup.
  List<ClientRect> get clientRects() {
    final out = new List(_clientRects.length);
    for (num i = 0; i < _clientRects.length; i++) {
      out[i] = _clientRects.item(i);
    }
    return out;
  }
}

class _ElementImpl extends _NodeImpl implements Element {

  // TODO(jacobr): caching these may hurt performance.
  ElementAttributeMap _elementAttributeMap;
  _CssClassSet _cssClassSet;
  _DataAttributeMap _dataAttributes;

  /**
   * @domName Element.hasAttribute, Element.getAttribute, Element.setAttribute,
   *   Element.removeAttribute
   */
  Map<String, String> get attributes() {
    if (_elementAttributeMap === null) {
      _elementAttributeMap = new ElementAttributeMap._wrap(this);
    }
    return _elementAttributeMap;
  }

  void set attributes(Map<String, String> value) {
    Map<String, String> attributes = this.attributes;
    attributes.clear();
    for (String key in value.getKeys()) {
      attributes[key] = value[key];
    }
  }

  void set elements(Collection<Element> value) {
    final elements = this.elements;
    elements.clear();
    elements.addAll(value);
  }

  ElementList get elements() => new _ChildrenElementList._wrap(this);

  ElementList queryAll(String selectors) =>
    new _FrozenElementList._wrap(_querySelectorAll(selectors));

  Set<String> get classes() {
    if (_cssClassSet === null) {
      _cssClassSet = new _CssClassSet(this);
    }
    return _cssClassSet;
  }

  void set classes(Collection<String> value) {
    _CssClassSet classSet = classes;
    classSet.clear();
    classSet.addAll(value);
  }

  Map<String, String> get dataAttributes() {
    if (_dataAttributes === null) {
      _dataAttributes = new _DataAttributeMap(attributes);
    }
    return _dataAttributes;
  }

  void set dataAttributes(Map<String, String> value) {
    Map<String, String> dataAttributes = this.dataAttributes;
    dataAttributes.clear();
    for (String key in value.getKeys()) {
      dataAttributes[key] = value[key];
    }
  }

  Future<ElementRect> get rect() {
    return _createMeasurementFuture(
        () => new _ElementRectImpl(this),
        new Completer<ElementRect>());
  }

  Future<CSSStyleDeclaration> get computedStyle() {
     // TODO(jacobr): last param should be null, see b/5045788
     return getComputedStyle('');
  }

  Future<CSSStyleDeclaration> getComputedStyle(String pseudoElement) {
    return _createMeasurementFuture(
        () => _window._getComputedStyle(this, pseudoElement),
        new Completer<CSSStyleDeclaration>());
  }
  _ElementImpl._wrap(ptr) : super._wrap(ptr);

  _ElementEventsImpl get on() {
    if (_on == null) _on = new _ElementEventsImpl(this);
    return _on;
  }

  int get _childElementCount() => _wrap(_ptr.childElementCount);

  HTMLCollection get _children() => _wrap(_ptr.children);

  String get _className() => _wrap(_ptr.className);

  void set _className(String value) { _ptr.className = _unwrap(value); }

  int get _clientHeight() => _wrap(_ptr.clientHeight);

  int get _clientLeft() => _wrap(_ptr.clientLeft);

  int get _clientTop() => _wrap(_ptr.clientTop);

  int get _clientWidth() => _wrap(_ptr.clientWidth);

  String get contentEditable() => _wrap(_ptr.contentEditable);

  void set contentEditable(String value) { _ptr.contentEditable = _unwrap(value); }

  String get dir() => _wrap(_ptr.dir);

  void set dir(String value) { _ptr.dir = _unwrap(value); }

  bool get draggable() => _wrap(_ptr.draggable);

  void set draggable(bool value) { _ptr.draggable = _unwrap(value); }

  Element get _firstElementChild() => _wrap(_ptr.firstElementChild);

  bool get hidden() => _wrap(_ptr.hidden);

  void set hidden(bool value) { _ptr.hidden = _unwrap(value); }

  String get id() => _wrap(_ptr.id);

  void set id(String value) { _ptr.id = _unwrap(value); }

  String get innerHTML() => _wrap(_ptr.innerHTML);

  void set innerHTML(String value) { _ptr.innerHTML = _unwrap(value); }

  bool get isContentEditable() => _wrap(_ptr.isContentEditable);

  String get lang() => _wrap(_ptr.lang);

  void set lang(String value) { _ptr.lang = _unwrap(value); }

  Element get lastElementChild() => _wrap(_ptr.lastElementChild);

  Element get nextElementSibling() => _wrap(_ptr.nextElementSibling);

  int get _offsetHeight() => _wrap(_ptr.offsetHeight);

  int get _offsetLeft() => _wrap(_ptr.offsetLeft);

  Element get offsetParent() => _wrap(_ptr.offsetParent);

  int get _offsetTop() => _wrap(_ptr.offsetTop);

  int get _offsetWidth() => _wrap(_ptr.offsetWidth);

  String get outerHTML() => _wrap(_ptr.outerHTML);

  Element get previousElementSibling() => _wrap(_ptr.previousElementSibling);

  int get _scrollHeight() => _wrap(_ptr.scrollHeight);

  int get _scrollLeft() => _wrap(_ptr.scrollLeft);

  void set _scrollLeft(int value) { _ptr.scrollLeft = _unwrap(value); }

  int get _scrollTop() => _wrap(_ptr.scrollTop);

  void set _scrollTop(int value) { _ptr.scrollTop = _unwrap(value); }

  int get _scrollWidth() => _wrap(_ptr.scrollWidth);

  bool get spellcheck() => _wrap(_ptr.spellcheck);

  void set spellcheck(bool value) { _ptr.spellcheck = _unwrap(value); }

  CSSStyleDeclaration get style() => _wrap(_ptr.style);

  int get tabIndex() => _wrap(_ptr.tabIndex);

  void set tabIndex(int value) { _ptr.tabIndex = _unwrap(value); }

  String get tagName() => _wrap(_ptr.tagName);

  String get title() => _wrap(_ptr.title);

  void set title(String value) { _ptr.title = _unwrap(value); }

  bool get translate() => _wrap(_ptr.translate);

  void set translate(bool value) { _ptr.translate = _unwrap(value); }

  String get webkitRegionOverflow() => _wrap(_ptr.webkitRegionOverflow);

  String get webkitdropzone() => _wrap(_ptr.webkitdropzone);

  void set webkitdropzone(String value) { _ptr.webkitdropzone = _unwrap(value); }

  void blur() {
    _ptr.blur();
    return;
  }

  void click() {
    _ptr.click();
    return;
  }

  void focus() {
    _ptr.focus();
    return;
  }

  String _getAttribute(String name) {
    return _wrap(_ptr.getAttribute(_unwrap(name)));
  }

  ClientRect _getBoundingClientRect() {
    return _wrap(_ptr.getBoundingClientRect());
  }

  ClientRectList _getClientRects() {
    return _wrap(_ptr.getClientRects());
  }

  bool _hasAttribute(String name) {
    return _wrap(_ptr.hasAttribute(_unwrap(name)));
  }

  Element insertAdjacentElement(String where, Element element) {
    return _wrap(_ptr.insertAdjacentElement(_unwrap(where), _unwrap(element)));
  }

  void insertAdjacentHTML(String where, String html) {
    _ptr.insertAdjacentHTML(_unwrap(where), _unwrap(html));
    return;
  }

  void insertAdjacentText(String where, String text) {
    _ptr.insertAdjacentText(_unwrap(where), _unwrap(text));
    return;
  }

  Element query(String selectors) {
    return _wrap(_ptr.querySelector(_unwrap(selectors)));
  }

  NodeList _querySelectorAll(String selectors) {
    return _wrap(_ptr.querySelectorAll(_unwrap(selectors)));
  }

  void _removeAttribute(String name) {
    _ptr.removeAttribute(_unwrap(name));
    return;
  }

  void scrollByLines(int lines) {
    _ptr.scrollByLines(_unwrap(lines));
    return;
  }

  void scrollByPages(int pages) {
    _ptr.scrollByPages(_unwrap(pages));
    return;
  }

  void scrollIntoView([bool centerIfNeeded = null]) {
    if (centerIfNeeded === null) {
      _ptr.scrollIntoViewIfNeeded();
      return;
    } else {
      _ptr.scrollIntoViewIfNeeded(_unwrap(centerIfNeeded));
      return;
    }
  }

  void _setAttribute(String name, String value) {
    _ptr.setAttribute(_unwrap(name), _unwrap(value));
    return;
  }

  bool matchesSelector(String selectors) {
    return _wrap(_ptr.webkitMatchesSelector(_unwrap(selectors)));
  }

  void webkitRequestFullScreen(int flags) {
    _ptr.webkitRequestFullScreen(_unwrap(flags));
    return;
  }

  void webkitRequestFullscreen() {
    _ptr.webkitRequestFullscreen();
    return;
  }

}

class _ElementEventsImpl extends _EventsImpl implements ElementEvents {
  _ElementEventsImpl(_ptr) : super(_ptr);

  EventListenerList get abort() => _get('abort');

  EventListenerList get beforeCopy() => _get('beforecopy');

  EventListenerList get beforeCut() => _get('beforecut');

  EventListenerList get beforePaste() => _get('beforepaste');

  EventListenerList get blur() => _get('blur');

  EventListenerList get change() => _get('change');

  EventListenerList get click() => _get('click');

  EventListenerList get contextMenu() => _get('contextmenu');

  EventListenerList get copy() => _get('copy');

  EventListenerList get cut() => _get('cut');

  EventListenerList get doubleClick() => _get('dblclick');

  EventListenerList get drag() => _get('drag');

  EventListenerList get dragEnd() => _get('dragend');

  EventListenerList get dragEnter() => _get('dragenter');

  EventListenerList get dragLeave() => _get('dragleave');

  EventListenerList get dragOver() => _get('dragover');

  EventListenerList get dragStart() => _get('dragstart');

  EventListenerList get drop() => _get('drop');

  EventListenerList get error() => _get('error');

  EventListenerList get focus() => _get('focus');

  EventListenerList get fullscreenChange() => _get('webkitfullscreenchange');

  EventListenerList get fullscreenError() => _get('webkitfullscreenerror');

  EventListenerList get input() => _get('input');

  EventListenerList get invalid() => _get('invalid');

  EventListenerList get keyDown() => _get('keydown');

  EventListenerList get keyPress() => _get('keypress');

  EventListenerList get keyUp() => _get('keyup');

  EventListenerList get load() => _get('load');

  EventListenerList get mouseDown() => _get('mousedown');

  EventListenerList get mouseMove() => _get('mousemove');

  EventListenerList get mouseOut() => _get('mouseout');

  EventListenerList get mouseOver() => _get('mouseover');

  EventListenerList get mouseUp() => _get('mouseup');

  EventListenerList get mouseWheel() => _get('mousewheel');

  EventListenerList get paste() => _get('paste');

  EventListenerList get reset() => _get('reset');

  EventListenerList get scroll() => _get('scroll');

  EventListenerList get search() => _get('search');

  EventListenerList get select() => _get('select');

  EventListenerList get selectStart() => _get('selectstart');

  EventListenerList get submit() => _get('submit');

  EventListenerList get touchCancel() => _get('touchcancel');

  EventListenerList get touchEnd() => _get('touchend');

  EventListenerList get touchLeave() => _get('touchleave');

  EventListenerList get touchMove() => _get('touchmove');

  EventListenerList get touchStart() => _get('touchstart');

  EventListenerList get transitionEnd() => _get('webkitTransitionEnd');
}

class _ElementTimeControlImpl extends _DOMTypeBase implements ElementTimeControl {
  _ElementTimeControlImpl._wrap(ptr) : super._wrap(ptr);

  void beginElement() {
    _ptr.beginElement();
    return;
  }

  void beginElementAt(num offset) {
    _ptr.beginElementAt(_unwrap(offset));
    return;
  }

  void endElement() {
    _ptr.endElement();
    return;
  }

  void endElementAt(num offset) {
    _ptr.endElementAt(_unwrap(offset));
    return;
  }
}

class _ElementTraversalImpl extends _DOMTypeBase implements ElementTraversal {
  _ElementTraversalImpl._wrap(ptr) : super._wrap(ptr);

  int get childElementCount() => _wrap(_ptr.childElementCount);

  Element get firstElementChild() => _wrap(_ptr.firstElementChild);

  Element get lastElementChild() => _wrap(_ptr.lastElementChild);

  Element get nextElementSibling() => _wrap(_ptr.nextElementSibling);

  Element get previousElementSibling() => _wrap(_ptr.previousElementSibling);
}

class _EmbedElementImpl extends _ElementImpl implements EmbedElement {
  _EmbedElementImpl._wrap(ptr) : super._wrap(ptr);

  String get align() => _wrap(_ptr.align);

  void set align(String value) { _ptr.align = _unwrap(value); }

  String get height() => _wrap(_ptr.height);

  void set height(String value) { _ptr.height = _unwrap(value); }

  String get name() => _wrap(_ptr.name);

  void set name(String value) { _ptr.name = _unwrap(value); }

  String get src() => _wrap(_ptr.src);

  void set src(String value) { _ptr.src = _unwrap(value); }

  String get type() => _wrap(_ptr.type);

  void set type(String value) { _ptr.type = _unwrap(value); }

  String get width() => _wrap(_ptr.width);

  void set width(String value) { _ptr.width = _unwrap(value); }
}

class _EntityImpl extends _NodeImpl implements Entity {
  _EntityImpl._wrap(ptr) : super._wrap(ptr);

  String get notationName() => _wrap(_ptr.notationName);

  String get publicId() => _wrap(_ptr.publicId);

  String get systemId() => _wrap(_ptr.systemId);
}

class _EntityReferenceImpl extends _NodeImpl implements EntityReference {
  _EntityReferenceImpl._wrap(ptr) : super._wrap(ptr);
}

class _EntryImpl extends _DOMTypeBase implements Entry {
  _EntryImpl._wrap(ptr) : super._wrap(ptr);

  DOMFileSystem get filesystem() => _wrap(_ptr.filesystem);

  String get fullPath() => _wrap(_ptr.fullPath);

  bool get isDirectory() => _wrap(_ptr.isDirectory);

  bool get isFile() => _wrap(_ptr.isFile);

  String get name() => _wrap(_ptr.name);

  void copyTo(DirectoryEntry parent, [String name = null, EntryCallback successCallback = null, ErrorCallback errorCallback = null]) {
    if (name === null) {
      if (successCallback === null) {
        if (errorCallback === null) {
          _ptr.copyTo(_unwrap(parent));
          return;
        }
      }
    } else {
      if (successCallback === null) {
        if (errorCallback === null) {
          _ptr.copyTo(_unwrap(parent), _unwrap(name));
          return;
        }
      } else {
        if (errorCallback === null) {
          _ptr.copyTo(_unwrap(parent), _unwrap(name), _unwrap(successCallback));
          return;
        } else {
          _ptr.copyTo(_unwrap(parent), _unwrap(name), _unwrap(successCallback), _unwrap(errorCallback));
          return;
        }
      }
    }
    throw "Incorrect number or type of arguments";
  }

  void getMetadata(MetadataCallback successCallback, [ErrorCallback errorCallback = null]) {
    if (errorCallback === null) {
      _ptr.getMetadata(_unwrap(successCallback));
      return;
    } else {
      _ptr.getMetadata(_unwrap(successCallback), _unwrap(errorCallback));
      return;
    }
  }

  void getParent([EntryCallback successCallback = null, ErrorCallback errorCallback = null]) {
    if (successCallback === null) {
      if (errorCallback === null) {
        _ptr.getParent();
        return;
      }
    } else {
      if (errorCallback === null) {
        _ptr.getParent(_unwrap(successCallback));
        return;
      } else {
        _ptr.getParent(_unwrap(successCallback), _unwrap(errorCallback));
        return;
      }
    }
    throw "Incorrect number or type of arguments";
  }

  void moveTo(DirectoryEntry parent, [String name = null, EntryCallback successCallback = null, ErrorCallback errorCallback = null]) {
    if (name === null) {
      if (successCallback === null) {
        if (errorCallback === null) {
          _ptr.moveTo(_unwrap(parent));
          return;
        }
      }
    } else {
      if (successCallback === null) {
        if (errorCallback === null) {
          _ptr.moveTo(_unwrap(parent), _unwrap(name));
          return;
        }
      } else {
        if (errorCallback === null) {
          _ptr.moveTo(_unwrap(parent), _unwrap(name), _unwrap(successCallback));
          return;
        } else {
          _ptr.moveTo(_unwrap(parent), _unwrap(name), _unwrap(successCallback), _unwrap(errorCallback));
          return;
        }
      }
    }
    throw "Incorrect number or type of arguments";
  }

  void remove(VoidCallback successCallback, [ErrorCallback errorCallback = null]) {
    if (errorCallback === null) {
      _ptr.remove(_unwrap(successCallback));
      return;
    } else {
      _ptr.remove(_unwrap(successCallback), _unwrap(errorCallback));
      return;
    }
  }

  String toURL() {
    return _wrap(_ptr.toURL());
  }
}

class _EntryArrayImpl extends _DOMTypeBase implements EntryArray {
  _EntryArrayImpl._wrap(ptr) : super._wrap(ptr);

  int get length() => _wrap(_ptr.length);

  Entry item(int index) {
    return _wrap(_ptr.item(_unwrap(index)));
  }
}

class _EntryArraySyncImpl extends _DOMTypeBase implements EntryArraySync {
  _EntryArraySyncImpl._wrap(ptr) : super._wrap(ptr);

  int get length() => _wrap(_ptr.length);

  EntrySync item(int index) {
    return _wrap(_ptr.item(_unwrap(index)));
  }
}

class _EntrySyncImpl extends _DOMTypeBase implements EntrySync {
  _EntrySyncImpl._wrap(ptr) : super._wrap(ptr);

  DOMFileSystemSync get filesystem() => _wrap(_ptr.filesystem);

  String get fullPath() => _wrap(_ptr.fullPath);

  bool get isDirectory() => _wrap(_ptr.isDirectory);

  bool get isFile() => _wrap(_ptr.isFile);

  String get name() => _wrap(_ptr.name);

  EntrySync copyTo(DirectoryEntrySync parent, String name) {
    return _wrap(_ptr.copyTo(_unwrap(parent), _unwrap(name)));
  }

  Metadata getMetadata() {
    return _wrap(_ptr.getMetadata());
  }

  DirectoryEntrySync getParent() {
    return _wrap(_ptr.getParent());
  }

  EntrySync moveTo(DirectoryEntrySync parent, String name) {
    return _wrap(_ptr.moveTo(_unwrap(parent), _unwrap(name)));
  }

  void remove() {
    _ptr.remove();
    return;
  }

  String toURL() {
    return _wrap(_ptr.toURL());
  }
}

class _ErrorEventImpl extends _EventImpl implements ErrorEvent {
  _ErrorEventImpl._wrap(ptr) : super._wrap(ptr);

  String get filename() => _wrap(_ptr.filename);

  int get lineno() => _wrap(_ptr.lineno);

  String get message() => _wrap(_ptr.message);
}

class _EventImpl extends _DOMTypeBase implements Event {
  _EventImpl._wrap(ptr) : super._wrap(ptr);

  bool get bubbles() => _wrap(_ptr.bubbles);

  bool get cancelBubble() => _wrap(_ptr.cancelBubble);

  void set cancelBubble(bool value) { _ptr.cancelBubble = _unwrap(value); }

  bool get cancelable() => _wrap(_ptr.cancelable);

  Clipboard get clipboardData() => _wrap(_ptr.clipboardData);

  EventTarget get currentTarget() => _FixHtmlDocumentReference(_wrap(_ptr.currentTarget));

  bool get defaultPrevented() => _wrap(_ptr.defaultPrevented);

  int get eventPhase() => _wrap(_ptr.eventPhase);

  bool get returnValue() => _wrap(_ptr.returnValue);

  void set returnValue(bool value) { _ptr.returnValue = _unwrap(value); }

  EventTarget get srcElement() => _FixHtmlDocumentReference(_wrap(_ptr.srcElement));

  EventTarget get target() => _FixHtmlDocumentReference(_wrap(_ptr.target));

  int get timeStamp() => _wrap(_ptr.timeStamp);

  String get type() => _wrap(_ptr.type);

  void _initEvent(String eventTypeArg, bool canBubbleArg, bool cancelableArg) {
    _ptr.initEvent(_unwrap(eventTypeArg), _unwrap(canBubbleArg), _unwrap(cancelableArg));
    return;
  }

  void preventDefault() {
    _ptr.preventDefault();
    return;
  }

  void stopImmediatePropagation() {
    _ptr.stopImmediatePropagation();
    return;
  }

  void stopPropagation() {
    _ptr.stopPropagation();
    return;
  }
}

class _EventExceptionImpl extends _DOMTypeBase implements EventException {
  _EventExceptionImpl._wrap(ptr) : super._wrap(ptr);

  int get code() => _wrap(_ptr.code);

  String get message() => _wrap(_ptr.message);

  String get name() => _wrap(_ptr.name);

  String toString() {
    return _wrap(_ptr.toString());
  }
}

class _EventSourceImpl extends _EventTargetImpl implements EventSource {
  _EventSourceImpl._wrap(ptr) : super._wrap(ptr);

  _EventSourceEventsImpl get on() {
    if (_on == null) _on = new _EventSourceEventsImpl(this);
    return _on;
  }

  String get URL() => _wrap(_ptr.URL);

  int get readyState() => _wrap(_ptr.readyState);

  String get url() => _wrap(_ptr.url);

  void _addEventListener(String type, EventListener listener, [bool useCapture = null]) {
    if (useCapture === null) {
      _ptr.addEventListener(_unwrap(type), _unwrap(listener));
      return;
    } else {
      _ptr.addEventListener(_unwrap(type), _unwrap(listener), _unwrap(useCapture));
      return;
    }
  }

  void close() {
    _ptr.close();
    return;
  }

  bool _dispatchEvent(Event evt) {
    return _wrap(_ptr.dispatchEvent(_unwrap(evt)));
  }

  void _removeEventListener(String type, EventListener listener, [bool useCapture = null]) {
    if (useCapture === null) {
      _ptr.removeEventListener(_unwrap(type), _unwrap(listener));
      return;
    } else {
      _ptr.removeEventListener(_unwrap(type), _unwrap(listener), _unwrap(useCapture));
      return;
    }
  }
}

class _EventSourceEventsImpl extends _EventsImpl implements EventSourceEvents {
  _EventSourceEventsImpl(_ptr) : super(_ptr);

  EventListenerList get error() => _get('error');

  EventListenerList get message() => _get('message');

  EventListenerList get open() => _get('open');
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

class _EventsImpl implements Events {

  final _EventTargetImpl _ptr;

  final Map<String, EventListenerList> _listenerMap;

  _EventsImpl(this._ptr) : _listenerMap = <EventListenerList>{};

  EventListenerList operator [](String type) {
    return _get(type.toLowerCase());
  }
  
  EventListenerList _get(String type) {
    return _listenerMap.putIfAbsent(type,
      () => new _EventListenerListImpl(_ptr, type));
  }
}

class _EventListenerWrapper {
  final EventListener raw;
  final Function wrapped;
  final bool useCapture;
  _EventListenerWrapper(this.raw, this.wrapped, this.useCapture);
}

class _EventListenerListImpl implements EventListenerList {
  final _EventTargetImpl _ptr;
  final String _type;
  List<_EventListenerWrapper> _wrappers;

  _EventListenerListImpl(this._ptr, this._type) :
    // TODO(jacobr): switch to <_EventListenerWrapper>[] when the VM allow it.
    _wrappers = new List<_EventListenerWrapper>();

  EventListenerList add(EventListener listener, [bool useCapture = false]) {
    _add(listener, useCapture);
    return this;
  }

  EventListenerList remove(EventListener listener, [bool useCapture = false]) {
    _remove(listener, useCapture);
    return this;
  }

  bool dispatch(Event evt) {
    // TODO(jacobr): what is the correct behavior here. We could alternately
    // force the event to have the expected type.
    assert(evt.type == _type);
    return _ptr._dispatchEvent(evt);
  }

  void _add(EventListener listener, bool useCapture) {
    _ptr._addEventListener(_type,
                          _findOrAddWrapper(listener, useCapture),
                          useCapture);
  }

  void _remove(EventListener listener, bool useCapture) {
    Function wrapper = _removeWrapper(listener, useCapture);
    if (wrapper !== null) {
      _ptr._removeEventListener(_type, wrapper, useCapture);
    }
  }

  Function _removeWrapper(EventListener listener, bool useCapture) {
    if (_wrappers === null) {
      return null;
    }
    for (int i = 0; i < _wrappers.length; i++) {
      _EventListenerWrapper wrapper = _wrappers[i];
      if (wrapper.raw === listener && wrapper.useCapture == useCapture) {
        // Order doesn't matter so we swap with the last element instead of
        // performing a more expensive remove from the middle of the list.
        if (i + 1 != _wrappers.length) {
          _wrappers[i] = _wrappers.removeLast();
        } else {
          _wrappers.removeLast();
        }
        return wrapper.wrapped;
      }
    }
    return null;
  }

  Function _findOrAddWrapper(EventListener listener, bool useCapture) {
    if (_wrappers === null) {
      _wrappers = <_EventListenerWrapper>[];
    } else {
      for (_EventListenerWrapper wrapper in _wrappers) {
        if (wrapper.raw === listener && wrapper.useCapture == useCapture) {
          return wrapper.wrapped;
        }
      }
    }
    final wrapped = (e) { listener(_wrap(e)); };
    _wrappers.add(new _EventListenerWrapper(listener, wrapped, useCapture));
    return wrapped;
  }
}

class _EventTargetImpl extends _DOMTypeBase implements EventTarget {

  Events _on;

  Events get on() {
    if (_on == null) _on = new _EventsImpl(this);
    return _on;
  }

  _EventTargetImpl._wrap(ptr) : super._wrap(ptr);

  void _addEventListener(String type, EventListener listener, [bool useCapture = null]) {
    if (useCapture === null) {
      _ptr.addEventListener(_unwrap(type), _unwrap(listener));
      return;
    } else {
      _ptr.addEventListener(_unwrap(type), _unwrap(listener), _unwrap(useCapture));
      return;
    }
  }

  bool _dispatchEvent(Event event) {
    return _wrap(_ptr.dispatchEvent(_unwrap(event)));
  }

  void _removeEventListener(String type, EventListener listener, [bool useCapture = null]) {
    if (useCapture === null) {
      _ptr.removeEventListener(_unwrap(type), _unwrap(listener));
      return;
    } else {
      _ptr.removeEventListener(_unwrap(type), _unwrap(listener), _unwrap(useCapture));
      return;
    }
  }

}

class _FieldSetElementImpl extends _ElementImpl implements FieldSetElement {
  _FieldSetElementImpl._wrap(ptr) : super._wrap(ptr);

  FormElement get form() => _wrap(_ptr.form);

  String get name() => _wrap(_ptr.name);

  void set name(String value) { _ptr.name = _unwrap(value); }

  String get type() => _wrap(_ptr.type);

  String get validationMessage() => _wrap(_ptr.validationMessage);

  ValidityState get validity() => _wrap(_ptr.validity);

  bool get willValidate() => _wrap(_ptr.willValidate);

  bool checkValidity() {
    return _wrap(_ptr.checkValidity());
  }

  void setCustomValidity(String error) {
    _ptr.setCustomValidity(_unwrap(error));
    return;
  }
}

class _FileImpl extends _BlobImpl implements File {
  _FileImpl._wrap(ptr) : super._wrap(ptr);

  Date get lastModifiedDate() => _wrap(_ptr.lastModifiedDate);

  String get name() => _wrap(_ptr.name);

  String get webkitRelativePath() => _wrap(_ptr.webkitRelativePath);
}

class _FileEntryImpl extends _EntryImpl implements FileEntry {
  _FileEntryImpl._wrap(ptr) : super._wrap(ptr);

  void createWriter(FileWriterCallback successCallback, [ErrorCallback errorCallback = null]) {
    if (errorCallback === null) {
      _ptr.createWriter(_unwrap(successCallback));
      return;
    } else {
      _ptr.createWriter(_unwrap(successCallback), _unwrap(errorCallback));
      return;
    }
  }

  void file(FileCallback successCallback, [ErrorCallback errorCallback = null]) {
    if (errorCallback === null) {
      _ptr.file(_unwrap(successCallback));
      return;
    } else {
      _ptr.file(_unwrap(successCallback), _unwrap(errorCallback));
      return;
    }
  }
}

class _FileEntrySyncImpl extends _EntrySyncImpl implements FileEntrySync {
  _FileEntrySyncImpl._wrap(ptr) : super._wrap(ptr);

  FileWriterSync createWriter() {
    return _wrap(_ptr.createWriter());
  }

  File file() {
    return _wrap(_ptr.file());
  }
}

class _FileErrorImpl extends _DOMTypeBase implements FileError {
  _FileErrorImpl._wrap(ptr) : super._wrap(ptr);

  int get code() => _wrap(_ptr.code);
}

class _FileExceptionImpl extends _DOMTypeBase implements FileException {
  _FileExceptionImpl._wrap(ptr) : super._wrap(ptr);

  int get code() => _wrap(_ptr.code);

  String get message() => _wrap(_ptr.message);

  String get name() => _wrap(_ptr.name);

  String toString() {
    return _wrap(_ptr.toString());
  }
}

class _FileListImpl extends _DOMTypeBase implements FileList {
  _FileListImpl._wrap(ptr) : super._wrap(ptr);

  int get length() => _wrap(_ptr.length);

  File item(int index) {
    return _wrap(_ptr.item(_unwrap(index)));
  }
}

class _FileReaderImpl extends _DOMTypeBase implements FileReader {
  _FileReaderImpl._wrap(ptr) : super._wrap(ptr);

  FileError get error() => _wrap(_ptr.error);

  EventListener get onabort() => _wrap(_ptr.onabort);

  void set onabort(EventListener value) { _ptr.onabort = _unwrap(value); }

  EventListener get onerror() => _wrap(_ptr.onerror);

  void set onerror(EventListener value) { _ptr.onerror = _unwrap(value); }

  EventListener get onload() => _wrap(_ptr.onload);

  void set onload(EventListener value) { _ptr.onload = _unwrap(value); }

  EventListener get onloadend() => _wrap(_ptr.onloadend);

  void set onloadend(EventListener value) { _ptr.onloadend = _unwrap(value); }

  EventListener get onloadstart() => _wrap(_ptr.onloadstart);

  void set onloadstart(EventListener value) { _ptr.onloadstart = _unwrap(value); }

  EventListener get onprogress() => _wrap(_ptr.onprogress);

  void set onprogress(EventListener value) { _ptr.onprogress = _unwrap(value); }

  int get readyState() => _wrap(_ptr.readyState);

  Object get result() => _wrap(_ptr.result);

  void abort() {
    _ptr.abort();
    return;
  }

  void addEventListener(String type, EventListener listener, [bool useCapture = null]) {
    if (useCapture === null) {
      _ptr.addEventListener(_unwrap(type), _unwrap(listener));
      return;
    } else {
      _ptr.addEventListener(_unwrap(type), _unwrap(listener), _unwrap(useCapture));
      return;
    }
  }

  bool dispatchEvent(Event evt) {
    return _wrap(_ptr.dispatchEvent(_unwrap(evt)));
  }

  void readAsArrayBuffer(Blob blob) {
    _ptr.readAsArrayBuffer(_unwrap(blob));
    return;
  }

  void readAsBinaryString(Blob blob) {
    _ptr.readAsBinaryString(_unwrap(blob));
    return;
  }

  void readAsDataURL(Blob blob) {
    _ptr.readAsDataURL(_unwrap(blob));
    return;
  }

  void readAsText(Blob blob, [String encoding = null]) {
    if (encoding === null) {
      _ptr.readAsText(_unwrap(blob));
      return;
    } else {
      _ptr.readAsText(_unwrap(blob), _unwrap(encoding));
      return;
    }
  }

  void removeEventListener(String type, EventListener listener, [bool useCapture = null]) {
    if (useCapture === null) {
      _ptr.removeEventListener(_unwrap(type), _unwrap(listener));
      return;
    } else {
      _ptr.removeEventListener(_unwrap(type), _unwrap(listener), _unwrap(useCapture));
      return;
    }
  }
}

class _FileReaderSyncImpl extends _DOMTypeBase implements FileReaderSync {
  _FileReaderSyncImpl._wrap(ptr) : super._wrap(ptr);

  ArrayBuffer readAsArrayBuffer(Blob blob) {
    return _wrap(_ptr.readAsArrayBuffer(_unwrap(blob)));
  }

  String readAsBinaryString(Blob blob) {
    return _wrap(_ptr.readAsBinaryString(_unwrap(blob)));
  }

  String readAsDataURL(Blob blob) {
    return _wrap(_ptr.readAsDataURL(_unwrap(blob)));
  }

  String readAsText(Blob blob, [String encoding = null]) {
    if (encoding === null) {
      return _wrap(_ptr.readAsText(_unwrap(blob)));
    } else {
      return _wrap(_ptr.readAsText(_unwrap(blob), _unwrap(encoding)));
    }
  }
}

class _FileWriterImpl extends _DOMTypeBase implements FileWriter {
  _FileWriterImpl._wrap(ptr) : super._wrap(ptr);

  FileError get error() => _wrap(_ptr.error);

  int get length() => _wrap(_ptr.length);

  EventListener get onabort() => _wrap(_ptr.onabort);

  void set onabort(EventListener value) { _ptr.onabort = _unwrap(value); }

  EventListener get onerror() => _wrap(_ptr.onerror);

  void set onerror(EventListener value) { _ptr.onerror = _unwrap(value); }

  EventListener get onprogress() => _wrap(_ptr.onprogress);

  void set onprogress(EventListener value) { _ptr.onprogress = _unwrap(value); }

  EventListener get onwrite() => _wrap(_ptr.onwrite);

  void set onwrite(EventListener value) { _ptr.onwrite = _unwrap(value); }

  EventListener get onwriteend() => _wrap(_ptr.onwriteend);

  void set onwriteend(EventListener value) { _ptr.onwriteend = _unwrap(value); }

  EventListener get onwritestart() => _wrap(_ptr.onwritestart);

  void set onwritestart(EventListener value) { _ptr.onwritestart = _unwrap(value); }

  int get position() => _wrap(_ptr.position);

  int get readyState() => _wrap(_ptr.readyState);

  void abort() {
    _ptr.abort();
    return;
  }

  void seek(int position) {
    _ptr.seek(_unwrap(position));
    return;
  }

  void truncate(int size) {
    _ptr.truncate(_unwrap(size));
    return;
  }

  void write(Blob data) {
    _ptr.write(_unwrap(data));
    return;
  }
}

class _FileWriterSyncImpl extends _DOMTypeBase implements FileWriterSync {
  _FileWriterSyncImpl._wrap(ptr) : super._wrap(ptr);

  int get length() => _wrap(_ptr.length);

  int get position() => _wrap(_ptr.position);

  void seek(int position) {
    _ptr.seek(_unwrap(position));
    return;
  }

  void truncate(int size) {
    _ptr.truncate(_unwrap(size));
    return;
  }

  void write(Blob data) {
    _ptr.write(_unwrap(data));
    return;
  }
}

class _Float32ArrayImpl extends _ArrayBufferViewImpl implements Float32Array, List<num> {
  _Float32ArrayImpl._wrap(ptr) : super._wrap(ptr);

  int get length() => _wrap(_ptr.length);

  num operator[](int index) => _wrap(_ptr[index]);


  void operator[]=(int index, num value) {
    throw new UnsupportedOperationException("Cannot assign element of immutable List.");
  }

  void add(num value) {
    throw new UnsupportedOperationException("Cannot add to immutable List.");
  }

  void addLast(num value) {
    throw new UnsupportedOperationException("Cannot add to immutable List.");
  }

  void addAll(Collection<num> collection) {
    throw new UnsupportedOperationException("Cannot add to immutable List.");
  }

  void sort(int compare(num a, num b)) {
    throw new UnsupportedOperationException("Cannot sort immutable List.");
  }

  void copyFrom(List<Object> src, int srcStart, int dstStart, int count) {
    throw new UnsupportedOperationException("This object is immutable.");
  }

  int indexOf(num element, [int start = 0]) {
    return _Lists.indexOf(this, element, start, this.length);
  }

  int lastIndexOf(num element, [int start = null]) {
    if (start === null) start = length - 1;
    return _Lists.lastIndexOf(this, element, start);
  }

  int clear() {
    throw new UnsupportedOperationException("Cannot clear immutable List.");
  }

  num removeLast() {
    throw new UnsupportedOperationException("Cannot removeLast on immutable List.");
  }

  num last() {
    return this[length - 1];
  }

  void forEach(void f(num element)) {
    _Collections.forEach(this, f);
  }

  Collection map(f(num element)) {
    return _Collections.map(this, [], f);
  }

  Collection<num> filter(bool f(num element)) {
    return _Collections.filter(this, new List<num>(), f);
  }

  bool every(bool f(num element)) {
    return _Collections.every(this, f);
  }

  bool some(bool f(num element)) {
    return _Collections.some(this, f);
  }

  void setRange(int start, int length, List<num> from, [int startFrom]) {
    throw new UnsupportedOperationException("Cannot setRange on immutable List.");
  }

  void removeRange(int start, int length) {
    throw new UnsupportedOperationException("Cannot removeRange on immutable List.");
  }

  void insertRange(int start, int length, [num initialValue]) {
    throw new UnsupportedOperationException("Cannot insertRange on immutable List.");
  }

  List<num> getRange(int start, int length) {
    throw new NotImplementedException();
  }

  bool isEmpty() {
    return length == 0;
  }

  Iterator<num> iterator() {
    return new _FixedSizeListIterator<num>(this);
  }

  void setElements(Object array, [int offset = null]) {
    if (offset === null) {
      _ptr.setElements(_unwrap(array));
      return;
    } else {
      _ptr.setElements(_unwrap(array), _unwrap(offset));
      return;
    }
  }

  Float32Array subarray(int start, [int end = null]) {
    if (end === null) {
      return _wrap(_ptr.subarray(_unwrap(start)));
    } else {
      return _wrap(_ptr.subarray(_unwrap(start), _unwrap(end)));
    }
  }
}

class _Float64ArrayImpl extends _ArrayBufferViewImpl implements Float64Array, List<num> {
  _Float64ArrayImpl._wrap(ptr) : super._wrap(ptr);

  int get length() => _wrap(_ptr.length);

  num operator[](int index) => _wrap(_ptr[index]);


  void operator[]=(int index, num value) {
    throw new UnsupportedOperationException("Cannot assign element of immutable List.");
  }

  void add(num value) {
    throw new UnsupportedOperationException("Cannot add to immutable List.");
  }

  void addLast(num value) {
    throw new UnsupportedOperationException("Cannot add to immutable List.");
  }

  void addAll(Collection<num> collection) {
    throw new UnsupportedOperationException("Cannot add to immutable List.");
  }

  void sort(int compare(num a, num b)) {
    throw new UnsupportedOperationException("Cannot sort immutable List.");
  }

  void copyFrom(List<Object> src, int srcStart, int dstStart, int count) {
    throw new UnsupportedOperationException("This object is immutable.");
  }

  int indexOf(num element, [int start = 0]) {
    return _Lists.indexOf(this, element, start, this.length);
  }

  int lastIndexOf(num element, [int start = null]) {
    if (start === null) start = length - 1;
    return _Lists.lastIndexOf(this, element, start);
  }

  int clear() {
    throw new UnsupportedOperationException("Cannot clear immutable List.");
  }

  num removeLast() {
    throw new UnsupportedOperationException("Cannot removeLast on immutable List.");
  }

  num last() {
    return this[length - 1];
  }

  void forEach(void f(num element)) {
    _Collections.forEach(this, f);
  }

  Collection map(f(num element)) {
    return _Collections.map(this, [], f);
  }

  Collection<num> filter(bool f(num element)) {
    return _Collections.filter(this, new List<num>(), f);
  }

  bool every(bool f(num element)) {
    return _Collections.every(this, f);
  }

  bool some(bool f(num element)) {
    return _Collections.some(this, f);
  }

  void setRange(int start, int length, List<num> from, [int startFrom]) {
    throw new UnsupportedOperationException("Cannot setRange on immutable List.");
  }

  void removeRange(int start, int length) {
    throw new UnsupportedOperationException("Cannot removeRange on immutable List.");
  }

  void insertRange(int start, int length, [num initialValue]) {
    throw new UnsupportedOperationException("Cannot insertRange on immutable List.");
  }

  List<num> getRange(int start, int length) {
    throw new NotImplementedException();
  }

  bool isEmpty() {
    return length == 0;
  }

  Iterator<num> iterator() {
    return new _FixedSizeListIterator<num>(this);
  }

  void setElements(Object array, [int offset = null]) {
    if (offset === null) {
      _ptr.setElements(_unwrap(array));
      return;
    } else {
      _ptr.setElements(_unwrap(array), _unwrap(offset));
      return;
    }
  }

  Float64Array subarray(int start, [int end = null]) {
    if (end === null) {
      return _wrap(_ptr.subarray(_unwrap(start)));
    } else {
      return _wrap(_ptr.subarray(_unwrap(start), _unwrap(end)));
    }
  }
}

class _FontElementImpl extends _ElementImpl implements FontElement {
  _FontElementImpl._wrap(ptr) : super._wrap(ptr);

  String get color() => _wrap(_ptr.color);

  void set color(String value) { _ptr.color = _unwrap(value); }

  String get face() => _wrap(_ptr.face);

  void set face(String value) { _ptr.face = _unwrap(value); }

  String get size() => _wrap(_ptr.size);

  void set size(String value) { _ptr.size = _unwrap(value); }
}

class _FormElementImpl extends _ElementImpl implements FormElement {
  _FormElementImpl._wrap(ptr) : super._wrap(ptr);

  String get acceptCharset() => _wrap(_ptr.acceptCharset);

  void set acceptCharset(String value) { _ptr.acceptCharset = _unwrap(value); }

  String get action() => _wrap(_ptr.action);

  void set action(String value) { _ptr.action = _unwrap(value); }

  String get autocomplete() => _wrap(_ptr.autocomplete);

  void set autocomplete(String value) { _ptr.autocomplete = _unwrap(value); }

  String get encoding() => _wrap(_ptr.encoding);

  void set encoding(String value) { _ptr.encoding = _unwrap(value); }

  String get enctype() => _wrap(_ptr.enctype);

  void set enctype(String value) { _ptr.enctype = _unwrap(value); }

  int get length() => _wrap(_ptr.length);

  String get method() => _wrap(_ptr.method);

  void set method(String value) { _ptr.method = _unwrap(value); }

  String get name() => _wrap(_ptr.name);

  void set name(String value) { _ptr.name = _unwrap(value); }

  bool get noValidate() => _wrap(_ptr.noValidate);

  void set noValidate(bool value) { _ptr.noValidate = _unwrap(value); }

  String get target() => _wrap(_ptr.target);

  void set target(String value) { _ptr.target = _unwrap(value); }

  bool checkValidity() {
    return _wrap(_ptr.checkValidity());
  }

  void reset() {
    _ptr.reset();
    return;
  }

  void submit() {
    _ptr.submit();
    return;
  }
}

class _FrameElementImpl extends _ElementImpl implements FrameElement {
  _FrameElementImpl._wrap(ptr) : super._wrap(ptr);

  Document get contentDocument() => _FixHtmlDocumentReference(_wrap(_ptr.contentDocument));

  Window get contentWindow() => _wrap(_ptr.contentWindow);

  String get frameBorder() => _wrap(_ptr.frameBorder);

  void set frameBorder(String value) { _ptr.frameBorder = _unwrap(value); }

  int get height() => _wrap(_ptr.height);

  String get location() => _wrap(_ptr.location);

  void set location(String value) { _ptr.location = _unwrap(value); }

  String get longDesc() => _wrap(_ptr.longDesc);

  void set longDesc(String value) { _ptr.longDesc = _unwrap(value); }

  String get marginHeight() => _wrap(_ptr.marginHeight);

  void set marginHeight(String value) { _ptr.marginHeight = _unwrap(value); }

  String get marginWidth() => _wrap(_ptr.marginWidth);

  void set marginWidth(String value) { _ptr.marginWidth = _unwrap(value); }

  String get name() => _wrap(_ptr.name);

  void set name(String value) { _ptr.name = _unwrap(value); }

  bool get noResize() => _wrap(_ptr.noResize);

  void set noResize(bool value) { _ptr.noResize = _unwrap(value); }

  String get scrolling() => _wrap(_ptr.scrolling);

  void set scrolling(String value) { _ptr.scrolling = _unwrap(value); }

  String get src() => _wrap(_ptr.src);

  void set src(String value) { _ptr.src = _unwrap(value); }

  int get width() => _wrap(_ptr.width);

  SVGDocument getSVGDocument() {
    return _wrap(_ptr.getSVGDocument());
  }
}

class _FrameSetElementImpl extends _ElementImpl implements FrameSetElement {
  _FrameSetElementImpl._wrap(ptr) : super._wrap(ptr);

  _FrameSetElementEventsImpl get on() {
    if (_on == null) _on = new _FrameSetElementEventsImpl(this);
    return _on;
  }

  String get cols() => _wrap(_ptr.cols);

  void set cols(String value) { _ptr.cols = _unwrap(value); }

  String get rows() => _wrap(_ptr.rows);

  void set rows(String value) { _ptr.rows = _unwrap(value); }
}

class _FrameSetElementEventsImpl extends _ElementEventsImpl implements FrameSetElementEvents {
  _FrameSetElementEventsImpl(_ptr) : super(_ptr);

  EventListenerList get beforeUnload() => _get('beforeunload');

  EventListenerList get blur() => _get('blur');

  EventListenerList get error() => _get('error');

  EventListenerList get focus() => _get('focus');

  EventListenerList get hashChange() => _get('hashchange');

  EventListenerList get load() => _get('load');

  EventListenerList get message() => _get('message');

  EventListenerList get offline() => _get('offline');

  EventListenerList get online() => _get('online');

  EventListenerList get popState() => _get('popstate');

  EventListenerList get resize() => _get('resize');

  EventListenerList get storage() => _get('storage');

  EventListenerList get unload() => _get('unload');
}

class _GeolocationImpl extends _DOMTypeBase implements Geolocation {
  _GeolocationImpl._wrap(ptr) : super._wrap(ptr);

  void clearWatch(int watchId) {
    _ptr.clearWatch(_unwrap(watchId));
    return;
  }

  void getCurrentPosition(PositionCallback successCallback, [PositionErrorCallback errorCallback = null]) {
    if (errorCallback === null) {
      _ptr.getCurrentPosition(_unwrap(successCallback));
      return;
    } else {
      _ptr.getCurrentPosition(_unwrap(successCallback), _unwrap(errorCallback));
      return;
    }
  }

  int watchPosition(PositionCallback successCallback, [PositionErrorCallback errorCallback = null]) {
    if (errorCallback === null) {
      return _wrap(_ptr.watchPosition(_unwrap(successCallback)));
    } else {
      return _wrap(_ptr.watchPosition(_unwrap(successCallback), _unwrap(errorCallback)));
    }
  }
}

class _GeopositionImpl extends _DOMTypeBase implements Geoposition {
  _GeopositionImpl._wrap(ptr) : super._wrap(ptr);

  Coordinates get coords() => _wrap(_ptr.coords);

  int get timestamp() => _wrap(_ptr.timestamp);
}

class _HRElementImpl extends _ElementImpl implements HRElement {
  _HRElementImpl._wrap(ptr) : super._wrap(ptr);

  String get align() => _wrap(_ptr.align);

  void set align(String value) { _ptr.align = _unwrap(value); }

  bool get noShade() => _wrap(_ptr.noShade);

  void set noShade(bool value) { _ptr.noShade = _unwrap(value); }

  String get size() => _wrap(_ptr.size);

  void set size(String value) { _ptr.size = _unwrap(value); }

  String get width() => _wrap(_ptr.width);

  void set width(String value) { _ptr.width = _unwrap(value); }
}

class _HTMLAllCollectionImpl extends _DOMTypeBase implements HTMLAllCollection {
  _HTMLAllCollectionImpl._wrap(ptr) : super._wrap(ptr);

  int get length() => _wrap(_ptr.length);

  Node item(int index) {
    return _wrap(_ptr.item(_unwrap(index)));
  }

  Node namedItem(String name) {
    return _wrap(_ptr.namedItem(_unwrap(name)));
  }

  NodeList tags(String name) {
    return _wrap(_ptr.tags(_unwrap(name)));
  }
}

class _HTMLCollectionImpl extends _DOMTypeBase implements HTMLCollection {
  _HTMLCollectionImpl._wrap(ptr) : super._wrap(ptr);

  int get length() => _wrap(_ptr.length);

  Node operator[](int index) => _wrap(_ptr[index]);


  void operator[]=(int index, Node value) {
    throw new UnsupportedOperationException("Cannot assign element of immutable List.");
  }

  void add(Node value) {
    throw new UnsupportedOperationException("Cannot add to immutable List.");
  }

  void addLast(Node value) {
    throw new UnsupportedOperationException("Cannot add to immutable List.");
  }

  void addAll(Collection<Node> collection) {
    throw new UnsupportedOperationException("Cannot add to immutable List.");
  }

  void sort(int compare(Node a, Node b)) {
    throw new UnsupportedOperationException("Cannot sort immutable List.");
  }

  void copyFrom(List<Object> src, int srcStart, int dstStart, int count) {
    throw new UnsupportedOperationException("This object is immutable.");
  }

  int indexOf(Node element, [int start = 0]) {
    return _Lists.indexOf(this, element, start, this.length);
  }

  int lastIndexOf(Node element, [int start = null]) {
    if (start === null) start = length - 1;
    return _Lists.lastIndexOf(this, element, start);
  }

  int clear() {
    throw new UnsupportedOperationException("Cannot clear immutable List.");
  }

  Node removeLast() {
    throw new UnsupportedOperationException("Cannot removeLast on immutable List.");
  }

  Node last() {
    return this[length - 1];
  }

  void forEach(void f(Node element)) {
    _Collections.forEach(this, f);
  }

  Collection map(f(Node element)) {
    return _Collections.map(this, [], f);
  }

  Collection<Node> filter(bool f(Node element)) {
    return _Collections.filter(this, new List<Node>(), f);
  }

  bool every(bool f(Node element)) {
    return _Collections.every(this, f);
  }

  bool some(bool f(Node element)) {
    return _Collections.some(this, f);
  }

  void setRange(int start, int length, List<Node> from, [int startFrom]) {
    throw new UnsupportedOperationException("Cannot setRange on immutable List.");
  }

  void removeRange(int start, int length) {
    throw new UnsupportedOperationException("Cannot removeRange on immutable List.");
  }

  void insertRange(int start, int length, [Node initialValue]) {
    throw new UnsupportedOperationException("Cannot insertRange on immutable List.");
  }

  List<Node> getRange(int start, int length) {
    throw new NotImplementedException();
  }

  bool isEmpty() {
    return length == 0;
  }

  Iterator<Node> iterator() {
    return new _FixedSizeListIterator<Node>(this);
  }

  Node item(int index) {
    return _wrap(_ptr.item(_unwrap(index)));
  }

  Node namedItem(String name) {
    return _wrap(_ptr.namedItem(_unwrap(name)));
  }
}

class _HTMLOptionsCollectionImpl extends _HTMLCollectionImpl implements HTMLOptionsCollection {
  _HTMLOptionsCollectionImpl._wrap(ptr) : super._wrap(ptr);

  int get length() => _wrap(_ptr.length);

  void set length(int value) { _ptr.length = _unwrap(value); }

  int get selectedIndex() => _wrap(_ptr.selectedIndex);

  void set selectedIndex(int value) { _ptr.selectedIndex = _unwrap(value); }

  void remove(int index) {
    _ptr.remove(_unwrap(index));
    return;
  }
}

class _HashChangeEventImpl extends _EventImpl implements HashChangeEvent {
  _HashChangeEventImpl._wrap(ptr) : super._wrap(ptr);

  String get newURL() => _wrap(_ptr.newURL);

  String get oldURL() => _wrap(_ptr.oldURL);

  void initHashChangeEvent(String type, bool canBubble, bool cancelable, String oldURL, String newURL) {
    _ptr.initHashChangeEvent(_unwrap(type), _unwrap(canBubble), _unwrap(cancelable), _unwrap(oldURL), _unwrap(newURL));
    return;
  }
}

class _HeadElementImpl extends _ElementImpl implements HeadElement {
  _HeadElementImpl._wrap(ptr) : super._wrap(ptr);

  String get profile() => _wrap(_ptr.profile);

  void set profile(String value) { _ptr.profile = _unwrap(value); }
}

class _HeadingElementImpl extends _ElementImpl implements HeadingElement {
  _HeadingElementImpl._wrap(ptr) : super._wrap(ptr);

  String get align() => _wrap(_ptr.align);

  void set align(String value) { _ptr.align = _unwrap(value); }
}

class _HighPass2FilterNodeImpl extends _AudioNodeImpl implements HighPass2FilterNode {
  _HighPass2FilterNodeImpl._wrap(ptr) : super._wrap(ptr);

  AudioParam get cutoff() => _wrap(_ptr.cutoff);

  AudioParam get resonance() => _wrap(_ptr.resonance);
}

class _HistoryImpl extends _DOMTypeBase implements History {
  _HistoryImpl._wrap(ptr) : super._wrap(ptr);

  int get length() => _wrap(_ptr.length);

  Dynamic get state() => _wrap(_ptr.state);

  void back() {
    _ptr.back();
    return;
  }

  void forward() {
    _ptr.forward();
    return;
  }

  void go(int distance) {
    _ptr.go(_unwrap(distance));
    return;
  }

  void pushState(Object data, String title, [String url = null]) {
    if (url === null) {
      _ptr.pushState(_unwrap(data), _unwrap(title));
      return;
    } else {
      _ptr.pushState(_unwrap(data), _unwrap(title), _unwrap(url));
      return;
    }
  }

  void replaceState(Object data, String title, [String url = null]) {
    if (url === null) {
      _ptr.replaceState(_unwrap(data), _unwrap(title));
      return;
    } else {
      _ptr.replaceState(_unwrap(data), _unwrap(title), _unwrap(url));
      return;
    }
  }
}

class _HtmlElementImpl extends _ElementImpl implements HtmlElement {
  _HtmlElementImpl._wrap(ptr) : super._wrap(ptr);
}

class _IDBAnyImpl extends _DOMTypeBase implements IDBAny {
  _IDBAnyImpl._wrap(ptr) : super._wrap(ptr);
}

class _IDBCursorImpl extends _DOMTypeBase implements IDBCursor {
  _IDBCursorImpl._wrap(ptr) : super._wrap(ptr);

  int get direction() => _wrap(_ptr.direction);

  IDBKey get key() => _wrap(_ptr.key);

  IDBKey get primaryKey() => _wrap(_ptr.primaryKey);

  IDBAny get source() => _wrap(_ptr.source);

  void continueFunction([IDBKey key = null]) {
    if (key === null) {
      _ptr.continueFunction();
      return;
    } else {
      _ptr.continueFunction(_unwrap(key));
      return;
    }
  }

  IDBRequest delete() {
    return _wrap(_ptr.delete());
  }

  IDBRequest update(Dynamic value) {
    return _wrap(_ptr.update(_unwrap(value)));
  }
}

class _IDBCursorWithValueImpl extends _IDBCursorImpl implements IDBCursorWithValue {
  _IDBCursorWithValueImpl._wrap(ptr) : super._wrap(ptr);

  IDBAny get value() => _wrap(_ptr.value);
}

class _IDBDatabaseImpl extends _DOMTypeBase implements IDBDatabase {
  _IDBDatabaseImpl._wrap(ptr) : super._wrap(ptr);

  String get name() => _wrap(_ptr.name);

  List<String> get objectStoreNames() => _wrap(_ptr.objectStoreNames);

  EventListener get onabort() => _wrap(_ptr.onabort);

  void set onabort(EventListener value) { _ptr.onabort = _unwrap(value); }

  EventListener get onerror() => _wrap(_ptr.onerror);

  void set onerror(EventListener value) { _ptr.onerror = _unwrap(value); }

  EventListener get onversionchange() => _wrap(_ptr.onversionchange);

  void set onversionchange(EventListener value) { _ptr.onversionchange = _unwrap(value); }

  String get version() => _wrap(_ptr.version);

  void addEventListener(String type, EventListener listener, [bool useCapture = null]) {
    if (useCapture === null) {
      _ptr.addEventListener(_unwrap(type), _unwrap(listener));
      return;
    } else {
      _ptr.addEventListener(_unwrap(type), _unwrap(listener), _unwrap(useCapture));
      return;
    }
  }

  void close() {
    _ptr.close();
    return;
  }

  IDBObjectStore createObjectStore(String name) {
    return _wrap(_ptr.createObjectStore(_unwrap(name)));
  }

  void deleteObjectStore(String name) {
    _ptr.deleteObjectStore(_unwrap(name));
    return;
  }

  bool dispatchEvent(Event evt) {
    return _wrap(_ptr.dispatchEvent(_unwrap(evt)));
  }

  void removeEventListener(String type, EventListener listener, [bool useCapture = null]) {
    if (useCapture === null) {
      _ptr.removeEventListener(_unwrap(type), _unwrap(listener));
      return;
    } else {
      _ptr.removeEventListener(_unwrap(type), _unwrap(listener), _unwrap(useCapture));
      return;
    }
  }

  IDBVersionChangeRequest setVersion(String version) {
    return _wrap(_ptr.setVersion(_unwrap(version)));
  }

  IDBTransaction transaction(var storeName_OR_storeNames, [int mode = null]) {
    if (storeName_OR_storeNames is List<String>) {
      if (mode === null) {
        return _wrap(_ptr.transaction(_unwrap(storeName_OR_storeNames)));
      } else {
        return _wrap(_ptr.transaction(_unwrap(storeName_OR_storeNames), _unwrap(mode)));
      }
    } else {
      if (storeName_OR_storeNames is String) {
        if (mode === null) {
          return _wrap(_ptr.transaction(_unwrap(storeName_OR_storeNames)));
        } else {
          return _wrap(_ptr.transaction(_unwrap(storeName_OR_storeNames), _unwrap(mode)));
        }
      }
    }
    throw "Incorrect number or type of arguments";
  }
}

class _IDBDatabaseErrorImpl extends _DOMTypeBase implements IDBDatabaseError {
  _IDBDatabaseErrorImpl._wrap(ptr) : super._wrap(ptr);

  int get code() => _wrap(_ptr.code);

  void set code(int value) { _ptr.code = _unwrap(value); }

  String get message() => _wrap(_ptr.message);

  void set message(String value) { _ptr.message = _unwrap(value); }
}

class _IDBDatabaseExceptionImpl extends _DOMTypeBase implements IDBDatabaseException {
  _IDBDatabaseExceptionImpl._wrap(ptr) : super._wrap(ptr);

  int get code() => _wrap(_ptr.code);

  String get message() => _wrap(_ptr.message);

  String get name() => _wrap(_ptr.name);

  String toString() {
    return _wrap(_ptr.toString());
  }
}

class _IDBFactoryImpl extends _DOMTypeBase implements IDBFactory {
  _IDBFactoryImpl._wrap(ptr) : super._wrap(ptr);

  int cmp(IDBKey first, IDBKey second) {
    return _wrap(_ptr.cmp(_unwrap(first), _unwrap(second)));
  }

  IDBVersionChangeRequest deleteDatabase(String name) {
    return _wrap(_ptr.deleteDatabase(_unwrap(name)));
  }

  IDBRequest getDatabaseNames() {
    return _wrap(_ptr.getDatabaseNames());
  }

  IDBRequest open(String name) {
    return _wrap(_ptr.open(_unwrap(name)));
  }
}

class _IDBIndexImpl extends _DOMTypeBase implements IDBIndex {
  _IDBIndexImpl._wrap(ptr) : super._wrap(ptr);

  String get keyPath() => _wrap(_ptr.keyPath);

  bool get multiEntry() => _wrap(_ptr.multiEntry);

  String get name() => _wrap(_ptr.name);

  IDBObjectStore get objectStore() => _wrap(_ptr.objectStore);

  bool get unique() => _wrap(_ptr.unique);

  IDBRequest count([var key_OR_range = null]) {
    if (key_OR_range === null) {
      return _wrap(_ptr.count());
    } else {
      if (key_OR_range is IDBKeyRange) {
        return _wrap(_ptr.count(_unwrap(key_OR_range)));
      } else {
        if (key_OR_range is IDBKey) {
          return _wrap(_ptr.count(_unwrap(key_OR_range)));
        }
      }
    }
    throw "Incorrect number or type of arguments";
  }

  IDBRequest getObject(IDBKey key) {
    return _wrap(_ptr.getObject(_unwrap(key)));
  }

  IDBRequest getKey(IDBKey key) {
    return _wrap(_ptr.getKey(_unwrap(key)));
  }

  IDBRequest openCursor([IDBKeyRange range = null, int direction = null]) {
    if (range === null) {
      if (direction === null) {
        return _wrap(_ptr.openCursor());
      }
    } else {
      if (direction === null) {
        return _wrap(_ptr.openCursor(_unwrap(range)));
      } else {
        return _wrap(_ptr.openCursor(_unwrap(range), _unwrap(direction)));
      }
    }
    throw "Incorrect number or type of arguments";
  }

  IDBRequest openKeyCursor([IDBKeyRange range = null, int direction = null]) {
    if (range === null) {
      if (direction === null) {
        return _wrap(_ptr.openKeyCursor());
      }
    } else {
      if (direction === null) {
        return _wrap(_ptr.openKeyCursor(_unwrap(range)));
      } else {
        return _wrap(_ptr.openKeyCursor(_unwrap(range), _unwrap(direction)));
      }
    }
    throw "Incorrect number or type of arguments";
  }
}

class _IDBKeyImpl extends _DOMTypeBase implements IDBKey {
  _IDBKeyImpl._wrap(ptr) : super._wrap(ptr);
}

class _IDBKeyRangeImpl extends _DOMTypeBase implements IDBKeyRange {
  _IDBKeyRangeImpl._wrap(ptr) : super._wrap(ptr);

  IDBKey get lower() => _wrap(_ptr.lower);

  bool get lowerOpen() => _wrap(_ptr.lowerOpen);

  IDBKey get upper() => _wrap(_ptr.upper);

  bool get upperOpen() => _wrap(_ptr.upperOpen);

  IDBKeyRange bound(IDBKey lower, IDBKey upper, [bool lowerOpen = null, bool upperOpen = null]) {
    if (lowerOpen === null) {
      if (upperOpen === null) {
        return _wrap(_ptr.bound(_unwrap(lower), _unwrap(upper)));
      }
    } else {
      if (upperOpen === null) {
        return _wrap(_ptr.bound(_unwrap(lower), _unwrap(upper), _unwrap(lowerOpen)));
      } else {
        return _wrap(_ptr.bound(_unwrap(lower), _unwrap(upper), _unwrap(lowerOpen), _unwrap(upperOpen)));
      }
    }
    throw "Incorrect number or type of arguments";
  }

  IDBKeyRange lowerBound(IDBKey bound, [bool open = null]) {
    if (open === null) {
      return _wrap(_ptr.lowerBound(_unwrap(bound)));
    } else {
      return _wrap(_ptr.lowerBound(_unwrap(bound), _unwrap(open)));
    }
  }

  IDBKeyRange only(IDBKey value) {
    return _wrap(_ptr.only(_unwrap(value)));
  }

  IDBKeyRange upperBound(IDBKey bound, [bool open = null]) {
    if (open === null) {
      return _wrap(_ptr.upperBound(_unwrap(bound)));
    } else {
      return _wrap(_ptr.upperBound(_unwrap(bound), _unwrap(open)));
    }
  }
}

class _IDBObjectStoreImpl extends _DOMTypeBase implements IDBObjectStore {
  _IDBObjectStoreImpl._wrap(ptr) : super._wrap(ptr);

  List<String> get indexNames() => _wrap(_ptr.indexNames);

  String get keyPath() => _wrap(_ptr.keyPath);

  String get name() => _wrap(_ptr.name);

  IDBTransaction get transaction() => _wrap(_ptr.transaction);

  IDBRequest add(Dynamic value, [IDBKey key = null]) {
    if (key === null) {
      return _wrap(_ptr.add(_unwrap(value)));
    } else {
      return _wrap(_ptr.add(_unwrap(value), _unwrap(key)));
    }
  }

  IDBRequest clear() {
    return _wrap(_ptr.clear());
  }

  IDBRequest count([var key_OR_range = null]) {
    if (key_OR_range === null) {
      return _wrap(_ptr.count());
    } else {
      if (key_OR_range is IDBKeyRange) {
        return _wrap(_ptr.count(_unwrap(key_OR_range)));
      } else {
        if (key_OR_range is IDBKey) {
          return _wrap(_ptr.count(_unwrap(key_OR_range)));
        }
      }
    }
    throw "Incorrect number or type of arguments";
  }

  IDBIndex createIndex(String name, String keyPath) {
    return _wrap(_ptr.createIndex(_unwrap(name), _unwrap(keyPath)));
  }

  IDBRequest delete(var key_OR_keyRange) {
    if (key_OR_keyRange is IDBKeyRange) {
      return _wrap(_ptr.delete(_unwrap(key_OR_keyRange)));
    } else {
      if (key_OR_keyRange is IDBKey) {
        return _wrap(_ptr.delete(_unwrap(key_OR_keyRange)));
      }
    }
    throw "Incorrect number or type of arguments";
  }

  void deleteIndex(String name) {
    _ptr.deleteIndex(_unwrap(name));
    return;
  }

  IDBRequest getObject(IDBKey key) {
    return _wrap(_ptr.getObject(_unwrap(key)));
  }

  IDBIndex index(String name) {
    return _wrap(_ptr.index(_unwrap(name)));
  }

  IDBRequest openCursor([IDBKeyRange range = null, int direction = null]) {
    if (range === null) {
      if (direction === null) {
        return _wrap(_ptr.openCursor());
      }
    } else {
      if (direction === null) {
        return _wrap(_ptr.openCursor(_unwrap(range)));
      } else {
        return _wrap(_ptr.openCursor(_unwrap(range), _unwrap(direction)));
      }
    }
    throw "Incorrect number or type of arguments";
  }

  IDBRequest put(Dynamic value, [IDBKey key = null]) {
    if (key === null) {
      return _wrap(_ptr.put(_unwrap(value)));
    } else {
      return _wrap(_ptr.put(_unwrap(value), _unwrap(key)));
    }
  }
}

class _IDBRequestImpl extends _DOMTypeBase implements IDBRequest {
  _IDBRequestImpl._wrap(ptr) : super._wrap(ptr);

  int get errorCode() => _wrap(_ptr.errorCode);

  EventListener get onerror() => _wrap(_ptr.onerror);

  void set onerror(EventListener value) { _ptr.onerror = _unwrap(value); }

  EventListener get onsuccess() => _wrap(_ptr.onsuccess);

  void set onsuccess(EventListener value) { _ptr.onsuccess = _unwrap(value); }

  int get readyState() => _wrap(_ptr.readyState);

  IDBAny get result() => _wrap(_ptr.result);

  IDBAny get source() => _wrap(_ptr.source);

  IDBTransaction get transaction() => _wrap(_ptr.transaction);

  String get webkitErrorMessage() => _wrap(_ptr.webkitErrorMessage);

  void addEventListener(String type, EventListener listener, [bool useCapture = null]) {
    if (useCapture === null) {
      _ptr.addEventListener(_unwrap(type), _unwrap(listener));
      return;
    } else {
      _ptr.addEventListener(_unwrap(type), _unwrap(listener), _unwrap(useCapture));
      return;
    }
  }

  bool dispatchEvent(Event evt) {
    return _wrap(_ptr.dispatchEvent(_unwrap(evt)));
  }

  void removeEventListener(String type, EventListener listener, [bool useCapture = null]) {
    if (useCapture === null) {
      _ptr.removeEventListener(_unwrap(type), _unwrap(listener));
      return;
    } else {
      _ptr.removeEventListener(_unwrap(type), _unwrap(listener), _unwrap(useCapture));
      return;
    }
  }
}

class _IDBTransactionImpl extends _DOMTypeBase implements IDBTransaction {
  _IDBTransactionImpl._wrap(ptr) : super._wrap(ptr);

  IDBDatabase get db() => _wrap(_ptr.db);

  int get mode() => _wrap(_ptr.mode);

  EventListener get onabort() => _wrap(_ptr.onabort);

  void set onabort(EventListener value) { _ptr.onabort = _unwrap(value); }

  EventListener get oncomplete() => _wrap(_ptr.oncomplete);

  void set oncomplete(EventListener value) { _ptr.oncomplete = _unwrap(value); }

  EventListener get onerror() => _wrap(_ptr.onerror);

  void set onerror(EventListener value) { _ptr.onerror = _unwrap(value); }

  void abort() {
    _ptr.abort();
    return;
  }

  void addEventListener(String type, EventListener listener, [bool useCapture = null]) {
    if (useCapture === null) {
      _ptr.addEventListener(_unwrap(type), _unwrap(listener));
      return;
    } else {
      _ptr.addEventListener(_unwrap(type), _unwrap(listener), _unwrap(useCapture));
      return;
    }
  }

  bool dispatchEvent(Event evt) {
    return _wrap(_ptr.dispatchEvent(_unwrap(evt)));
  }

  IDBObjectStore objectStore(String name) {
    return _wrap(_ptr.objectStore(_unwrap(name)));
  }

  void removeEventListener(String type, EventListener listener, [bool useCapture = null]) {
    if (useCapture === null) {
      _ptr.removeEventListener(_unwrap(type), _unwrap(listener));
      return;
    } else {
      _ptr.removeEventListener(_unwrap(type), _unwrap(listener), _unwrap(useCapture));
      return;
    }
  }
}

class _IDBVersionChangeEventImpl extends _EventImpl implements IDBVersionChangeEvent {
  _IDBVersionChangeEventImpl._wrap(ptr) : super._wrap(ptr);

  String get version() => _wrap(_ptr.version);
}

class _IDBVersionChangeRequestImpl extends _IDBRequestImpl implements IDBVersionChangeRequest {
  _IDBVersionChangeRequestImpl._wrap(ptr) : super._wrap(ptr);

  EventListener get onblocked() => _wrap(_ptr.onblocked);

  void set onblocked(EventListener value) { _ptr.onblocked = _unwrap(value); }
}

class _IFrameElementImpl extends _ElementImpl implements IFrameElement {
  _IFrameElementImpl._wrap(ptr) : super._wrap(ptr);

  String get align() => _wrap(_ptr.align);

  void set align(String value) { _ptr.align = _unwrap(value); }

  Document get contentDocument() => _FixHtmlDocumentReference(_wrap(_ptr.contentDocument));

  Window get contentWindow() => _wrap(_ptr.contentWindow);

  String get frameBorder() => _wrap(_ptr.frameBorder);

  void set frameBorder(String value) { _ptr.frameBorder = _unwrap(value); }

  String get height() => _wrap(_ptr.height);

  void set height(String value) { _ptr.height = _unwrap(value); }

  String get longDesc() => _wrap(_ptr.longDesc);

  void set longDesc(String value) { _ptr.longDesc = _unwrap(value); }

  String get marginHeight() => _wrap(_ptr.marginHeight);

  void set marginHeight(String value) { _ptr.marginHeight = _unwrap(value); }

  String get marginWidth() => _wrap(_ptr.marginWidth);

  void set marginWidth(String value) { _ptr.marginWidth = _unwrap(value); }

  String get name() => _wrap(_ptr.name);

  void set name(String value) { _ptr.name = _unwrap(value); }

  String get sandbox() => _wrap(_ptr.sandbox);

  void set sandbox(String value) { _ptr.sandbox = _unwrap(value); }

  String get scrolling() => _wrap(_ptr.scrolling);

  void set scrolling(String value) { _ptr.scrolling = _unwrap(value); }

  String get src() => _wrap(_ptr.src);

  void set src(String value) { _ptr.src = _unwrap(value); }

  String get width() => _wrap(_ptr.width);

  void set width(String value) { _ptr.width = _unwrap(value); }

  SVGDocument getSVGDocument() {
    return _wrap(_ptr.getSVGDocument());
  }
}

class _IceCandidateImpl extends _DOMTypeBase implements IceCandidate {
  _IceCandidateImpl._wrap(ptr) : super._wrap(ptr);

  String get label() => _wrap(_ptr.label);

  String toSdp() {
    return _wrap(_ptr.toSdp());
  }
}

class _ImageDataImpl extends _DOMTypeBase implements ImageData {
  _ImageDataImpl._wrap(ptr) : super._wrap(ptr);

  CanvasPixelArray get data() => _wrap(_ptr.data);

  int get height() => _wrap(_ptr.height);

  int get width() => _wrap(_ptr.width);
}

class _ImageElementImpl extends _ElementImpl implements ImageElement {
  _ImageElementImpl._wrap(ptr) : super._wrap(ptr);

  String get align() => _wrap(_ptr.align);

  void set align(String value) { _ptr.align = _unwrap(value); }

  String get alt() => _wrap(_ptr.alt);

  void set alt(String value) { _ptr.alt = _unwrap(value); }

  String get border() => _wrap(_ptr.border);

  void set border(String value) { _ptr.border = _unwrap(value); }

  bool get complete() => _wrap(_ptr.complete);

  String get crossOrigin() => _wrap(_ptr.crossOrigin);

  void set crossOrigin(String value) { _ptr.crossOrigin = _unwrap(value); }

  int get height() => _wrap(_ptr.height);

  void set height(int value) { _ptr.height = _unwrap(value); }

  int get hspace() => _wrap(_ptr.hspace);

  void set hspace(int value) { _ptr.hspace = _unwrap(value); }

  bool get isMap() => _wrap(_ptr.isMap);

  void set isMap(bool value) { _ptr.isMap = _unwrap(value); }

  String get longDesc() => _wrap(_ptr.longDesc);

  void set longDesc(String value) { _ptr.longDesc = _unwrap(value); }

  String get lowsrc() => _wrap(_ptr.lowsrc);

  void set lowsrc(String value) { _ptr.lowsrc = _unwrap(value); }

  String get name() => _wrap(_ptr.name);

  void set name(String value) { _ptr.name = _unwrap(value); }

  int get naturalHeight() => _wrap(_ptr.naturalHeight);

  int get naturalWidth() => _wrap(_ptr.naturalWidth);

  String get src() => _wrap(_ptr.src);

  void set src(String value) { _ptr.src = _unwrap(value); }

  String get useMap() => _wrap(_ptr.useMap);

  void set useMap(String value) { _ptr.useMap = _unwrap(value); }

  int get vspace() => _wrap(_ptr.vspace);

  void set vspace(int value) { _ptr.vspace = _unwrap(value); }

  int get width() => _wrap(_ptr.width);

  void set width(int value) { _ptr.width = _unwrap(value); }

  int get x() => _wrap(_ptr.x);

  int get y() => _wrap(_ptr.y);
}

class _InputElementImpl extends _ElementImpl implements InputElement {
  _InputElementImpl._wrap(ptr) : super._wrap(ptr);

  _InputElementEventsImpl get on() {
    if (_on == null) _on = new _InputElementEventsImpl(this);
    return _on;
  }

  String get accept() => _wrap(_ptr.accept);

  void set accept(String value) { _ptr.accept = _unwrap(value); }

  String get align() => _wrap(_ptr.align);

  void set align(String value) { _ptr.align = _unwrap(value); }

  String get alt() => _wrap(_ptr.alt);

  void set alt(String value) { _ptr.alt = _unwrap(value); }

  String get autocomplete() => _wrap(_ptr.autocomplete);

  void set autocomplete(String value) { _ptr.autocomplete = _unwrap(value); }

  bool get autofocus() => _wrap(_ptr.autofocus);

  void set autofocus(bool value) { _ptr.autofocus = _unwrap(value); }

  bool get checked() => _wrap(_ptr.checked);

  void set checked(bool value) { _ptr.checked = _unwrap(value); }

  bool get defaultChecked() => _wrap(_ptr.defaultChecked);

  void set defaultChecked(bool value) { _ptr.defaultChecked = _unwrap(value); }

  String get defaultValue() => _wrap(_ptr.defaultValue);

  void set defaultValue(String value) { _ptr.defaultValue = _unwrap(value); }

  bool get disabled() => _wrap(_ptr.disabled);

  void set disabled(bool value) { _ptr.disabled = _unwrap(value); }

  FileList get files() => _wrap(_ptr.files);

  FormElement get form() => _wrap(_ptr.form);

  String get formAction() => _wrap(_ptr.formAction);

  void set formAction(String value) { _ptr.formAction = _unwrap(value); }

  String get formEnctype() => _wrap(_ptr.formEnctype);

  void set formEnctype(String value) { _ptr.formEnctype = _unwrap(value); }

  String get formMethod() => _wrap(_ptr.formMethod);

  void set formMethod(String value) { _ptr.formMethod = _unwrap(value); }

  bool get formNoValidate() => _wrap(_ptr.formNoValidate);

  void set formNoValidate(bool value) { _ptr.formNoValidate = _unwrap(value); }

  String get formTarget() => _wrap(_ptr.formTarget);

  void set formTarget(String value) { _ptr.formTarget = _unwrap(value); }

  bool get incremental() => _wrap(_ptr.incremental);

  void set incremental(bool value) { _ptr.incremental = _unwrap(value); }

  bool get indeterminate() => _wrap(_ptr.indeterminate);

  void set indeterminate(bool value) { _ptr.indeterminate = _unwrap(value); }

  NodeList get labels() => _wrap(_ptr.labels);

  String get max() => _wrap(_ptr.max);

  void set max(String value) { _ptr.max = _unwrap(value); }

  int get maxLength() => _wrap(_ptr.maxLength);

  void set maxLength(int value) { _ptr.maxLength = _unwrap(value); }

  String get min() => _wrap(_ptr.min);

  void set min(String value) { _ptr.min = _unwrap(value); }

  bool get multiple() => _wrap(_ptr.multiple);

  void set multiple(bool value) { _ptr.multiple = _unwrap(value); }

  String get name() => _wrap(_ptr.name);

  void set name(String value) { _ptr.name = _unwrap(value); }

  String get pattern() => _wrap(_ptr.pattern);

  void set pattern(String value) { _ptr.pattern = _unwrap(value); }

  String get placeholder() => _wrap(_ptr.placeholder);

  void set placeholder(String value) { _ptr.placeholder = _unwrap(value); }

  bool get readOnly() => _wrap(_ptr.readOnly);

  void set readOnly(bool value) { _ptr.readOnly = _unwrap(value); }

  bool get required() => _wrap(_ptr.required);

  void set required(bool value) { _ptr.required = _unwrap(value); }

  String get selectionDirection() => _wrap(_ptr.selectionDirection);

  void set selectionDirection(String value) { _ptr.selectionDirection = _unwrap(value); }

  int get selectionEnd() => _wrap(_ptr.selectionEnd);

  void set selectionEnd(int value) { _ptr.selectionEnd = _unwrap(value); }

  int get selectionStart() => _wrap(_ptr.selectionStart);

  void set selectionStart(int value) { _ptr.selectionStart = _unwrap(value); }

  int get size() => _wrap(_ptr.size);

  void set size(int value) { _ptr.size = _unwrap(value); }

  String get src() => _wrap(_ptr.src);

  void set src(String value) { _ptr.src = _unwrap(value); }

  String get step() => _wrap(_ptr.step);

  void set step(String value) { _ptr.step = _unwrap(value); }

  String get type() => _wrap(_ptr.type);

  void set type(String value) { _ptr.type = _unwrap(value); }

  String get useMap() => _wrap(_ptr.useMap);

  void set useMap(String value) { _ptr.useMap = _unwrap(value); }

  String get validationMessage() => _wrap(_ptr.validationMessage);

  ValidityState get validity() => _wrap(_ptr.validity);

  String get value() => _wrap(_ptr.value);

  void set value(String value) { _ptr.value = _unwrap(value); }

  Date get valueAsDate() => _wrap(_ptr.valueAsDate);

  void set valueAsDate(Date value) { _ptr.valueAsDate = _unwrap(value); }

  num get valueAsNumber() => _wrap(_ptr.valueAsNumber);

  void set valueAsNumber(num value) { _ptr.valueAsNumber = _unwrap(value); }

  bool get webkitGrammar() => _wrap(_ptr.webkitGrammar);

  void set webkitGrammar(bool value) { _ptr.webkitGrammar = _unwrap(value); }

  bool get webkitSpeech() => _wrap(_ptr.webkitSpeech);

  void set webkitSpeech(bool value) { _ptr.webkitSpeech = _unwrap(value); }

  bool get webkitdirectory() => _wrap(_ptr.webkitdirectory);

  void set webkitdirectory(bool value) { _ptr.webkitdirectory = _unwrap(value); }

  bool get willValidate() => _wrap(_ptr.willValidate);

  bool checkValidity() {
    return _wrap(_ptr.checkValidity());
  }

  void select() {
    _ptr.select();
    return;
  }

  void setCustomValidity(String error) {
    _ptr.setCustomValidity(_unwrap(error));
    return;
  }

  void setSelectionRange(int start, int end, [String direction = null]) {
    if (direction === null) {
      _ptr.setSelectionRange(_unwrap(start), _unwrap(end));
      return;
    } else {
      _ptr.setSelectionRange(_unwrap(start), _unwrap(end), _unwrap(direction));
      return;
    }
  }

  void stepDown([int n = null]) {
    if (n === null) {
      _ptr.stepDown();
      return;
    } else {
      _ptr.stepDown(_unwrap(n));
      return;
    }
  }

  void stepUp([int n = null]) {
    if (n === null) {
      _ptr.stepUp();
      return;
    } else {
      _ptr.stepUp(_unwrap(n));
      return;
    }
  }
}

class _InputElementEventsImpl extends _ElementEventsImpl implements InputElementEvents {
  _InputElementEventsImpl(_ptr) : super(_ptr);

  EventListenerList get speechChange() => _get('webkitSpeechChange');
}

class _Int16ArrayImpl extends _ArrayBufferViewImpl implements Int16Array, List<int> {
  _Int16ArrayImpl._wrap(ptr) : super._wrap(ptr);

  int get length() => _wrap(_ptr.length);

  int operator[](int index) => _wrap(_ptr[index]);


  void operator[]=(int index, int value) {
    throw new UnsupportedOperationException("Cannot assign element of immutable List.");
  }

  void add(int value) {
    throw new UnsupportedOperationException("Cannot add to immutable List.");
  }

  void addLast(int value) {
    throw new UnsupportedOperationException("Cannot add to immutable List.");
  }

  void addAll(Collection<int> collection) {
    throw new UnsupportedOperationException("Cannot add to immutable List.");
  }

  void sort(int compare(int a, int b)) {
    throw new UnsupportedOperationException("Cannot sort immutable List.");
  }

  void copyFrom(List<Object> src, int srcStart, int dstStart, int count) {
    throw new UnsupportedOperationException("This object is immutable.");
  }

  int indexOf(int element, [int start = 0]) {
    return _Lists.indexOf(this, element, start, this.length);
  }

  int lastIndexOf(int element, [int start = null]) {
    if (start === null) start = length - 1;
    return _Lists.lastIndexOf(this, element, start);
  }

  int clear() {
    throw new UnsupportedOperationException("Cannot clear immutable List.");
  }

  int removeLast() {
    throw new UnsupportedOperationException("Cannot removeLast on immutable List.");
  }

  int last() {
    return this[length - 1];
  }

  void forEach(void f(int element)) {
    _Collections.forEach(this, f);
  }

  Collection map(f(int element)) {
    return _Collections.map(this, [], f);
  }

  Collection<int> filter(bool f(int element)) {
    return _Collections.filter(this, new List<int>(), f);
  }

  bool every(bool f(int element)) {
    return _Collections.every(this, f);
  }

  bool some(bool f(int element)) {
    return _Collections.some(this, f);
  }

  void setRange(int start, int length, List<int> from, [int startFrom]) {
    throw new UnsupportedOperationException("Cannot setRange on immutable List.");
  }

  void removeRange(int start, int length) {
    throw new UnsupportedOperationException("Cannot removeRange on immutable List.");
  }

  void insertRange(int start, int length, [int initialValue]) {
    throw new UnsupportedOperationException("Cannot insertRange on immutable List.");
  }

  List<int> getRange(int start, int length) {
    throw new NotImplementedException();
  }

  bool isEmpty() {
    return length == 0;
  }

  Iterator<int> iterator() {
    return new _FixedSizeListIterator<int>(this);
  }

  void setElements(Object array, [int offset = null]) {
    if (offset === null) {
      _ptr.setElements(_unwrap(array));
      return;
    } else {
      _ptr.setElements(_unwrap(array), _unwrap(offset));
      return;
    }
  }

  Int16Array subarray(int start, [int end = null]) {
    if (end === null) {
      return _wrap(_ptr.subarray(_unwrap(start)));
    } else {
      return _wrap(_ptr.subarray(_unwrap(start), _unwrap(end)));
    }
  }
}

class _Int32ArrayImpl extends _ArrayBufferViewImpl implements Int32Array, List<int> {
  _Int32ArrayImpl._wrap(ptr) : super._wrap(ptr);

  int get length() => _wrap(_ptr.length);

  int operator[](int index) => _wrap(_ptr[index]);


  void operator[]=(int index, int value) {
    throw new UnsupportedOperationException("Cannot assign element of immutable List.");
  }

  void add(int value) {
    throw new UnsupportedOperationException("Cannot add to immutable List.");
  }

  void addLast(int value) {
    throw new UnsupportedOperationException("Cannot add to immutable List.");
  }

  void addAll(Collection<int> collection) {
    throw new UnsupportedOperationException("Cannot add to immutable List.");
  }

  void sort(int compare(int a, int b)) {
    throw new UnsupportedOperationException("Cannot sort immutable List.");
  }

  void copyFrom(List<Object> src, int srcStart, int dstStart, int count) {
    throw new UnsupportedOperationException("This object is immutable.");
  }

  int indexOf(int element, [int start = 0]) {
    return _Lists.indexOf(this, element, start, this.length);
  }

  int lastIndexOf(int element, [int start = null]) {
    if (start === null) start = length - 1;
    return _Lists.lastIndexOf(this, element, start);
  }

  int clear() {
    throw new UnsupportedOperationException("Cannot clear immutable List.");
  }

  int removeLast() {
    throw new UnsupportedOperationException("Cannot removeLast on immutable List.");
  }

  int last() {
    return this[length - 1];
  }

  void forEach(void f(int element)) {
    _Collections.forEach(this, f);
  }

  Collection map(f(int element)) {
    return _Collections.map(this, [], f);
  }

  Collection<int> filter(bool f(int element)) {
    return _Collections.filter(this, new List<int>(), f);
  }

  bool every(bool f(int element)) {
    return _Collections.every(this, f);
  }

  bool some(bool f(int element)) {
    return _Collections.some(this, f);
  }

  void setRange(int start, int length, List<int> from, [int startFrom]) {
    throw new UnsupportedOperationException("Cannot setRange on immutable List.");
  }

  void removeRange(int start, int length) {
    throw new UnsupportedOperationException("Cannot removeRange on immutable List.");
  }

  void insertRange(int start, int length, [int initialValue]) {
    throw new UnsupportedOperationException("Cannot insertRange on immutable List.");
  }

  List<int> getRange(int start, int length) {
    throw new NotImplementedException();
  }

  bool isEmpty() {
    return length == 0;
  }

  Iterator<int> iterator() {
    return new _FixedSizeListIterator<int>(this);
  }

  void setElements(Object array, [int offset = null]) {
    if (offset === null) {
      _ptr.setElements(_unwrap(array));
      return;
    } else {
      _ptr.setElements(_unwrap(array), _unwrap(offset));
      return;
    }
  }

  Int32Array subarray(int start, [int end = null]) {
    if (end === null) {
      return _wrap(_ptr.subarray(_unwrap(start)));
    } else {
      return _wrap(_ptr.subarray(_unwrap(start), _unwrap(end)));
    }
  }
}

class _Int8ArrayImpl extends _ArrayBufferViewImpl implements Int8Array, List<int> {
  _Int8ArrayImpl._wrap(ptr) : super._wrap(ptr);

  int get length() => _wrap(_ptr.length);

  int operator[](int index) => _wrap(_ptr[index]);


  void operator[]=(int index, int value) {
    throw new UnsupportedOperationException("Cannot assign element of immutable List.");
  }

  void add(int value) {
    throw new UnsupportedOperationException("Cannot add to immutable List.");
  }

  void addLast(int value) {
    throw new UnsupportedOperationException("Cannot add to immutable List.");
  }

  void addAll(Collection<int> collection) {
    throw new UnsupportedOperationException("Cannot add to immutable List.");
  }

  void sort(int compare(int a, int b)) {
    throw new UnsupportedOperationException("Cannot sort immutable List.");
  }

  void copyFrom(List<Object> src, int srcStart, int dstStart, int count) {
    throw new UnsupportedOperationException("This object is immutable.");
  }

  int indexOf(int element, [int start = 0]) {
    return _Lists.indexOf(this, element, start, this.length);
  }

  int lastIndexOf(int element, [int start = null]) {
    if (start === null) start = length - 1;
    return _Lists.lastIndexOf(this, element, start);
  }

  int clear() {
    throw new UnsupportedOperationException("Cannot clear immutable List.");
  }

  int removeLast() {
    throw new UnsupportedOperationException("Cannot removeLast on immutable List.");
  }

  int last() {
    return this[length - 1];
  }

  void forEach(void f(int element)) {
    _Collections.forEach(this, f);
  }

  Collection map(f(int element)) {
    return _Collections.map(this, [], f);
  }

  Collection<int> filter(bool f(int element)) {
    return _Collections.filter(this, new List<int>(), f);
  }

  bool every(bool f(int element)) {
    return _Collections.every(this, f);
  }

  bool some(bool f(int element)) {
    return _Collections.some(this, f);
  }

  void setRange(int start, int length, List<int> from, [int startFrom]) {
    throw new UnsupportedOperationException("Cannot setRange on immutable List.");
  }

  void removeRange(int start, int length) {
    throw new UnsupportedOperationException("Cannot removeRange on immutable List.");
  }

  void insertRange(int start, int length, [int initialValue]) {
    throw new UnsupportedOperationException("Cannot insertRange on immutable List.");
  }

  List<int> getRange(int start, int length) {
    throw new NotImplementedException();
  }

  bool isEmpty() {
    return length == 0;
  }

  Iterator<int> iterator() {
    return new _FixedSizeListIterator<int>(this);
  }

  void setElements(Object array, [int offset = null]) {
    if (offset === null) {
      _ptr.setElements(_unwrap(array));
      return;
    } else {
      _ptr.setElements(_unwrap(array), _unwrap(offset));
      return;
    }
  }

  Int8Array subarray(int start, [int end = null]) {
    if (end === null) {
      return _wrap(_ptr.subarray(_unwrap(start)));
    } else {
      return _wrap(_ptr.subarray(_unwrap(start), _unwrap(end)));
    }
  }
}

class _JavaScriptAudioNodeImpl extends _AudioNodeImpl implements JavaScriptAudioNode {
  _JavaScriptAudioNodeImpl._wrap(ptr) : super._wrap(ptr);

  int get bufferSize() => _wrap(_ptr.bufferSize);

  EventListener get onaudioprocess() => _wrap(_ptr.onaudioprocess);

  void set onaudioprocess(EventListener value) { _ptr.onaudioprocess = _unwrap(value); }
}

class _JavaScriptCallFrameImpl extends _DOMTypeBase implements JavaScriptCallFrame {
  _JavaScriptCallFrameImpl._wrap(ptr) : super._wrap(ptr);

  JavaScriptCallFrame get caller() => _wrap(_ptr.caller);

  int get column() => _wrap(_ptr.column);

  String get functionName() => _wrap(_ptr.functionName);

  int get line() => _wrap(_ptr.line);

  List get scopeChain() => _wrap(_ptr.scopeChain);

  int get sourceID() => _wrap(_ptr.sourceID);

  Object get thisObject() => _wrap(_ptr.thisObject);

  String get type() => _wrap(_ptr.type);

  void evaluate(String script) {
    _ptr.evaluate(_unwrap(script));
    return;
  }

  int scopeType(int scopeIndex) {
    return _wrap(_ptr.scopeType(_unwrap(scopeIndex)));
  }
}

class _KeyboardEventImpl extends _UIEventImpl implements KeyboardEvent {
  _KeyboardEventImpl._wrap(ptr) : super._wrap(ptr);

  bool get altGraphKey() => _wrap(_ptr.altGraphKey);

  bool get altKey() => _wrap(_ptr.altKey);

  bool get ctrlKey() => _wrap(_ptr.ctrlKey);

  String get keyIdentifier() => _wrap(_ptr.keyIdentifier);

  int get keyLocation() => _wrap(_ptr.keyLocation);

  bool get metaKey() => _wrap(_ptr.metaKey);

  bool get shiftKey() => _wrap(_ptr.shiftKey);

  void initKeyboardEvent(String type, bool canBubble, bool cancelable, Window view, String keyIdentifier, int keyLocation, bool ctrlKey, bool altKey, bool shiftKey, bool metaKey, bool altGraphKey) {
    _ptr.initKeyboardEvent(_unwrap(type), _unwrap(canBubble), _unwrap(cancelable), _unwrap(view), _unwrap(keyIdentifier), _unwrap(keyLocation), _unwrap(ctrlKey), _unwrap(altKey), _unwrap(shiftKey), _unwrap(metaKey), _unwrap(altGraphKey));
    return;
  }
}

class _KeygenElementImpl extends _ElementImpl implements KeygenElement {
  _KeygenElementImpl._wrap(ptr) : super._wrap(ptr);

  bool get autofocus() => _wrap(_ptr.autofocus);

  void set autofocus(bool value) { _ptr.autofocus = _unwrap(value); }

  String get challenge() => _wrap(_ptr.challenge);

  void set challenge(String value) { _ptr.challenge = _unwrap(value); }

  bool get disabled() => _wrap(_ptr.disabled);

  void set disabled(bool value) { _ptr.disabled = _unwrap(value); }

  FormElement get form() => _wrap(_ptr.form);

  String get keytype() => _wrap(_ptr.keytype);

  void set keytype(String value) { _ptr.keytype = _unwrap(value); }

  NodeList get labels() => _wrap(_ptr.labels);

  String get name() => _wrap(_ptr.name);

  void set name(String value) { _ptr.name = _unwrap(value); }

  String get type() => _wrap(_ptr.type);

  String get validationMessage() => _wrap(_ptr.validationMessage);

  ValidityState get validity() => _wrap(_ptr.validity);

  bool get willValidate() => _wrap(_ptr.willValidate);

  bool checkValidity() {
    return _wrap(_ptr.checkValidity());
  }

  void setCustomValidity(String error) {
    _ptr.setCustomValidity(_unwrap(error));
    return;
  }
}

class _LIElementImpl extends _ElementImpl implements LIElement {
  _LIElementImpl._wrap(ptr) : super._wrap(ptr);

  String get type() => _wrap(_ptr.type);

  void set type(String value) { _ptr.type = _unwrap(value); }

  int get value() => _wrap(_ptr.value);

  void set value(int value) { _ptr.value = _unwrap(value); }
}

class _LabelElementImpl extends _ElementImpl implements LabelElement {
  _LabelElementImpl._wrap(ptr) : super._wrap(ptr);

  Element get control() => _wrap(_ptr.control);

  FormElement get form() => _wrap(_ptr.form);

  String get htmlFor() => _wrap(_ptr.htmlFor);

  void set htmlFor(String value) { _ptr.htmlFor = _unwrap(value); }
}

class _LegendElementImpl extends _ElementImpl implements LegendElement {
  _LegendElementImpl._wrap(ptr) : super._wrap(ptr);

  String get align() => _wrap(_ptr.align);

  void set align(String value) { _ptr.align = _unwrap(value); }

  FormElement get form() => _wrap(_ptr.form);
}

class _LinkElementImpl extends _ElementImpl implements LinkElement {
  _LinkElementImpl._wrap(ptr) : super._wrap(ptr);

  String get charset() => _wrap(_ptr.charset);

  void set charset(String value) { _ptr.charset = _unwrap(value); }

  bool get disabled() => _wrap(_ptr.disabled);

  void set disabled(bool value) { _ptr.disabled = _unwrap(value); }

  String get href() => _wrap(_ptr.href);

  void set href(String value) { _ptr.href = _unwrap(value); }

  String get hreflang() => _wrap(_ptr.hreflang);

  void set hreflang(String value) { _ptr.hreflang = _unwrap(value); }

  String get media() => _wrap(_ptr.media);

  void set media(String value) { _ptr.media = _unwrap(value); }

  String get rel() => _wrap(_ptr.rel);

  void set rel(String value) { _ptr.rel = _unwrap(value); }

  String get rev() => _wrap(_ptr.rev);

  void set rev(String value) { _ptr.rev = _unwrap(value); }

  StyleSheet get sheet() => _wrap(_ptr.sheet);

  DOMSettableTokenList get sizes() => _wrap(_ptr.sizes);

  void set sizes(DOMSettableTokenList value) { _ptr.sizes = _unwrap(value); }

  String get target() => _wrap(_ptr.target);

  void set target(String value) { _ptr.target = _unwrap(value); }

  String get type() => _wrap(_ptr.type);

  void set type(String value) { _ptr.type = _unwrap(value); }
}

class _LocalMediaStreamImpl extends _MediaStreamImpl implements LocalMediaStream {
  _LocalMediaStreamImpl._wrap(ptr) : super._wrap(ptr);

  void stop() {
    _ptr.stop();
    return;
  }
}

class _LocationImpl extends _DOMTypeBase implements Location {
  _LocationImpl._wrap(ptr) : super._wrap(ptr);

  String get hash() => _wrap(_ptr.hash);

  void set hash(String value) { _ptr.hash = _unwrap(value); }

  String get host() => _wrap(_ptr.host);

  void set host(String value) { _ptr.host = _unwrap(value); }

  String get hostname() => _wrap(_ptr.hostname);

  void set hostname(String value) { _ptr.hostname = _unwrap(value); }

  String get href() => _wrap(_ptr.href);

  void set href(String value) { _ptr.href = _unwrap(value); }

  String get origin() => _wrap(_ptr.origin);

  String get pathname() => _wrap(_ptr.pathname);

  void set pathname(String value) { _ptr.pathname = _unwrap(value); }

  String get port() => _wrap(_ptr.port);

  void set port(String value) { _ptr.port = _unwrap(value); }

  String get protocol() => _wrap(_ptr.protocol);

  void set protocol(String value) { _ptr.protocol = _unwrap(value); }

  String get search() => _wrap(_ptr.search);

  void set search(String value) { _ptr.search = _unwrap(value); }

  void assign(String url) {
    _ptr.assign(_unwrap(url));
    return;
  }

  void reload() {
    _ptr.reload();
    return;
  }

  void replace(String url) {
    _ptr.replace(_unwrap(url));
    return;
  }

  String toString() {
    return _wrap(_ptr.toString());
  }
}

class _LowPass2FilterNodeImpl extends _AudioNodeImpl implements LowPass2FilterNode {
  _LowPass2FilterNodeImpl._wrap(ptr) : super._wrap(ptr);

  AudioParam get cutoff() => _wrap(_ptr.cutoff);

  AudioParam get resonance() => _wrap(_ptr.resonance);
}

class _MapElementImpl extends _ElementImpl implements MapElement {
  _MapElementImpl._wrap(ptr) : super._wrap(ptr);

  HTMLCollection get areas() => _wrap(_ptr.areas);

  String get name() => _wrap(_ptr.name);

  void set name(String value) { _ptr.name = _unwrap(value); }
}

class _MarqueeElementImpl extends _ElementImpl implements MarqueeElement {
  _MarqueeElementImpl._wrap(ptr) : super._wrap(ptr);

  String get behavior() => _wrap(_ptr.behavior);

  void set behavior(String value) { _ptr.behavior = _unwrap(value); }

  String get bgColor() => _wrap(_ptr.bgColor);

  void set bgColor(String value) { _ptr.bgColor = _unwrap(value); }

  String get direction() => _wrap(_ptr.direction);

  void set direction(String value) { _ptr.direction = _unwrap(value); }

  String get height() => _wrap(_ptr.height);

  void set height(String value) { _ptr.height = _unwrap(value); }

  int get hspace() => _wrap(_ptr.hspace);

  void set hspace(int value) { _ptr.hspace = _unwrap(value); }

  int get loop() => _wrap(_ptr.loop);

  void set loop(int value) { _ptr.loop = _unwrap(value); }

  int get scrollAmount() => _wrap(_ptr.scrollAmount);

  void set scrollAmount(int value) { _ptr.scrollAmount = _unwrap(value); }

  int get scrollDelay() => _wrap(_ptr.scrollDelay);

  void set scrollDelay(int value) { _ptr.scrollDelay = _unwrap(value); }

  bool get trueSpeed() => _wrap(_ptr.trueSpeed);

  void set trueSpeed(bool value) { _ptr.trueSpeed = _unwrap(value); }

  int get vspace() => _wrap(_ptr.vspace);

  void set vspace(int value) { _ptr.vspace = _unwrap(value); }

  String get width() => _wrap(_ptr.width);

  void set width(String value) { _ptr.width = _unwrap(value); }

  void start() {
    _ptr.start();
    return;
  }

  void stop() {
    _ptr.stop();
    return;
  }
}

class _MediaControllerImpl extends _DOMTypeBase implements MediaController {
  _MediaControllerImpl._wrap(ptr) : super._wrap(ptr);

  TimeRanges get buffered() => _wrap(_ptr.buffered);

  num get currentTime() => _wrap(_ptr.currentTime);

  void set currentTime(num value) { _ptr.currentTime = _unwrap(value); }

  num get defaultPlaybackRate() => _wrap(_ptr.defaultPlaybackRate);

  void set defaultPlaybackRate(num value) { _ptr.defaultPlaybackRate = _unwrap(value); }

  num get duration() => _wrap(_ptr.duration);

  bool get muted() => _wrap(_ptr.muted);

  void set muted(bool value) { _ptr.muted = _unwrap(value); }

  bool get paused() => _wrap(_ptr.paused);

  num get playbackRate() => _wrap(_ptr.playbackRate);

  void set playbackRate(num value) { _ptr.playbackRate = _unwrap(value); }

  TimeRanges get played() => _wrap(_ptr.played);

  TimeRanges get seekable() => _wrap(_ptr.seekable);

  num get volume() => _wrap(_ptr.volume);

  void set volume(num value) { _ptr.volume = _unwrap(value); }

  void addEventListener(String type, EventListener listener, [bool useCapture = null]) {
    if (useCapture === null) {
      _ptr.addEventListener(_unwrap(type), _unwrap(listener));
      return;
    } else {
      _ptr.addEventListener(_unwrap(type), _unwrap(listener), _unwrap(useCapture));
      return;
    }
  }

  bool dispatchEvent(Event evt) {
    return _wrap(_ptr.dispatchEvent(_unwrap(evt)));
  }

  void pause() {
    _ptr.pause();
    return;
  }

  void play() {
    _ptr.play();
    return;
  }

  void removeEventListener(String type, EventListener listener, [bool useCapture = null]) {
    if (useCapture === null) {
      _ptr.removeEventListener(_unwrap(type), _unwrap(listener));
      return;
    } else {
      _ptr.removeEventListener(_unwrap(type), _unwrap(listener), _unwrap(useCapture));
      return;
    }
  }
}

class _MediaElementImpl extends _ElementImpl implements MediaElement {
  _MediaElementImpl._wrap(ptr) : super._wrap(ptr);

  bool get autoplay() => _wrap(_ptr.autoplay);

  void set autoplay(bool value) { _ptr.autoplay = _unwrap(value); }

  TimeRanges get buffered() => _wrap(_ptr.buffered);

  MediaController get controller() => _wrap(_ptr.controller);

  void set controller(MediaController value) { _ptr.controller = _unwrap(value); }

  bool get controls() => _wrap(_ptr.controls);

  void set controls(bool value) { _ptr.controls = _unwrap(value); }

  String get currentSrc() => _wrap(_ptr.currentSrc);

  num get currentTime() => _wrap(_ptr.currentTime);

  void set currentTime(num value) { _ptr.currentTime = _unwrap(value); }

  bool get defaultMuted() => _wrap(_ptr.defaultMuted);

  void set defaultMuted(bool value) { _ptr.defaultMuted = _unwrap(value); }

  num get defaultPlaybackRate() => _wrap(_ptr.defaultPlaybackRate);

  void set defaultPlaybackRate(num value) { _ptr.defaultPlaybackRate = _unwrap(value); }

  num get duration() => _wrap(_ptr.duration);

  bool get ended() => _wrap(_ptr.ended);

  MediaError get error() => _wrap(_ptr.error);

  num get initialTime() => _wrap(_ptr.initialTime);

  bool get loop() => _wrap(_ptr.loop);

  void set loop(bool value) { _ptr.loop = _unwrap(value); }

  String get mediaGroup() => _wrap(_ptr.mediaGroup);

  void set mediaGroup(String value) { _ptr.mediaGroup = _unwrap(value); }

  bool get muted() => _wrap(_ptr.muted);

  void set muted(bool value) { _ptr.muted = _unwrap(value); }

  int get networkState() => _wrap(_ptr.networkState);

  bool get paused() => _wrap(_ptr.paused);

  num get playbackRate() => _wrap(_ptr.playbackRate);

  void set playbackRate(num value) { _ptr.playbackRate = _unwrap(value); }

  TimeRanges get played() => _wrap(_ptr.played);

  String get preload() => _wrap(_ptr.preload);

  void set preload(String value) { _ptr.preload = _unwrap(value); }

  int get readyState() => _wrap(_ptr.readyState);

  TimeRanges get seekable() => _wrap(_ptr.seekable);

  bool get seeking() => _wrap(_ptr.seeking);

  String get src() => _wrap(_ptr.src);

  void set src(String value) { _ptr.src = _unwrap(value); }

  num get startTime() => _wrap(_ptr.startTime);

  TextTrackList get textTracks() => _wrap(_ptr.textTracks);

  num get volume() => _wrap(_ptr.volume);

  void set volume(num value) { _ptr.volume = _unwrap(value); }

  int get webkitAudioDecodedByteCount() => _wrap(_ptr.webkitAudioDecodedByteCount);

  bool get webkitClosedCaptionsVisible() => _wrap(_ptr.webkitClosedCaptionsVisible);

  void set webkitClosedCaptionsVisible(bool value) { _ptr.webkitClosedCaptionsVisible = _unwrap(value); }

  bool get webkitHasClosedCaptions() => _wrap(_ptr.webkitHasClosedCaptions);

  String get webkitMediaSourceURL() => _wrap(_ptr.webkitMediaSourceURL);

  bool get webkitPreservesPitch() => _wrap(_ptr.webkitPreservesPitch);

  void set webkitPreservesPitch(bool value) { _ptr.webkitPreservesPitch = _unwrap(value); }

  int get webkitSourceState() => _wrap(_ptr.webkitSourceState);

  int get webkitVideoDecodedByteCount() => _wrap(_ptr.webkitVideoDecodedByteCount);

  TextTrack addTextTrack(String kind, [String label = null, String language = null]) {
    if (label === null) {
      if (language === null) {
        return _wrap(_ptr.addTextTrack(_unwrap(kind)));
      }
    } else {
      if (language === null) {
        return _wrap(_ptr.addTextTrack(_unwrap(kind), _unwrap(label)));
      } else {
        return _wrap(_ptr.addTextTrack(_unwrap(kind), _unwrap(label), _unwrap(language)));
      }
    }
    throw "Incorrect number or type of arguments";
  }

  String canPlayType(String type) {
    return _wrap(_ptr.canPlayType(_unwrap(type)));
  }

  void load() {
    _ptr.load();
    return;
  }

  void pause() {
    _ptr.pause();
    return;
  }

  void play() {
    _ptr.play();
    return;
  }

  void webkitSourceAppend(Uint8Array data) {
    _ptr.webkitSourceAppend(_unwrap(data));
    return;
  }

  void webkitSourceEndOfStream(int status) {
    _ptr.webkitSourceEndOfStream(_unwrap(status));
    return;
  }
}

class _MediaElementAudioSourceNodeImpl extends _AudioSourceNodeImpl implements MediaElementAudioSourceNode {
  _MediaElementAudioSourceNodeImpl._wrap(ptr) : super._wrap(ptr);

  MediaElement get mediaElement() => _wrap(_ptr.mediaElement);
}

class _MediaErrorImpl extends _DOMTypeBase implements MediaError {
  _MediaErrorImpl._wrap(ptr) : super._wrap(ptr);

  int get code() => _wrap(_ptr.code);
}

class _MediaListImpl extends _DOMTypeBase implements MediaList {
  _MediaListImpl._wrap(ptr) : super._wrap(ptr);

  int get length() => _wrap(_ptr.length);

  String get mediaText() => _wrap(_ptr.mediaText);

  void set mediaText(String value) { _ptr.mediaText = _unwrap(value); }

  String operator[](int index) => _wrap(_ptr[index]);


  void operator[]=(int index, String value) {
    throw new UnsupportedOperationException("Cannot assign element of immutable List.");
  }

  void add(String value) {
    throw new UnsupportedOperationException("Cannot add to immutable List.");
  }

  void addLast(String value) {
    throw new UnsupportedOperationException("Cannot add to immutable List.");
  }

  void addAll(Collection<String> collection) {
    throw new UnsupportedOperationException("Cannot add to immutable List.");
  }

  void sort(int compare(String a, String b)) {
    throw new UnsupportedOperationException("Cannot sort immutable List.");
  }

  void copyFrom(List<Object> src, int srcStart, int dstStart, int count) {
    throw new UnsupportedOperationException("This object is immutable.");
  }

  int indexOf(String element, [int start = 0]) {
    return _Lists.indexOf(this, element, start, this.length);
  }

  int lastIndexOf(String element, [int start = null]) {
    if (start === null) start = length - 1;
    return _Lists.lastIndexOf(this, element, start);
  }

  int clear() {
    throw new UnsupportedOperationException("Cannot clear immutable List.");
  }

  String removeLast() {
    throw new UnsupportedOperationException("Cannot removeLast on immutable List.");
  }

  String last() {
    return this[length - 1];
  }

  void forEach(void f(String element)) {
    _Collections.forEach(this, f);
  }

  Collection map(f(String element)) {
    return _Collections.map(this, [], f);
  }

  Collection<String> filter(bool f(String element)) {
    return _Collections.filter(this, new List<String>(), f);
  }

  bool every(bool f(String element)) {
    return _Collections.every(this, f);
  }

  bool some(bool f(String element)) {
    return _Collections.some(this, f);
  }

  void setRange(int start, int length, List<String> from, [int startFrom]) {
    throw new UnsupportedOperationException("Cannot setRange on immutable List.");
  }

  void removeRange(int start, int length) {
    throw new UnsupportedOperationException("Cannot removeRange on immutable List.");
  }

  void insertRange(int start, int length, [String initialValue]) {
    throw new UnsupportedOperationException("Cannot insertRange on immutable List.");
  }

  List<String> getRange(int start, int length) {
    throw new NotImplementedException();
  }

  bool isEmpty() {
    return length == 0;
  }

  Iterator<String> iterator() {
    return new _FixedSizeListIterator<String>(this);
  }

  void appendMedium(String newMedium) {
    _ptr.appendMedium(_unwrap(newMedium));
    return;
  }

  void deleteMedium(String oldMedium) {
    _ptr.deleteMedium(_unwrap(oldMedium));
    return;
  }

  String item(int index) {
    return _wrap(_ptr.item(_unwrap(index)));
  }
}

class _MediaQueryListImpl extends _DOMTypeBase implements MediaQueryList {
  _MediaQueryListImpl._wrap(ptr) : super._wrap(ptr);

  bool get matches() => _wrap(_ptr.matches);

  String get media() => _wrap(_ptr.media);

  void addListener(MediaQueryListListener listener) {
    _ptr.addListener(_unwrap(listener));
    return;
  }

  void removeListener(MediaQueryListListener listener) {
    _ptr.removeListener(_unwrap(listener));
    return;
  }
}

class _MediaQueryListListenerImpl extends _DOMTypeBase implements MediaQueryListListener {
  _MediaQueryListListenerImpl._wrap(ptr) : super._wrap(ptr);

  void queryChanged(MediaQueryList list) {
    _ptr.queryChanged(_unwrap(list));
    return;
  }
}

class _MediaStreamImpl extends _DOMTypeBase implements MediaStream {
  _MediaStreamImpl._wrap(ptr) : super._wrap(ptr);

  MediaStreamTrackList get audioTracks() => _wrap(_ptr.audioTracks);

  String get label() => _wrap(_ptr.label);

  EventListener get onended() => _wrap(_ptr.onended);

  void set onended(EventListener value) { _ptr.onended = _unwrap(value); }

  int get readyState() => _wrap(_ptr.readyState);

  MediaStreamTrackList get videoTracks() => _wrap(_ptr.videoTracks);

  void addEventListener(String type, EventListener listener, [bool useCapture = null]) {
    if (useCapture === null) {
      _ptr.addEventListener(_unwrap(type), _unwrap(listener));
      return;
    } else {
      _ptr.addEventListener(_unwrap(type), _unwrap(listener), _unwrap(useCapture));
      return;
    }
  }

  bool dispatchEvent(Event event) {
    return _wrap(_ptr.dispatchEvent(_unwrap(event)));
  }

  void removeEventListener(String type, EventListener listener, [bool useCapture = null]) {
    if (useCapture === null) {
      _ptr.removeEventListener(_unwrap(type), _unwrap(listener));
      return;
    } else {
      _ptr.removeEventListener(_unwrap(type), _unwrap(listener), _unwrap(useCapture));
      return;
    }
  }
}

class _MediaStreamEventImpl extends _EventImpl implements MediaStreamEvent {
  _MediaStreamEventImpl._wrap(ptr) : super._wrap(ptr);

  MediaStream get stream() => _wrap(_ptr.stream);
}

class _MediaStreamListImpl extends _DOMTypeBase implements MediaStreamList {
  _MediaStreamListImpl._wrap(ptr) : super._wrap(ptr);

  int get length() => _wrap(_ptr.length);

  MediaStream item(int index) {
    return _wrap(_ptr.item(_unwrap(index)));
  }
}

class _MediaStreamTrackImpl extends _DOMTypeBase implements MediaStreamTrack {
  _MediaStreamTrackImpl._wrap(ptr) : super._wrap(ptr);

  bool get enabled() => _wrap(_ptr.enabled);

  void set enabled(bool value) { _ptr.enabled = _unwrap(value); }

  String get kind() => _wrap(_ptr.kind);

  String get label() => _wrap(_ptr.label);
}

class _MediaStreamTrackListImpl extends _DOMTypeBase implements MediaStreamTrackList {
  _MediaStreamTrackListImpl._wrap(ptr) : super._wrap(ptr);

  int get length() => _wrap(_ptr.length);

  MediaStreamTrack item(int index) {
    return _wrap(_ptr.item(_unwrap(index)));
  }
}

class _MemoryInfoImpl extends _DOMTypeBase implements MemoryInfo {
  _MemoryInfoImpl._wrap(ptr) : super._wrap(ptr);

  int get jsHeapSizeLimit() => _wrap(_ptr.jsHeapSizeLimit);

  int get totalJSHeapSize() => _wrap(_ptr.totalJSHeapSize);

  int get usedJSHeapSize() => _wrap(_ptr.usedJSHeapSize);
}

class _MenuElementImpl extends _ElementImpl implements MenuElement {
  _MenuElementImpl._wrap(ptr) : super._wrap(ptr);

  bool get compact() => _wrap(_ptr.compact);

  void set compact(bool value) { _ptr.compact = _unwrap(value); }
}

class _MessageChannelImpl extends _DOMTypeBase implements MessageChannel {
  _MessageChannelImpl._wrap(ptr) : super._wrap(ptr);

  MessagePort get port1() => _wrap(_ptr.port1);

  MessagePort get port2() => _wrap(_ptr.port2);
}

class _MessageEventImpl extends _EventImpl implements MessageEvent {
  _MessageEventImpl._wrap(ptr) : super._wrap(ptr);

  Object get data() => _wrap(_ptr.data);

  String get lastEventId() => _wrap(_ptr.lastEventId);

  String get origin() => _wrap(_ptr.origin);

  List get ports() => _wrap(_ptr.ports);

  Window get source() => _wrap(_ptr.source);

  void initMessageEvent(String typeArg, bool canBubbleArg, bool cancelableArg, Object dataArg, String originArg, String lastEventIdArg, Window sourceArg, List messagePorts) {
    _ptr.initMessageEvent(_unwrap(typeArg), _unwrap(canBubbleArg), _unwrap(cancelableArg), _unwrap(dataArg), _unwrap(originArg), _unwrap(lastEventIdArg), _unwrap(sourceArg), _unwrap(messagePorts));
    return;
  }

  void webkitInitMessageEvent(String typeArg, bool canBubbleArg, bool cancelableArg, Object dataArg, String originArg, String lastEventIdArg, Window sourceArg, List transferables) {
    _ptr.webkitInitMessageEvent(_unwrap(typeArg), _unwrap(canBubbleArg), _unwrap(cancelableArg), _unwrap(dataArg), _unwrap(originArg), _unwrap(lastEventIdArg), _unwrap(sourceArg), _unwrap(transferables));
    return;
  }
}

class _MessagePortImpl extends _EventTargetImpl implements MessagePort {
  _MessagePortImpl._wrap(ptr) : super._wrap(ptr);

  _MessagePortEventsImpl get on() {
    if (_on == null) _on = new _MessagePortEventsImpl(this);
    return _on;
  }

  void _addEventListener(String type, EventListener listener, [bool useCapture = null]) {
    if (useCapture === null) {
      _ptr.addEventListener(_unwrap(type), _unwrap(listener));
      return;
    } else {
      _ptr.addEventListener(_unwrap(type), _unwrap(listener), _unwrap(useCapture));
      return;
    }
  }

  void close() {
    _ptr.close();
    return;
  }

  bool _dispatchEvent(Event evt) {
    return _wrap(_ptr.dispatchEvent(_unwrap(evt)));
  }

  void postMessage(String message, [List messagePorts = null]) {
    if (messagePorts === null) {
      _ptr.postMessage(_unwrap(message));
      return;
    } else {
      _ptr.postMessage(_unwrap(message), _unwrap(messagePorts));
      return;
    }
  }

  void _removeEventListener(String type, EventListener listener, [bool useCapture = null]) {
    if (useCapture === null) {
      _ptr.removeEventListener(_unwrap(type), _unwrap(listener));
      return;
    } else {
      _ptr.removeEventListener(_unwrap(type), _unwrap(listener), _unwrap(useCapture));
      return;
    }
  }

  void start() {
    _ptr.start();
    return;
  }

  void webkitPostMessage(String message, [List transfer = null]) {
    if (transfer === null) {
      _ptr.webkitPostMessage(_unwrap(message));
      return;
    } else {
      _ptr.webkitPostMessage(_unwrap(message), _unwrap(transfer));
      return;
    }
  }
}

class _MessagePortEventsImpl extends _EventsImpl implements MessagePortEvents {
  _MessagePortEventsImpl(_ptr) : super(_ptr);

  EventListenerList get message() => _get('message');
}

class _MetaElementImpl extends _ElementImpl implements MetaElement {
  _MetaElementImpl._wrap(ptr) : super._wrap(ptr);

  String get content() => _wrap(_ptr.content);

  void set content(String value) { _ptr.content = _unwrap(value); }

  String get httpEquiv() => _wrap(_ptr.httpEquiv);

  void set httpEquiv(String value) { _ptr.httpEquiv = _unwrap(value); }

  String get name() => _wrap(_ptr.name);

  void set name(String value) { _ptr.name = _unwrap(value); }

  String get scheme() => _wrap(_ptr.scheme);

  void set scheme(String value) { _ptr.scheme = _unwrap(value); }
}

class _MetadataImpl extends _DOMTypeBase implements Metadata {
  _MetadataImpl._wrap(ptr) : super._wrap(ptr);

  Date get modificationTime() => _wrap(_ptr.modificationTime);

  int get size() => _wrap(_ptr.size);
}

class _MeterElementImpl extends _ElementImpl implements MeterElement {
  _MeterElementImpl._wrap(ptr) : super._wrap(ptr);

  num get high() => _wrap(_ptr.high);

  void set high(num value) { _ptr.high = _unwrap(value); }

  NodeList get labels() => _wrap(_ptr.labels);

  num get low() => _wrap(_ptr.low);

  void set low(num value) { _ptr.low = _unwrap(value); }

  num get max() => _wrap(_ptr.max);

  void set max(num value) { _ptr.max = _unwrap(value); }

  num get min() => _wrap(_ptr.min);

  void set min(num value) { _ptr.min = _unwrap(value); }

  num get optimum() => _wrap(_ptr.optimum);

  void set optimum(num value) { _ptr.optimum = _unwrap(value); }

  num get value() => _wrap(_ptr.value);

  void set value(num value) { _ptr.value = _unwrap(value); }
}

class _ModElementImpl extends _ElementImpl implements ModElement {
  _ModElementImpl._wrap(ptr) : super._wrap(ptr);

  String get cite() => _wrap(_ptr.cite);

  void set cite(String value) { _ptr.cite = _unwrap(value); }

  String get dateTime() => _wrap(_ptr.dateTime);

  void set dateTime(String value) { _ptr.dateTime = _unwrap(value); }
}

class _MouseEventImpl extends _UIEventImpl implements MouseEvent {
  _MouseEventImpl._wrap(ptr) : super._wrap(ptr);

  bool get altKey() => _wrap(_ptr.altKey);

  int get button() => _wrap(_ptr.button);

  int get clientX() => _wrap(_ptr.clientX);

  int get clientY() => _wrap(_ptr.clientY);

  bool get ctrlKey() => _wrap(_ptr.ctrlKey);

  Clipboard get dataTransfer() => _wrap(_ptr.dataTransfer);

  Node get fromElement() => _wrap(_ptr.fromElement);

  bool get metaKey() => _wrap(_ptr.metaKey);

  int get offsetX() => _wrap(_ptr.offsetX);

  int get offsetY() => _wrap(_ptr.offsetY);

  EventTarget get relatedTarget() => _FixHtmlDocumentReference(_wrap(_ptr.relatedTarget));

  int get screenX() => _wrap(_ptr.screenX);

  int get screenY() => _wrap(_ptr.screenY);

  bool get shiftKey() => _wrap(_ptr.shiftKey);

  Node get toElement() => _wrap(_ptr.toElement);

  int get x() => _wrap(_ptr.x);

  int get y() => _wrap(_ptr.y);

  void _initMouseEvent(String type, bool canBubble, bool cancelable, Window view, int detail, int screenX, int screenY, int clientX, int clientY, bool ctrlKey, bool altKey, bool shiftKey, bool metaKey, int button, EventTarget relatedTarget) {
    _ptr.initMouseEvent(_unwrap(type), _unwrap(canBubble), _unwrap(cancelable), _unwrap(view), _unwrap(detail), _unwrap(screenX), _unwrap(screenY), _unwrap(clientX), _unwrap(clientY), _unwrap(ctrlKey), _unwrap(altKey), _unwrap(shiftKey), _unwrap(metaKey), _unwrap(button), _unwrap(relatedTarget));
    return;
  }
}

class _MutationEventImpl extends _EventImpl implements MutationEvent {
  _MutationEventImpl._wrap(ptr) : super._wrap(ptr);

  int get attrChange() => _wrap(_ptr.attrChange);

  String get attrName() => _wrap(_ptr.attrName);

  String get newValue() => _wrap(_ptr.newValue);

  String get prevValue() => _wrap(_ptr.prevValue);

  Node get relatedNode() => _wrap(_ptr.relatedNode);

  void initMutationEvent(String type, bool canBubble, bool cancelable, Node relatedNode, String prevValue, String newValue, String attrName, int attrChange) {
    _ptr.initMutationEvent(_unwrap(type), _unwrap(canBubble), _unwrap(cancelable), _unwrap(relatedNode), _unwrap(prevValue), _unwrap(newValue), _unwrap(attrName), _unwrap(attrChange));
    return;
  }
}

class _NamedNodeMapImpl extends _DOMTypeBase implements NamedNodeMap {
  _NamedNodeMapImpl._wrap(ptr) : super._wrap(ptr);

  int get length() => _wrap(_ptr.length);

  Node operator[](int index) => _wrap(_ptr[index]);


  void operator[]=(int index, Node value) {
    throw new UnsupportedOperationException("Cannot assign element of immutable List.");
  }

  void add(Node value) {
    throw new UnsupportedOperationException("Cannot add to immutable List.");
  }

  void addLast(Node value) {
    throw new UnsupportedOperationException("Cannot add to immutable List.");
  }

  void addAll(Collection<Node> collection) {
    throw new UnsupportedOperationException("Cannot add to immutable List.");
  }

  void sort(int compare(Node a, Node b)) {
    throw new UnsupportedOperationException("Cannot sort immutable List.");
  }

  void copyFrom(List<Object> src, int srcStart, int dstStart, int count) {
    throw new UnsupportedOperationException("This object is immutable.");
  }

  int indexOf(Node element, [int start = 0]) {
    return _Lists.indexOf(this, element, start, this.length);
  }

  int lastIndexOf(Node element, [int start = null]) {
    if (start === null) start = length - 1;
    return _Lists.lastIndexOf(this, element, start);
  }

  int clear() {
    throw new UnsupportedOperationException("Cannot clear immutable List.");
  }

  Node removeLast() {
    throw new UnsupportedOperationException("Cannot removeLast on immutable List.");
  }

  Node last() {
    return this[length - 1];
  }

  void forEach(void f(Node element)) {
    _Collections.forEach(this, f);
  }

  Collection map(f(Node element)) {
    return _Collections.map(this, [], f);
  }

  Collection<Node> filter(bool f(Node element)) {
    return _Collections.filter(this, new List<Node>(), f);
  }

  bool every(bool f(Node element)) {
    return _Collections.every(this, f);
  }

  bool some(bool f(Node element)) {
    return _Collections.some(this, f);
  }

  void setRange(int start, int length, List<Node> from, [int startFrom]) {
    throw new UnsupportedOperationException("Cannot setRange on immutable List.");
  }

  void removeRange(int start, int length) {
    throw new UnsupportedOperationException("Cannot removeRange on immutable List.");
  }

  void insertRange(int start, int length, [Node initialValue]) {
    throw new UnsupportedOperationException("Cannot insertRange on immutable List.");
  }

  List<Node> getRange(int start, int length) {
    throw new NotImplementedException();
  }

  bool isEmpty() {
    return length == 0;
  }

  Iterator<Node> iterator() {
    return new _FixedSizeListIterator<Node>(this);
  }

  Node getNamedItem(String name) {
    return _wrap(_ptr.getNamedItem(_unwrap(name)));
  }

  Node getNamedItemNS(String namespaceURI, String localName) {
    return _wrap(_ptr.getNamedItemNS(_unwrap(namespaceURI), _unwrap(localName)));
  }

  Node item(int index) {
    return _wrap(_ptr.item(_unwrap(index)));
  }

  Node removeNamedItem(String name) {
    return _wrap(_ptr.removeNamedItem(_unwrap(name)));
  }

  Node removeNamedItemNS(String namespaceURI, String localName) {
    return _wrap(_ptr.removeNamedItemNS(_unwrap(namespaceURI), _unwrap(localName)));
  }

  Node setNamedItem(Node node) {
    return _wrap(_ptr.setNamedItem(_unwrap(node)));
  }

  Node setNamedItemNS(Node node) {
    return _wrap(_ptr.setNamedItemNS(_unwrap(node)));
  }
}

class _NavigatorImpl extends _DOMTypeBase implements Navigator {
  _NavigatorImpl._wrap(ptr) : super._wrap(ptr);

  String get appCodeName() => _wrap(_ptr.appCodeName);

  String get appName() => _wrap(_ptr.appName);

  String get appVersion() => _wrap(_ptr.appVersion);

  bool get cookieEnabled() => _wrap(_ptr.cookieEnabled);

  Geolocation get geolocation() => _wrap(_ptr.geolocation);

  String get language() => _wrap(_ptr.language);

  DOMMimeTypeArray get mimeTypes() => _wrap(_ptr.mimeTypes);

  bool get onLine() => _wrap(_ptr.onLine);

  String get platform() => _wrap(_ptr.platform);

  DOMPluginArray get plugins() => _wrap(_ptr.plugins);

  String get product() => _wrap(_ptr.product);

  String get productSub() => _wrap(_ptr.productSub);

  String get userAgent() => _wrap(_ptr.userAgent);

  String get vendor() => _wrap(_ptr.vendor);

  String get vendorSub() => _wrap(_ptr.vendorSub);

  void getStorageUpdates() {
    _ptr.getStorageUpdates();
    return;
  }

  bool javaEnabled() {
    return _wrap(_ptr.javaEnabled());
  }

  void registerProtocolHandler(String scheme, String url, String title) {
    _ptr.registerProtocolHandler(_unwrap(scheme), _unwrap(url), _unwrap(title));
    return;
  }

  void webkitGetUserMedia(String options, NavigatorUserMediaSuccessCallback successCallback, [NavigatorUserMediaErrorCallback errorCallback = null]) {
    if (errorCallback === null) {
      _ptr.webkitGetUserMedia(_unwrap(options), _unwrap(successCallback));
      return;
    } else {
      _ptr.webkitGetUserMedia(_unwrap(options), _unwrap(successCallback), _unwrap(errorCallback));
      return;
    }
  }
}

class _NavigatorUserMediaErrorImpl extends _DOMTypeBase implements NavigatorUserMediaError {
  _NavigatorUserMediaErrorImpl._wrap(ptr) : super._wrap(ptr);

  int get code() => _wrap(_ptr.code);
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

class _NodeImpl extends _EventTargetImpl implements Node {
  _NodeListImpl get nodes() {
    final list = _childNodes;
    list._parent = this;
    return list;
  }

  void set nodes(Collection<Node> value) {
    // Copy list first since we don't want liveness during iteration.
    // TODO(jacobr): there is a better way to do this.
    List copy = new List.from(value);
    text = '';
    for (Node node in copy) {
      _appendChild(node);
    }
  }

  // TODO(jacobr): should we throw an exception if parent is already null?
  _NodeImpl remove() {
    if (this.parent != null) {
      final _NodeImpl parent = this.parent;
      parent._removeChild(this);
    }
    return this;
  }

  _NodeImpl replaceWith(Node otherNode) {
    try {
      final _NodeImpl parent = this.parent;
      parent._replaceChild(otherNode, this);
    } catch(var e) {
      
    };
    return this;
  }

  _NodeImpl._wrap(ptr) : super._wrap(ptr);

  NamedNodeMap get _attributes() => _wrap(_ptr.attributes);

  NodeList get _childNodes() => _wrap(_ptr.childNodes);

  Node get nextNode() => _wrap(_ptr.nextSibling);

  Document get document() => _FixHtmlDocumentReference(_wrap(_ptr.ownerDocument));

  Node get parent() => _wrap(_ptr.parentNode);

  Node get previousNode() => _wrap(_ptr.previousSibling);

  String get text() => _wrap(_ptr.textContent);

  void set text(String value) { _ptr.textContent = _unwrap(value); }

  Node _appendChild(Node newChild) {
    return _wrap(_ptr.appendChild(_unwrap(newChild)));
  }

  Node clone(bool deep) {
    return _wrap(_ptr.cloneNode(_unwrap(deep)));
  }

  bool contains(Node other) {
    return _wrap(_ptr.contains(_unwrap(other)));
  }

  bool hasChildNodes() {
    return _wrap(_ptr.hasChildNodes());
  }

  Node insertBefore(Node newChild, Node refChild) {
    return _wrap(_ptr.insertBefore(_unwrap(newChild), _unwrap(refChild)));
  }

  Node _removeChild(Node oldChild) {
    return _wrap(_ptr.removeChild(_unwrap(oldChild)));
  }

  Node _replaceChild(Node newChild, Node oldChild) {
    return _wrap(_ptr.replaceChild(_unwrap(newChild), _unwrap(oldChild)));
  }

}

class _NodeFilterImpl extends _DOMTypeBase implements NodeFilter {
  _NodeFilterImpl._wrap(ptr) : super._wrap(ptr);

  int acceptNode(Node n) {
    return _wrap(_ptr.acceptNode(_unwrap(n)));
  }
}

class _NodeIteratorImpl extends _DOMTypeBase implements NodeIterator {
  _NodeIteratorImpl._wrap(ptr) : super._wrap(ptr);

  bool get expandEntityReferences() => _wrap(_ptr.expandEntityReferences);

  NodeFilter get filter() => _wrap(_ptr.filter);

  bool get pointerBeforeReferenceNode() => _wrap(_ptr.pointerBeforeReferenceNode);

  Node get referenceNode() => _wrap(_ptr.referenceNode);

  Node get root() => _wrap(_ptr.root);

  int get whatToShow() => _wrap(_ptr.whatToShow);

  void detach() {
    _ptr.detach();
    return;
  }

  Node nextNode() {
    return _wrap(_ptr.nextNode());
  }

  Node previousNode() {
    return _wrap(_ptr.previousNode());
  }
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// TODO(nweiz): when all implementations we target have the same name for the
// coreimpl implementation of List<E>, extend that rather than wrapping.
class _ListWrapper<E> implements List<E> {
  List _list;

  _ListWrapper(List this._list);

  Iterator<E> iterator() => _list.iterator();

  void forEach(void f(E element)) => _list.forEach(f);

  Collection map(f(E element)) => _list.map(f);

  List<E> filter(bool f(E element)) => _list.filter(f);

  bool every(bool f(E element)) => _list.every(f);

  bool some(bool f(E element)) => _list.some(f);

  bool isEmpty() => _list.isEmpty();

  int get length() => _list.length;

  E operator [](int index) => _list[index];

  void operator []=(int index, E value) { _list[index] = value; }

  void set length(int newLength) { _list.length = newLength; }

  void add(E value) => _list.add(value);

  void addLast(E value) => _list.addLast(value);

  void addAll(Collection<E> collection) => _list.addAll(collection);

  void sort(int compare(E a, E b)) => _list.sort(compare);

  int indexOf(E element, [int start = 0]) => _list.indexOf(element, start);

  int lastIndexOf(E element, [int start = 0]) =>
    _list.lastIndexOf(element, start);

  void clear() => _list.clear();

  E removeLast() => _list.removeLast();

  E last() => _list.last();

  List<E> getRange(int start, int length) => _list.getRange(start, length);

  void setRange(int start, int length, List<E> from, [int startFrom = 0]) =>
    _list.setRange(start, length, from, startFrom);

  void removeRange(int start, int length) => _list.removeRange(start, length);

  void insertRange(int start, int length, [E initialValue = null]) =>
    _list.insertRange(start, length, initialValue);

  E get first() => _list[0];
}

/**
 * This class is used to insure the results of list operations are NodeLists
 * instead of lists.
 */
class _NodeListWrapper extends _ListWrapper<Node> implements NodeList {
  _NodeListWrapper(List list) : super(list);

  NodeList filter(bool f(Node element)) =>
    new _NodeListWrapper(_list.filter(f));

  NodeList getRange(int start, int length) =>
    new _NodeListWrapper(_list.getRange(start, length));
}

class _NodeListImpl extends _DOMTypeBase implements NodeList {
  _NodeImpl _parent;

  // -- start List<Node> mixins.
  // Node is the element type.

  // From Iterable<Node>:

  Iterator<Node> iterator() {
    // Note: NodeLists are not fixed size. And most probably length shouldn't
    // be cached in both iterator _and_ forEach method. For now caching it
    // for consistency.
    return new _FixedSizeListIterator<Node>(this);
  }

  // From Collection<Node>:

  void add(_NodeImpl value) {
    _parent._appendChild(value);
  }

  void addLast(_NodeImpl value) {
    _parent._appendChild(value);
  }

  void addAll(Collection<_NodeImpl> collection) {
    for (_NodeImpl node in collection) {
      _parent._appendChild(node);      
    }
  }

  _NodeImpl removeLast() {
    final last = this.last();
    if (last != null) {
      _parent._removeChild(last);
    }
    return last;
  }

  void clear() {
    _parent.text = '';
  }

  void operator []=(int index, _NodeImpl value) {
    _parent._replaceChild(value, this[index]);
  }

  void forEach(void f(Node element)) => _Collections.forEach(this, f);

  Collection map(f(Node element)) => _Collections.map(this, [], f);

  Collection<Node> filter(bool f(Node element)) =>
     new _NodeListWrapper(_Collections.filter(this, <Node>[], f));

  bool every(bool f(Node element)) => _Collections.every(this, f);

  bool some(bool f(Node element)) => _Collections.some(this, f);

  bool isEmpty() => this.length == 0;

  // From List<Node>:

  void sort(int compare(Node a, Node b)) {
    throw new UnsupportedOperationException("Cannot sort immutable List.");
  }

  int indexOf(Node element, [int start = 0]) =>
      _Lists.indexOf(this, element, start, this.length);

  int lastIndexOf(Node element, [int start = 0]) =>
      _Lists.lastIndexOf(this, element, start);

  Node last() => this[length - 1];
  Node get first() => this[0];

  // FIXME: implement thesee.
  void setRange(int start, int length, List<Node> from, [int startFrom]) {
    throw new UnsupportedOperationException("Cannot setRange on immutable List.");
  }
  void removeRange(int start, int length) {
    throw new UnsupportedOperationException("Cannot removeRange on immutable List.");
  }
  void insertRange(int start, int length, [Node initialValue]) {
    throw new UnsupportedOperationException("Cannot insertRange on immutable List.");
  }
  NodeList getRange(int start, int length) =>
    new _NodeListWrapper(_Lists.getRange(this, start, length, <Node>[]));

  // -- end List<Node> mixins.

  _NodeListImpl._wrap(ptr) : super._wrap(ptr);

  int get length() => _wrap(_ptr.length);

  Node operator[](int index) => _wrap(_ptr[index]);


}

class _NodeSelectorImpl extends _DOMTypeBase implements NodeSelector {
  _NodeSelectorImpl._wrap(ptr) : super._wrap(ptr);

  Element query(String selectors) {
    return _wrap(_ptr.querySelector(_unwrap(selectors)));
  }

  NodeList _querySelectorAll(String selectors) {
    return _wrap(_ptr.querySelectorAll(_unwrap(selectors)));
  }
}

class _NotationImpl extends _NodeImpl implements Notation {
  _NotationImpl._wrap(ptr) : super._wrap(ptr);

  String get publicId() => _wrap(_ptr.publicId);

  String get systemId() => _wrap(_ptr.systemId);
}

class _NotificationImpl extends _EventTargetImpl implements Notification {
  _NotificationImpl._wrap(ptr) : super._wrap(ptr);

  _NotificationEventsImpl get on() {
    if (_on == null) _on = new _NotificationEventsImpl(this);
    return _on;
  }

  String get dir() => _wrap(_ptr.dir);

  void set dir(String value) { _ptr.dir = _unwrap(value); }

  String get replaceId() => _wrap(_ptr.replaceId);

  void set replaceId(String value) { _ptr.replaceId = _unwrap(value); }

  void cancel() {
    _ptr.cancel();
    return;
  }

  void show() {
    _ptr.show();
    return;
  }
}

class _NotificationEventsImpl extends _EventsImpl implements NotificationEvents {
  _NotificationEventsImpl(_ptr) : super(_ptr);

  EventListenerList get click() => _get('click');

  EventListenerList get close() => _get('close');

  EventListenerList get error() => _get('error');

  EventListenerList get show() => _get('show');
}

class _NotificationCenterImpl extends _DOMTypeBase implements NotificationCenter {
  _NotificationCenterImpl._wrap(ptr) : super._wrap(ptr);

  int checkPermission() {
    return _wrap(_ptr.checkPermission());
  }

  Notification createHTMLNotification(String url) {
    return _wrap(_ptr.createHTMLNotification(_unwrap(url)));
  }

  Notification createNotification(String iconUrl, String title, String body) {
    return _wrap(_ptr.createNotification(_unwrap(iconUrl), _unwrap(title), _unwrap(body)));
  }

  void requestPermission(VoidCallback callback) {
    _ptr.requestPermission(_unwrap(callback));
    return;
  }
}

class _OESStandardDerivativesImpl extends _DOMTypeBase implements OESStandardDerivatives {
  _OESStandardDerivativesImpl._wrap(ptr) : super._wrap(ptr);
}

class _OESTextureFloatImpl extends _DOMTypeBase implements OESTextureFloat {
  _OESTextureFloatImpl._wrap(ptr) : super._wrap(ptr);
}

class _OESVertexArrayObjectImpl extends _DOMTypeBase implements OESVertexArrayObject {
  _OESVertexArrayObjectImpl._wrap(ptr) : super._wrap(ptr);

  void bindVertexArrayOES(WebGLVertexArrayObjectOES arrayObject) {
    _ptr.bindVertexArrayOES(_unwrap(arrayObject));
    return;
  }

  WebGLVertexArrayObjectOES createVertexArrayOES() {
    return _wrap(_ptr.createVertexArrayOES());
  }

  void deleteVertexArrayOES(WebGLVertexArrayObjectOES arrayObject) {
    _ptr.deleteVertexArrayOES(_unwrap(arrayObject));
    return;
  }

  bool isVertexArrayOES(WebGLVertexArrayObjectOES arrayObject) {
    return _wrap(_ptr.isVertexArrayOES(_unwrap(arrayObject)));
  }
}

class _OListElementImpl extends _ElementImpl implements OListElement {
  _OListElementImpl._wrap(ptr) : super._wrap(ptr);

  bool get compact() => _wrap(_ptr.compact);

  void set compact(bool value) { _ptr.compact = _unwrap(value); }

  bool get reversed() => _wrap(_ptr.reversed);

  void set reversed(bool value) { _ptr.reversed = _unwrap(value); }

  int get start() => _wrap(_ptr.start);

  void set start(int value) { _ptr.start = _unwrap(value); }

  String get type() => _wrap(_ptr.type);

  void set type(String value) { _ptr.type = _unwrap(value); }
}

class _ObjectElementImpl extends _ElementImpl implements ObjectElement {
  _ObjectElementImpl._wrap(ptr) : super._wrap(ptr);

  String get align() => _wrap(_ptr.align);

  void set align(String value) { _ptr.align = _unwrap(value); }

  String get archive() => _wrap(_ptr.archive);

  void set archive(String value) { _ptr.archive = _unwrap(value); }

  String get border() => _wrap(_ptr.border);

  void set border(String value) { _ptr.border = _unwrap(value); }

  String get code() => _wrap(_ptr.code);

  void set code(String value) { _ptr.code = _unwrap(value); }

  String get codeBase() => _wrap(_ptr.codeBase);

  void set codeBase(String value) { _ptr.codeBase = _unwrap(value); }

  String get codeType() => _wrap(_ptr.codeType);

  void set codeType(String value) { _ptr.codeType = _unwrap(value); }

  Document get contentDocument() => _FixHtmlDocumentReference(_wrap(_ptr.contentDocument));

  String get data() => _wrap(_ptr.data);

  void set data(String value) { _ptr.data = _unwrap(value); }

  bool get declare() => _wrap(_ptr.declare);

  void set declare(bool value) { _ptr.declare = _unwrap(value); }

  FormElement get form() => _wrap(_ptr.form);

  String get height() => _wrap(_ptr.height);

  void set height(String value) { _ptr.height = _unwrap(value); }

  int get hspace() => _wrap(_ptr.hspace);

  void set hspace(int value) { _ptr.hspace = _unwrap(value); }

  String get name() => _wrap(_ptr.name);

  void set name(String value) { _ptr.name = _unwrap(value); }

  String get standby() => _wrap(_ptr.standby);

  void set standby(String value) { _ptr.standby = _unwrap(value); }

  String get type() => _wrap(_ptr.type);

  void set type(String value) { _ptr.type = _unwrap(value); }

  String get useMap() => _wrap(_ptr.useMap);

  void set useMap(String value) { _ptr.useMap = _unwrap(value); }

  String get validationMessage() => _wrap(_ptr.validationMessage);

  ValidityState get validity() => _wrap(_ptr.validity);

  int get vspace() => _wrap(_ptr.vspace);

  void set vspace(int value) { _ptr.vspace = _unwrap(value); }

  String get width() => _wrap(_ptr.width);

  void set width(String value) { _ptr.width = _unwrap(value); }

  bool get willValidate() => _wrap(_ptr.willValidate);

  bool checkValidity() {
    return _wrap(_ptr.checkValidity());
  }

  void setCustomValidity(String error) {
    _ptr.setCustomValidity(_unwrap(error));
    return;
  }
}

class _OfflineAudioCompletionEventImpl extends _EventImpl implements OfflineAudioCompletionEvent {
  _OfflineAudioCompletionEventImpl._wrap(ptr) : super._wrap(ptr);

  AudioBuffer get renderedBuffer() => _wrap(_ptr.renderedBuffer);
}

class _OperationNotAllowedExceptionImpl extends _DOMTypeBase implements OperationNotAllowedException {
  _OperationNotAllowedExceptionImpl._wrap(ptr) : super._wrap(ptr);

  int get code() => _wrap(_ptr.code);

  String get message() => _wrap(_ptr.message);

  String get name() => _wrap(_ptr.name);

  String toString() {
    return _wrap(_ptr.toString());
  }
}

class _OptGroupElementImpl extends _ElementImpl implements OptGroupElement {
  _OptGroupElementImpl._wrap(ptr) : super._wrap(ptr);

  bool get disabled() => _wrap(_ptr.disabled);

  void set disabled(bool value) { _ptr.disabled = _unwrap(value); }

  String get label() => _wrap(_ptr.label);

  void set label(String value) { _ptr.label = _unwrap(value); }
}

class _OptionElementImpl extends _ElementImpl implements OptionElement {
  _OptionElementImpl._wrap(ptr) : super._wrap(ptr);

  bool get defaultSelected() => _wrap(_ptr.defaultSelected);

  void set defaultSelected(bool value) { _ptr.defaultSelected = _unwrap(value); }

  bool get disabled() => _wrap(_ptr.disabled);

  void set disabled(bool value) { _ptr.disabled = _unwrap(value); }

  FormElement get form() => _wrap(_ptr.form);

  int get index() => _wrap(_ptr.index);

  String get label() => _wrap(_ptr.label);

  void set label(String value) { _ptr.label = _unwrap(value); }

  bool get selected() => _wrap(_ptr.selected);

  void set selected(bool value) { _ptr.selected = _unwrap(value); }

  String get value() => _wrap(_ptr.value);

  void set value(String value) { _ptr.value = _unwrap(value); }
}

class _OutputElementImpl extends _ElementImpl implements OutputElement {
  _OutputElementImpl._wrap(ptr) : super._wrap(ptr);

  String get defaultValue() => _wrap(_ptr.defaultValue);

  void set defaultValue(String value) { _ptr.defaultValue = _unwrap(value); }

  FormElement get form() => _wrap(_ptr.form);

  DOMSettableTokenList get htmlFor() => _wrap(_ptr.htmlFor);

  void set htmlFor(DOMSettableTokenList value) { _ptr.htmlFor = _unwrap(value); }

  NodeList get labels() => _wrap(_ptr.labels);

  String get name() => _wrap(_ptr.name);

  void set name(String value) { _ptr.name = _unwrap(value); }

  String get type() => _wrap(_ptr.type);

  String get validationMessage() => _wrap(_ptr.validationMessage);

  ValidityState get validity() => _wrap(_ptr.validity);

  String get value() => _wrap(_ptr.value);

  void set value(String value) { _ptr.value = _unwrap(value); }

  bool get willValidate() => _wrap(_ptr.willValidate);

  bool checkValidity() {
    return _wrap(_ptr.checkValidity());
  }

  void setCustomValidity(String error) {
    _ptr.setCustomValidity(_unwrap(error));
    return;
  }
}

class _OverflowEventImpl extends _EventImpl implements OverflowEvent {
  _OverflowEventImpl._wrap(ptr) : super._wrap(ptr);

  bool get horizontalOverflow() => _wrap(_ptr.horizontalOverflow);

  int get orient() => _wrap(_ptr.orient);

  bool get verticalOverflow() => _wrap(_ptr.verticalOverflow);
}

class _PageTransitionEventImpl extends _EventImpl implements PageTransitionEvent {
  _PageTransitionEventImpl._wrap(ptr) : super._wrap(ptr);

  bool get persisted() => _wrap(_ptr.persisted);
}

class _ParagraphElementImpl extends _ElementImpl implements ParagraphElement {
  _ParagraphElementImpl._wrap(ptr) : super._wrap(ptr);

  String get align() => _wrap(_ptr.align);

  void set align(String value) { _ptr.align = _unwrap(value); }
}

class _ParamElementImpl extends _ElementImpl implements ParamElement {
  _ParamElementImpl._wrap(ptr) : super._wrap(ptr);

  String get name() => _wrap(_ptr.name);

  void set name(String value) { _ptr.name = _unwrap(value); }

  String get type() => _wrap(_ptr.type);

  void set type(String value) { _ptr.type = _unwrap(value); }

  String get value() => _wrap(_ptr.value);

  void set value(String value) { _ptr.value = _unwrap(value); }

  String get valueType() => _wrap(_ptr.valueType);

  void set valueType(String value) { _ptr.valueType = _unwrap(value); }
}

class _PerformanceImpl extends _DOMTypeBase implements Performance {
  _PerformanceImpl._wrap(ptr) : super._wrap(ptr);

  MemoryInfo get memory() => _wrap(_ptr.memory);

  PerformanceNavigation get navigation() => _wrap(_ptr.navigation);

  PerformanceTiming get timing() => _wrap(_ptr.timing);
}

class _PerformanceNavigationImpl extends _DOMTypeBase implements PerformanceNavigation {
  _PerformanceNavigationImpl._wrap(ptr) : super._wrap(ptr);

  int get redirectCount() => _wrap(_ptr.redirectCount);

  int get type() => _wrap(_ptr.type);
}

class _PerformanceTimingImpl extends _DOMTypeBase implements PerformanceTiming {
  _PerformanceTimingImpl._wrap(ptr) : super._wrap(ptr);

  int get connectEnd() => _wrap(_ptr.connectEnd);

  int get connectStart() => _wrap(_ptr.connectStart);

  int get domComplete() => _wrap(_ptr.domComplete);

  int get domContentLoadedEventEnd() => _wrap(_ptr.domContentLoadedEventEnd);

  int get domContentLoadedEventStart() => _wrap(_ptr.domContentLoadedEventStart);

  int get domInteractive() => _wrap(_ptr.domInteractive);

  int get domLoading() => _wrap(_ptr.domLoading);

  int get domainLookupEnd() => _wrap(_ptr.domainLookupEnd);

  int get domainLookupStart() => _wrap(_ptr.domainLookupStart);

  int get fetchStart() => _wrap(_ptr.fetchStart);

  int get loadEventEnd() => _wrap(_ptr.loadEventEnd);

  int get loadEventStart() => _wrap(_ptr.loadEventStart);

  int get navigationStart() => _wrap(_ptr.navigationStart);

  int get redirectEnd() => _wrap(_ptr.redirectEnd);

  int get redirectStart() => _wrap(_ptr.redirectStart);

  int get requestStart() => _wrap(_ptr.requestStart);

  int get responseEnd() => _wrap(_ptr.responseEnd);

  int get responseStart() => _wrap(_ptr.responseStart);

  int get secureConnectionStart() => _wrap(_ptr.secureConnectionStart);

  int get unloadEventEnd() => _wrap(_ptr.unloadEventEnd);

  int get unloadEventStart() => _wrap(_ptr.unloadEventStart);
}

class _PointImpl extends _DOMTypeBase implements Point {
  _PointImpl._wrap(ptr) : super._wrap(ptr);

  num get x() => _wrap(_ptr.x);

  void set x(num value) { _ptr.x = _unwrap(value); }

  num get y() => _wrap(_ptr.y);

  void set y(num value) { _ptr.y = _unwrap(value); }
}

class _PopStateEventImpl extends _EventImpl implements PopStateEvent {
  _PopStateEventImpl._wrap(ptr) : super._wrap(ptr);

  Object get state() => _wrap(_ptr.state);
}

class _PositionErrorImpl extends _DOMTypeBase implements PositionError {
  _PositionErrorImpl._wrap(ptr) : super._wrap(ptr);

  int get code() => _wrap(_ptr.code);

  String get message() => _wrap(_ptr.message);
}

class _PreElementImpl extends _ElementImpl implements PreElement {
  _PreElementImpl._wrap(ptr) : super._wrap(ptr);

  int get width() => _wrap(_ptr.width);

  void set width(int value) { _ptr.width = _unwrap(value); }

  bool get wrap() => _wrap(_ptr.wrap);

  void set wrap(bool value) { _ptr.wrap = _unwrap(value); }
}

class _ProcessingInstructionImpl extends _NodeImpl implements ProcessingInstruction {
  _ProcessingInstructionImpl._wrap(ptr) : super._wrap(ptr);

  String get data() => _wrap(_ptr.data);

  void set data(String value) { _ptr.data = _unwrap(value); }

  StyleSheet get sheet() => _wrap(_ptr.sheet);

  String get target() => _wrap(_ptr.target);
}

class _ProgressElementImpl extends _ElementImpl implements ProgressElement {
  _ProgressElementImpl._wrap(ptr) : super._wrap(ptr);

  NodeList get labels() => _wrap(_ptr.labels);

  num get max() => _wrap(_ptr.max);

  void set max(num value) { _ptr.max = _unwrap(value); }

  num get position() => _wrap(_ptr.position);

  num get value() => _wrap(_ptr.value);

  void set value(num value) { _ptr.value = _unwrap(value); }
}

class _ProgressEventImpl extends _EventImpl implements ProgressEvent {
  _ProgressEventImpl._wrap(ptr) : super._wrap(ptr);

  bool get lengthComputable() => _wrap(_ptr.lengthComputable);

  int get loaded() => _wrap(_ptr.loaded);

  int get total() => _wrap(_ptr.total);
}

class _QuoteElementImpl extends _ElementImpl implements QuoteElement {
  _QuoteElementImpl._wrap(ptr) : super._wrap(ptr);

  String get cite() => _wrap(_ptr.cite);

  void set cite(String value) { _ptr.cite = _unwrap(value); }
}

class _RGBColorImpl extends _DOMTypeBase implements RGBColor {
  _RGBColorImpl._wrap(ptr) : super._wrap(ptr);

  CSSPrimitiveValue get blue() => _wrap(_ptr.blue);

  CSSPrimitiveValue get green() => _wrap(_ptr.green);

  CSSPrimitiveValue get red() => _wrap(_ptr.red);
}

class _RangeImpl extends _DOMTypeBase implements Range {
  _RangeImpl._wrap(ptr) : super._wrap(ptr);

  bool get collapsed() => _wrap(_ptr.collapsed);

  Node get commonAncestorContainer() => _wrap(_ptr.commonAncestorContainer);

  Node get endContainer() => _wrap(_ptr.endContainer);

  int get endOffset() => _wrap(_ptr.endOffset);

  Node get startContainer() => _wrap(_ptr.startContainer);

  int get startOffset() => _wrap(_ptr.startOffset);

  DocumentFragment cloneContents() {
    return _wrap(_ptr.cloneContents());
  }

  Range cloneRange() {
    return _wrap(_ptr.cloneRange());
  }

  void collapse(bool toStart) {
    _ptr.collapse(_unwrap(toStart));
    return;
  }

  int compareNode(Node refNode) {
    return _wrap(_ptr.compareNode(_unwrap(refNode)));
  }

  int comparePoint(Node refNode, int offset) {
    return _wrap(_ptr.comparePoint(_unwrap(refNode), _unwrap(offset)));
  }

  DocumentFragment createContextualFragment(String html) {
    return _wrap(_ptr.createContextualFragment(_unwrap(html)));
  }

  void deleteContents() {
    _ptr.deleteContents();
    return;
  }

  void detach() {
    _ptr.detach();
    return;
  }

  void expand(String unit) {
    _ptr.expand(_unwrap(unit));
    return;
  }

  DocumentFragment extractContents() {
    return _wrap(_ptr.extractContents());
  }

  ClientRect getBoundingClientRect() {
    return _wrap(_ptr.getBoundingClientRect());
  }

  ClientRectList getClientRects() {
    return _wrap(_ptr.getClientRects());
  }

  void insertNode(Node newNode) {
    _ptr.insertNode(_unwrap(newNode));
    return;
  }

  bool intersectsNode(Node refNode) {
    return _wrap(_ptr.intersectsNode(_unwrap(refNode)));
  }

  bool isPointInRange(Node refNode, int offset) {
    return _wrap(_ptr.isPointInRange(_unwrap(refNode), _unwrap(offset)));
  }

  void selectNode(Node refNode) {
    _ptr.selectNode(_unwrap(refNode));
    return;
  }

  void selectNodeContents(Node refNode) {
    _ptr.selectNodeContents(_unwrap(refNode));
    return;
  }

  void setEnd(Node refNode, int offset) {
    _ptr.setEnd(_unwrap(refNode), _unwrap(offset));
    return;
  }

  void setEndAfter(Node refNode) {
    _ptr.setEndAfter(_unwrap(refNode));
    return;
  }

  void setEndBefore(Node refNode) {
    _ptr.setEndBefore(_unwrap(refNode));
    return;
  }

  void setStart(Node refNode, int offset) {
    _ptr.setStart(_unwrap(refNode), _unwrap(offset));
    return;
  }

  void setStartAfter(Node refNode) {
    _ptr.setStartAfter(_unwrap(refNode));
    return;
  }

  void setStartBefore(Node refNode) {
    _ptr.setStartBefore(_unwrap(refNode));
    return;
  }

  void surroundContents(Node newParent) {
    _ptr.surroundContents(_unwrap(newParent));
    return;
  }

  String toString() {
    return _wrap(_ptr.toString());
  }
}

class _RangeExceptionImpl extends _DOMTypeBase implements RangeException {
  _RangeExceptionImpl._wrap(ptr) : super._wrap(ptr);

  int get code() => _wrap(_ptr.code);

  String get message() => _wrap(_ptr.message);

  String get name() => _wrap(_ptr.name);

  String toString() {
    return _wrap(_ptr.toString());
  }
}

class _RealtimeAnalyserNodeImpl extends _AudioNodeImpl implements RealtimeAnalyserNode {
  _RealtimeAnalyserNodeImpl._wrap(ptr) : super._wrap(ptr);

  int get fftSize() => _wrap(_ptr.fftSize);

  void set fftSize(int value) { _ptr.fftSize = _unwrap(value); }

  int get frequencyBinCount() => _wrap(_ptr.frequencyBinCount);

  num get maxDecibels() => _wrap(_ptr.maxDecibels);

  void set maxDecibels(num value) { _ptr.maxDecibels = _unwrap(value); }

  num get minDecibels() => _wrap(_ptr.minDecibels);

  void set minDecibels(num value) { _ptr.minDecibels = _unwrap(value); }

  num get smoothingTimeConstant() => _wrap(_ptr.smoothingTimeConstant);

  void set smoothingTimeConstant(num value) { _ptr.smoothingTimeConstant = _unwrap(value); }

  void getByteFrequencyData(Uint8Array array) {
    _ptr.getByteFrequencyData(_unwrap(array));
    return;
  }

  void getByteTimeDomainData(Uint8Array array) {
    _ptr.getByteTimeDomainData(_unwrap(array));
    return;
  }

  void getFloatFrequencyData(Float32Array array) {
    _ptr.getFloatFrequencyData(_unwrap(array));
    return;
  }
}

class _RectImpl extends _DOMTypeBase implements Rect {
  _RectImpl._wrap(ptr) : super._wrap(ptr);

  CSSPrimitiveValue get bottom() => _wrap(_ptr.bottom);

  CSSPrimitiveValue get left() => _wrap(_ptr.left);

  CSSPrimitiveValue get right() => _wrap(_ptr.right);

  CSSPrimitiveValue get top() => _wrap(_ptr.top);
}

class _SQLErrorImpl extends _DOMTypeBase implements SQLError {
  _SQLErrorImpl._wrap(ptr) : super._wrap(ptr);

  int get code() => _wrap(_ptr.code);

  String get message() => _wrap(_ptr.message);
}

class _SQLExceptionImpl extends _DOMTypeBase implements SQLException {
  _SQLExceptionImpl._wrap(ptr) : super._wrap(ptr);

  int get code() => _wrap(_ptr.code);

  String get message() => _wrap(_ptr.message);
}

class _SQLResultSetImpl extends _DOMTypeBase implements SQLResultSet {
  _SQLResultSetImpl._wrap(ptr) : super._wrap(ptr);

  int get insertId() => _wrap(_ptr.insertId);

  SQLResultSetRowList get rows() => _wrap(_ptr.rows);

  int get rowsAffected() => _wrap(_ptr.rowsAffected);
}

class _SQLResultSetRowListImpl extends _DOMTypeBase implements SQLResultSetRowList {
  _SQLResultSetRowListImpl._wrap(ptr) : super._wrap(ptr);

  int get length() => _wrap(_ptr.length);

  Object item(int index) {
    return _wrap(_ptr.item(_unwrap(index)));
  }
}

class _SQLTransactionImpl extends _DOMTypeBase implements SQLTransaction {
  _SQLTransactionImpl._wrap(ptr) : super._wrap(ptr);
}

class _SQLTransactionSyncImpl extends _DOMTypeBase implements SQLTransactionSync {
  _SQLTransactionSyncImpl._wrap(ptr) : super._wrap(ptr);
}

class _SVGAElementImpl extends _SVGElementImpl implements SVGAElement {
  _SVGAElementImpl._wrap(ptr) : super._wrap(ptr);

  SVGAnimatedString get target() => _wrap(_ptr.target);

  // From SVGURIReference

  SVGAnimatedString get href() => _wrap(_ptr.href);

  // From SVGTests

  SVGStringList get requiredExtensions() => _wrap(_ptr.requiredExtensions);

  SVGStringList get requiredFeatures() => _wrap(_ptr.requiredFeatures);

  SVGStringList get systemLanguage() => _wrap(_ptr.systemLanguage);

  bool hasExtension(String extension) {
    return _wrap(_ptr.hasExtension(_unwrap(extension)));
  }

  // From SVGLangSpace

  String get xmllang() => _wrap(_ptr.xmllang);

  void set xmllang(String value) { _ptr.xmllang = _unwrap(value); }

  String get xmlspace() => _wrap(_ptr.xmlspace);

  void set xmlspace(String value) { _ptr.xmlspace = _unwrap(value); }

  // From SVGExternalResourcesRequired

  SVGAnimatedBoolean get externalResourcesRequired() => _wrap(_ptr.externalResourcesRequired);

  // From SVGStylable

  SVGAnimatedString get _svgClassName() => _wrap(_ptr.className);

  CSSStyleDeclaration get style() => _wrap(_ptr.style);

  CSSValue getPresentationAttribute(String name) {
    return _wrap(_ptr.getPresentationAttribute(_unwrap(name)));
  }

  // From SVGTransformable

  SVGAnimatedTransformList get transform() => _wrap(_ptr.transform);

  // From SVGLocatable

  SVGElement get farthestViewportElement() => _wrap(_ptr.farthestViewportElement);

  SVGElement get nearestViewportElement() => _wrap(_ptr.nearestViewportElement);

  SVGRect getBBox() {
    return _wrap(_ptr.getBBox());
  }

  SVGMatrix getCTM() {
    return _wrap(_ptr.getCTM());
  }

  SVGMatrix getScreenCTM() {
    return _wrap(_ptr.getScreenCTM());
  }

  SVGMatrix getTransformToElement(SVGElement element) {
    return _wrap(_ptr.getTransformToElement(_unwrap(element)));
  }
}

class _SVGAltGlyphDefElementImpl extends _SVGElementImpl implements SVGAltGlyphDefElement {
  _SVGAltGlyphDefElementImpl._wrap(ptr) : super._wrap(ptr);
}

class _SVGAltGlyphElementImpl extends _SVGTextPositioningElementImpl implements SVGAltGlyphElement {
  _SVGAltGlyphElementImpl._wrap(ptr) : super._wrap(ptr);

  String get format() => _wrap(_ptr.format);

  void set format(String value) { _ptr.format = _unwrap(value); }

  String get glyphRef() => _wrap(_ptr.glyphRef);

  void set glyphRef(String value) { _ptr.glyphRef = _unwrap(value); }

  // From SVGURIReference

  SVGAnimatedString get href() => _wrap(_ptr.href);
}

class _SVGAltGlyphItemElementImpl extends _SVGElementImpl implements SVGAltGlyphItemElement {
  _SVGAltGlyphItemElementImpl._wrap(ptr) : super._wrap(ptr);
}

class _SVGAngleImpl extends _DOMTypeBase implements SVGAngle {
  _SVGAngleImpl._wrap(ptr) : super._wrap(ptr);

  int get unitType() => _wrap(_ptr.unitType);

  num get value() => _wrap(_ptr.value);

  void set value(num value) { _ptr.value = _unwrap(value); }

  String get valueAsString() => _wrap(_ptr.valueAsString);

  void set valueAsString(String value) { _ptr.valueAsString = _unwrap(value); }

  num get valueInSpecifiedUnits() => _wrap(_ptr.valueInSpecifiedUnits);

  void set valueInSpecifiedUnits(num value) { _ptr.valueInSpecifiedUnits = _unwrap(value); }

  void convertToSpecifiedUnits(int unitType) {
    _ptr.convertToSpecifiedUnits(_unwrap(unitType));
    return;
  }

  void newValueSpecifiedUnits(int unitType, num valueInSpecifiedUnits) {
    _ptr.newValueSpecifiedUnits(_unwrap(unitType), _unwrap(valueInSpecifiedUnits));
    return;
  }
}

class _SVGAnimateColorElementImpl extends _SVGAnimationElementImpl implements SVGAnimateColorElement {
  _SVGAnimateColorElementImpl._wrap(ptr) : super._wrap(ptr);
}

class _SVGAnimateElementImpl extends _SVGAnimationElementImpl implements SVGAnimateElement {
  _SVGAnimateElementImpl._wrap(ptr) : super._wrap(ptr);
}

class _SVGAnimateMotionElementImpl extends _SVGAnimationElementImpl implements SVGAnimateMotionElement {
  _SVGAnimateMotionElementImpl._wrap(ptr) : super._wrap(ptr);
}

class _SVGAnimateTransformElementImpl extends _SVGAnimationElementImpl implements SVGAnimateTransformElement {
  _SVGAnimateTransformElementImpl._wrap(ptr) : super._wrap(ptr);
}

class _SVGAnimatedAngleImpl extends _DOMTypeBase implements SVGAnimatedAngle {
  _SVGAnimatedAngleImpl._wrap(ptr) : super._wrap(ptr);

  SVGAngle get animVal() => _wrap(_ptr.animVal);

  SVGAngle get baseVal() => _wrap(_ptr.baseVal);
}

class _SVGAnimatedBooleanImpl extends _DOMTypeBase implements SVGAnimatedBoolean {
  _SVGAnimatedBooleanImpl._wrap(ptr) : super._wrap(ptr);

  bool get animVal() => _wrap(_ptr.animVal);

  bool get baseVal() => _wrap(_ptr.baseVal);

  void set baseVal(bool value) { _ptr.baseVal = _unwrap(value); }
}

class _SVGAnimatedEnumerationImpl extends _DOMTypeBase implements SVGAnimatedEnumeration {
  _SVGAnimatedEnumerationImpl._wrap(ptr) : super._wrap(ptr);

  int get animVal() => _wrap(_ptr.animVal);

  int get baseVal() => _wrap(_ptr.baseVal);

  void set baseVal(int value) { _ptr.baseVal = _unwrap(value); }
}

class _SVGAnimatedIntegerImpl extends _DOMTypeBase implements SVGAnimatedInteger {
  _SVGAnimatedIntegerImpl._wrap(ptr) : super._wrap(ptr);

  int get animVal() => _wrap(_ptr.animVal);

  int get baseVal() => _wrap(_ptr.baseVal);

  void set baseVal(int value) { _ptr.baseVal = _unwrap(value); }
}

class _SVGAnimatedLengthImpl extends _DOMTypeBase implements SVGAnimatedLength {
  _SVGAnimatedLengthImpl._wrap(ptr) : super._wrap(ptr);

  SVGLength get animVal() => _wrap(_ptr.animVal);

  SVGLength get baseVal() => _wrap(_ptr.baseVal);
}

class _SVGAnimatedLengthListImpl extends _DOMTypeBase implements SVGAnimatedLengthList {
  _SVGAnimatedLengthListImpl._wrap(ptr) : super._wrap(ptr);

  SVGLengthList get animVal() => _wrap(_ptr.animVal);

  SVGLengthList get baseVal() => _wrap(_ptr.baseVal);
}

class _SVGAnimatedNumberImpl extends _DOMTypeBase implements SVGAnimatedNumber {
  _SVGAnimatedNumberImpl._wrap(ptr) : super._wrap(ptr);

  num get animVal() => _wrap(_ptr.animVal);

  num get baseVal() => _wrap(_ptr.baseVal);

  void set baseVal(num value) { _ptr.baseVal = _unwrap(value); }
}

class _SVGAnimatedNumberListImpl extends _DOMTypeBase implements SVGAnimatedNumberList {
  _SVGAnimatedNumberListImpl._wrap(ptr) : super._wrap(ptr);

  SVGNumberList get animVal() => _wrap(_ptr.animVal);

  SVGNumberList get baseVal() => _wrap(_ptr.baseVal);
}

class _SVGAnimatedPreserveAspectRatioImpl extends _DOMTypeBase implements SVGAnimatedPreserveAspectRatio {
  _SVGAnimatedPreserveAspectRatioImpl._wrap(ptr) : super._wrap(ptr);

  SVGPreserveAspectRatio get animVal() => _wrap(_ptr.animVal);

  SVGPreserveAspectRatio get baseVal() => _wrap(_ptr.baseVal);
}

class _SVGAnimatedRectImpl extends _DOMTypeBase implements SVGAnimatedRect {
  _SVGAnimatedRectImpl._wrap(ptr) : super._wrap(ptr);

  SVGRect get animVal() => _wrap(_ptr.animVal);

  SVGRect get baseVal() => _wrap(_ptr.baseVal);
}

class _SVGAnimatedStringImpl extends _DOMTypeBase implements SVGAnimatedString {
  _SVGAnimatedStringImpl._wrap(ptr) : super._wrap(ptr);

  String get animVal() => _wrap(_ptr.animVal);

  String get baseVal() => _wrap(_ptr.baseVal);

  void set baseVal(String value) { _ptr.baseVal = _unwrap(value); }
}

class _SVGAnimatedTransformListImpl extends _DOMTypeBase implements SVGAnimatedTransformList {
  _SVGAnimatedTransformListImpl._wrap(ptr) : super._wrap(ptr);

  SVGTransformList get animVal() => _wrap(_ptr.animVal);

  SVGTransformList get baseVal() => _wrap(_ptr.baseVal);
}

class _SVGAnimationElementImpl extends _SVGElementImpl implements SVGAnimationElement {
  _SVGAnimationElementImpl._wrap(ptr) : super._wrap(ptr);

  SVGElement get targetElement() => _wrap(_ptr.targetElement);

  num getCurrentTime() {
    return _wrap(_ptr.getCurrentTime());
  }

  num getSimpleDuration() {
    return _wrap(_ptr.getSimpleDuration());
  }

  num getStartTime() {
    return _wrap(_ptr.getStartTime());
  }

  // From SVGTests

  SVGStringList get requiredExtensions() => _wrap(_ptr.requiredExtensions);

  SVGStringList get requiredFeatures() => _wrap(_ptr.requiredFeatures);

  SVGStringList get systemLanguage() => _wrap(_ptr.systemLanguage);

  bool hasExtension(String extension) {
    return _wrap(_ptr.hasExtension(_unwrap(extension)));
  }

  // From SVGExternalResourcesRequired

  SVGAnimatedBoolean get externalResourcesRequired() => _wrap(_ptr.externalResourcesRequired);

  // From ElementTimeControl

  void beginElement() {
    _ptr.beginElement();
    return;
  }

  void beginElementAt(num offset) {
    _ptr.beginElementAt(_unwrap(offset));
    return;
  }

  void endElement() {
    _ptr.endElement();
    return;
  }

  void endElementAt(num offset) {
    _ptr.endElementAt(_unwrap(offset));
    return;
  }
}

class _SVGCircleElementImpl extends _SVGElementImpl implements SVGCircleElement {
  _SVGCircleElementImpl._wrap(ptr) : super._wrap(ptr);

  SVGAnimatedLength get cx() => _wrap(_ptr.cx);

  SVGAnimatedLength get cy() => _wrap(_ptr.cy);

  SVGAnimatedLength get r() => _wrap(_ptr.r);

  // From SVGTests

  SVGStringList get requiredExtensions() => _wrap(_ptr.requiredExtensions);

  SVGStringList get requiredFeatures() => _wrap(_ptr.requiredFeatures);

  SVGStringList get systemLanguage() => _wrap(_ptr.systemLanguage);

  bool hasExtension(String extension) {
    return _wrap(_ptr.hasExtension(_unwrap(extension)));
  }

  // From SVGLangSpace

  String get xmllang() => _wrap(_ptr.xmllang);

  void set xmllang(String value) { _ptr.xmllang = _unwrap(value); }

  String get xmlspace() => _wrap(_ptr.xmlspace);

  void set xmlspace(String value) { _ptr.xmlspace = _unwrap(value); }

  // From SVGExternalResourcesRequired

  SVGAnimatedBoolean get externalResourcesRequired() => _wrap(_ptr.externalResourcesRequired);

  // From SVGStylable

  SVGAnimatedString get _svgClassName() => _wrap(_ptr.className);

  CSSStyleDeclaration get style() => _wrap(_ptr.style);

  CSSValue getPresentationAttribute(String name) {
    return _wrap(_ptr.getPresentationAttribute(_unwrap(name)));
  }

  // From SVGTransformable

  SVGAnimatedTransformList get transform() => _wrap(_ptr.transform);

  // From SVGLocatable

  SVGElement get farthestViewportElement() => _wrap(_ptr.farthestViewportElement);

  SVGElement get nearestViewportElement() => _wrap(_ptr.nearestViewportElement);

  SVGRect getBBox() {
    return _wrap(_ptr.getBBox());
  }

  SVGMatrix getCTM() {
    return _wrap(_ptr.getCTM());
  }

  SVGMatrix getScreenCTM() {
    return _wrap(_ptr.getScreenCTM());
  }

  SVGMatrix getTransformToElement(SVGElement element) {
    return _wrap(_ptr.getTransformToElement(_unwrap(element)));
  }
}

class _SVGClipPathElementImpl extends _SVGElementImpl implements SVGClipPathElement {
  _SVGClipPathElementImpl._wrap(ptr) : super._wrap(ptr);

  SVGAnimatedEnumeration get clipPathUnits() => _wrap(_ptr.clipPathUnits);

  // From SVGTests

  SVGStringList get requiredExtensions() => _wrap(_ptr.requiredExtensions);

  SVGStringList get requiredFeatures() => _wrap(_ptr.requiredFeatures);

  SVGStringList get systemLanguage() => _wrap(_ptr.systemLanguage);

  bool hasExtension(String extension) {
    return _wrap(_ptr.hasExtension(_unwrap(extension)));
  }

  // From SVGLangSpace

  String get xmllang() => _wrap(_ptr.xmllang);

  void set xmllang(String value) { _ptr.xmllang = _unwrap(value); }

  String get xmlspace() => _wrap(_ptr.xmlspace);

  void set xmlspace(String value) { _ptr.xmlspace = _unwrap(value); }

  // From SVGExternalResourcesRequired

  SVGAnimatedBoolean get externalResourcesRequired() => _wrap(_ptr.externalResourcesRequired);

  // From SVGStylable

  SVGAnimatedString get _svgClassName() => _wrap(_ptr.className);

  CSSStyleDeclaration get style() => _wrap(_ptr.style);

  CSSValue getPresentationAttribute(String name) {
    return _wrap(_ptr.getPresentationAttribute(_unwrap(name)));
  }

  // From SVGTransformable

  SVGAnimatedTransformList get transform() => _wrap(_ptr.transform);

  // From SVGLocatable

  SVGElement get farthestViewportElement() => _wrap(_ptr.farthestViewportElement);

  SVGElement get nearestViewportElement() => _wrap(_ptr.nearestViewportElement);

  SVGRect getBBox() {
    return _wrap(_ptr.getBBox());
  }

  SVGMatrix getCTM() {
    return _wrap(_ptr.getCTM());
  }

  SVGMatrix getScreenCTM() {
    return _wrap(_ptr.getScreenCTM());
  }

  SVGMatrix getTransformToElement(SVGElement element) {
    return _wrap(_ptr.getTransformToElement(_unwrap(element)));
  }
}

class _SVGColorImpl extends _CSSValueImpl implements SVGColor {
  _SVGColorImpl._wrap(ptr) : super._wrap(ptr);

  int get colorType() => _wrap(_ptr.colorType);

  RGBColor get rgbColor() => _wrap(_ptr.rgbColor);

  void setColor(int colorType, String rgbColor, String iccColor) {
    _ptr.setColor(_unwrap(colorType), _unwrap(rgbColor), _unwrap(iccColor));
    return;
  }

  void setRGBColor(String rgbColor) {
    _ptr.setRGBColor(_unwrap(rgbColor));
    return;
  }

  void setRGBColorICCColor(String rgbColor, String iccColor) {
    _ptr.setRGBColorICCColor(_unwrap(rgbColor), _unwrap(iccColor));
    return;
  }
}

class _SVGComponentTransferFunctionElementImpl extends _SVGElementImpl implements SVGComponentTransferFunctionElement {
  _SVGComponentTransferFunctionElementImpl._wrap(ptr) : super._wrap(ptr);

  SVGAnimatedNumber get amplitude() => _wrap(_ptr.amplitude);

  SVGAnimatedNumber get exponent() => _wrap(_ptr.exponent);

  SVGAnimatedNumber get intercept() => _wrap(_ptr.intercept);

  SVGAnimatedNumber get offset() => _wrap(_ptr.offset);

  SVGAnimatedNumber get slope() => _wrap(_ptr.slope);

  SVGAnimatedNumberList get tableValues() => _wrap(_ptr.tableValues);

  SVGAnimatedEnumeration get type() => _wrap(_ptr.type);
}

class _SVGCursorElementImpl extends _SVGElementImpl implements SVGCursorElement {
  _SVGCursorElementImpl._wrap(ptr) : super._wrap(ptr);

  SVGAnimatedLength get x() => _wrap(_ptr.x);

  SVGAnimatedLength get y() => _wrap(_ptr.y);

  // From SVGURIReference

  SVGAnimatedString get href() => _wrap(_ptr.href);

  // From SVGTests

  SVGStringList get requiredExtensions() => _wrap(_ptr.requiredExtensions);

  SVGStringList get requiredFeatures() => _wrap(_ptr.requiredFeatures);

  SVGStringList get systemLanguage() => _wrap(_ptr.systemLanguage);

  bool hasExtension(String extension) {
    return _wrap(_ptr.hasExtension(_unwrap(extension)));
  }

  // From SVGExternalResourcesRequired

  SVGAnimatedBoolean get externalResourcesRequired() => _wrap(_ptr.externalResourcesRequired);
}

class _SVGDefsElementImpl extends _SVGElementImpl implements SVGDefsElement {
  _SVGDefsElementImpl._wrap(ptr) : super._wrap(ptr);

  // From SVGTests

  SVGStringList get requiredExtensions() => _wrap(_ptr.requiredExtensions);

  SVGStringList get requiredFeatures() => _wrap(_ptr.requiredFeatures);

  SVGStringList get systemLanguage() => _wrap(_ptr.systemLanguage);

  bool hasExtension(String extension) {
    return _wrap(_ptr.hasExtension(_unwrap(extension)));
  }

  // From SVGLangSpace

  String get xmllang() => _wrap(_ptr.xmllang);

  void set xmllang(String value) { _ptr.xmllang = _unwrap(value); }

  String get xmlspace() => _wrap(_ptr.xmlspace);

  void set xmlspace(String value) { _ptr.xmlspace = _unwrap(value); }

  // From SVGExternalResourcesRequired

  SVGAnimatedBoolean get externalResourcesRequired() => _wrap(_ptr.externalResourcesRequired);

  // From SVGStylable

  SVGAnimatedString get _svgClassName() => _wrap(_ptr.className);

  CSSStyleDeclaration get style() => _wrap(_ptr.style);

  CSSValue getPresentationAttribute(String name) {
    return _wrap(_ptr.getPresentationAttribute(_unwrap(name)));
  }

  // From SVGTransformable

  SVGAnimatedTransformList get transform() => _wrap(_ptr.transform);

  // From SVGLocatable

  SVGElement get farthestViewportElement() => _wrap(_ptr.farthestViewportElement);

  SVGElement get nearestViewportElement() => _wrap(_ptr.nearestViewportElement);

  SVGRect getBBox() {
    return _wrap(_ptr.getBBox());
  }

  SVGMatrix getCTM() {
    return _wrap(_ptr.getCTM());
  }

  SVGMatrix getScreenCTM() {
    return _wrap(_ptr.getScreenCTM());
  }

  SVGMatrix getTransformToElement(SVGElement element) {
    return _wrap(_ptr.getTransformToElement(_unwrap(element)));
  }
}

class _SVGDescElementImpl extends _SVGElementImpl implements SVGDescElement {
  _SVGDescElementImpl._wrap(ptr) : super._wrap(ptr);

  // From SVGLangSpace

  String get xmllang() => _wrap(_ptr.xmllang);

  void set xmllang(String value) { _ptr.xmllang = _unwrap(value); }

  String get xmlspace() => _wrap(_ptr.xmlspace);

  void set xmlspace(String value) { _ptr.xmlspace = _unwrap(value); }

  // From SVGStylable

  SVGAnimatedString get _svgClassName() => _wrap(_ptr.className);

  CSSStyleDeclaration get style() => _wrap(_ptr.style);

  CSSValue getPresentationAttribute(String name) {
    return _wrap(_ptr.getPresentationAttribute(_unwrap(name)));
  }
}

class _SVGDocumentImpl extends _DocumentImpl implements SVGDocument {
  _SVGDocumentImpl._wrap(ptr) : super._wrap(ptr);

  SVGSVGElement get rootElement() => _wrap(_ptr.rootElement);

  Event _createEvent(String eventType) {
    return _wrap(_ptr.createEvent(_unwrap(eventType)));
  }
}
// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

class _AttributeClassSet extends _CssClassSet {
  _AttributeClassSet(element) : super(element);

  String _className() => _element.attributes['class'];

  void _write(Set s) {
    _element.attributes['class'] = _formatSet(s);
  }
}

class _SVGElementImpl extends _ElementImpl implements SVGElement {
  Set<String> get classes() {
    if (_cssClassSet === null) {
      _cssClassSet = new _AttributeClassSet(_ptr);
    }
    return _cssClassSet;
  }

  ElementList get elements() => new FilteredElementList(this);

  void set elements(Collection<Element> value) {
    final elements = this.elements;
    elements.clear();
    elements.addAll(value);
  }

  String get outerHTML() {
    final container = new Element.tag("div");
    final SVGElement clone = this.clone(true);
    container.elements.add(clone);
    return container.innerHTML;
  }

  String get innerHTML() {
    final container = new Element.tag("div");
    final SVGElement clone = this.clone(true);
    container.elements.addAll(clone.elements);
    return container.innerHTML;
  }

  void set innerHTML(String svg) {
    final container = new Element.tag("div");
    // Wrap the SVG string in <svg> so that SVGElements are created, rather than
    // HTMLElements.
    container.innerHTML = '<svg version="1.1">$svg</svg>';
    this.elements = container.elements.first.elements;
  }

  _SVGElementImpl._wrap(ptr) : super._wrap(ptr);

  String get id() => _wrap(_ptr.id);

  void set id(String value) { _ptr.id = _unwrap(value); }

  SVGSVGElement get ownerSVGElement() => _wrap(_ptr.ownerSVGElement);

  SVGElement get viewportElement() => _wrap(_ptr.viewportElement);

  String get xmlbase() => _wrap(_ptr.xmlbase);

  void set xmlbase(String value) { _ptr.xmlbase = _unwrap(value); }

}

class _SVGElementInstanceImpl extends _EventTargetImpl implements SVGElementInstance {
  _SVGElementInstanceImpl._wrap(ptr) : super._wrap(ptr);

  _SVGElementInstanceEventsImpl get on() {
    if (_on == null) _on = new _SVGElementInstanceEventsImpl(this);
    return _on;
  }

  SVGElementInstanceList get childNodes() => _wrap(_ptr.childNodes);

  SVGElement get correspondingElement() => _wrap(_ptr.correspondingElement);

  SVGUseElement get correspondingUseElement() => _wrap(_ptr.correspondingUseElement);

  SVGElementInstance get firstChild() => _wrap(_ptr.firstChild);

  SVGElementInstance get lastChild() => _wrap(_ptr.lastChild);

  SVGElementInstance get nextSibling() => _wrap(_ptr.nextSibling);

  SVGElementInstance get parentNode() => _wrap(_ptr.parentNode);

  SVGElementInstance get previousSibling() => _wrap(_ptr.previousSibling);

  void _addEventListener(String type, EventListener listener, [bool useCapture = null]) {
    if (useCapture === null) {
      _ptr.addEventListener(_unwrap(type), _unwrap(listener));
      return;
    } else {
      _ptr.addEventListener(_unwrap(type), _unwrap(listener), _unwrap(useCapture));
      return;
    }
  }

  bool _dispatchEvent(Event event) {
    return _wrap(_ptr.dispatchEvent(_unwrap(event)));
  }

  void _removeEventListener(String type, EventListener listener, [bool useCapture = null]) {
    if (useCapture === null) {
      _ptr.removeEventListener(_unwrap(type), _unwrap(listener));
      return;
    } else {
      _ptr.removeEventListener(_unwrap(type), _unwrap(listener), _unwrap(useCapture));
      return;
    }
  }
}

class _SVGElementInstanceEventsImpl extends _EventsImpl implements SVGElementInstanceEvents {
  _SVGElementInstanceEventsImpl(_ptr) : super(_ptr);

  EventListenerList get abort() => _get('abort');

  EventListenerList get beforeCopy() => _get('beforecopy');

  EventListenerList get beforeCut() => _get('beforecut');

  EventListenerList get beforePaste() => _get('beforepaste');

  EventListenerList get blur() => _get('blur');

  EventListenerList get change() => _get('change');

  EventListenerList get click() => _get('click');

  EventListenerList get contextMenu() => _get('contextmenu');

  EventListenerList get copy() => _get('copy');

  EventListenerList get cut() => _get('cut');

  EventListenerList get doubleClick() => _get('dblclick');

  EventListenerList get drag() => _get('drag');

  EventListenerList get dragEnd() => _get('dragend');

  EventListenerList get dragEnter() => _get('dragenter');

  EventListenerList get dragLeave() => _get('dragleave');

  EventListenerList get dragOver() => _get('dragover');

  EventListenerList get dragStart() => _get('dragstart');

  EventListenerList get drop() => _get('drop');

  EventListenerList get error() => _get('error');

  EventListenerList get focus() => _get('focus');

  EventListenerList get input() => _get('input');

  EventListenerList get keyDown() => _get('keydown');

  EventListenerList get keyPress() => _get('keypress');

  EventListenerList get keyUp() => _get('keyup');

  EventListenerList get load() => _get('load');

  EventListenerList get mouseDown() => _get('mousedown');

  EventListenerList get mouseMove() => _get('mousemove');

  EventListenerList get mouseOut() => _get('mouseout');

  EventListenerList get mouseOver() => _get('mouseover');

  EventListenerList get mouseUp() => _get('mouseup');

  EventListenerList get mouseWheel() => _get('mousewheel');

  EventListenerList get paste() => _get('paste');

  EventListenerList get reset() => _get('reset');

  EventListenerList get resize() => _get('resize');

  EventListenerList get scroll() => _get('scroll');

  EventListenerList get search() => _get('search');

  EventListenerList get select() => _get('select');

  EventListenerList get selectStart() => _get('selectstart');

  EventListenerList get submit() => _get('submit');

  EventListenerList get unload() => _get('unload');
}

class _SVGElementInstanceListImpl extends _DOMTypeBase implements SVGElementInstanceList {
  _SVGElementInstanceListImpl._wrap(ptr) : super._wrap(ptr);

  int get length() => _wrap(_ptr.length);

  SVGElementInstance item(int index) {
    return _wrap(_ptr.item(_unwrap(index)));
  }
}

class _SVGEllipseElementImpl extends _SVGElementImpl implements SVGEllipseElement {
  _SVGEllipseElementImpl._wrap(ptr) : super._wrap(ptr);

  SVGAnimatedLength get cx() => _wrap(_ptr.cx);

  SVGAnimatedLength get cy() => _wrap(_ptr.cy);

  SVGAnimatedLength get rx() => _wrap(_ptr.rx);

  SVGAnimatedLength get ry() => _wrap(_ptr.ry);

  // From SVGTests

  SVGStringList get requiredExtensions() => _wrap(_ptr.requiredExtensions);

  SVGStringList get requiredFeatures() => _wrap(_ptr.requiredFeatures);

  SVGStringList get systemLanguage() => _wrap(_ptr.systemLanguage);

  bool hasExtension(String extension) {
    return _wrap(_ptr.hasExtension(_unwrap(extension)));
  }

  // From SVGLangSpace

  String get xmllang() => _wrap(_ptr.xmllang);

  void set xmllang(String value) { _ptr.xmllang = _unwrap(value); }

  String get xmlspace() => _wrap(_ptr.xmlspace);

  void set xmlspace(String value) { _ptr.xmlspace = _unwrap(value); }

  // From SVGExternalResourcesRequired

  SVGAnimatedBoolean get externalResourcesRequired() => _wrap(_ptr.externalResourcesRequired);

  // From SVGStylable

  SVGAnimatedString get _svgClassName() => _wrap(_ptr.className);

  CSSStyleDeclaration get style() => _wrap(_ptr.style);

  CSSValue getPresentationAttribute(String name) {
    return _wrap(_ptr.getPresentationAttribute(_unwrap(name)));
  }

  // From SVGTransformable

  SVGAnimatedTransformList get transform() => _wrap(_ptr.transform);

  // From SVGLocatable

  SVGElement get farthestViewportElement() => _wrap(_ptr.farthestViewportElement);

  SVGElement get nearestViewportElement() => _wrap(_ptr.nearestViewportElement);

  SVGRect getBBox() {
    return _wrap(_ptr.getBBox());
  }

  SVGMatrix getCTM() {
    return _wrap(_ptr.getCTM());
  }

  SVGMatrix getScreenCTM() {
    return _wrap(_ptr.getScreenCTM());
  }

  SVGMatrix getTransformToElement(SVGElement element) {
    return _wrap(_ptr.getTransformToElement(_unwrap(element)));
  }
}

class _SVGExceptionImpl extends _DOMTypeBase implements SVGException {
  _SVGExceptionImpl._wrap(ptr) : super._wrap(ptr);

  int get code() => _wrap(_ptr.code);

  String get message() => _wrap(_ptr.message);

  String get name() => _wrap(_ptr.name);

  String toString() {
    return _wrap(_ptr.toString());
  }
}

class _SVGExternalResourcesRequiredImpl extends _DOMTypeBase implements SVGExternalResourcesRequired {
  _SVGExternalResourcesRequiredImpl._wrap(ptr) : super._wrap(ptr);

  SVGAnimatedBoolean get externalResourcesRequired() => _wrap(_ptr.externalResourcesRequired);
}

class _SVGFEBlendElementImpl extends _SVGElementImpl implements SVGFEBlendElement {
  _SVGFEBlendElementImpl._wrap(ptr) : super._wrap(ptr);

  SVGAnimatedString get in1() => _wrap(_ptr.in1);

  SVGAnimatedString get in2() => _wrap(_ptr.in2);

  SVGAnimatedEnumeration get mode() => _wrap(_ptr.mode);

  // From SVGFilterPrimitiveStandardAttributes

  SVGAnimatedLength get height() => _wrap(_ptr.height);

  SVGAnimatedString get result() => _wrap(_ptr.result);

  SVGAnimatedLength get width() => _wrap(_ptr.width);

  SVGAnimatedLength get x() => _wrap(_ptr.x);

  SVGAnimatedLength get y() => _wrap(_ptr.y);

  // From SVGStylable

  SVGAnimatedString get _svgClassName() => _wrap(_ptr.className);

  CSSStyleDeclaration get style() => _wrap(_ptr.style);

  CSSValue getPresentationAttribute(String name) {
    return _wrap(_ptr.getPresentationAttribute(_unwrap(name)));
  }
}

class _SVGFEColorMatrixElementImpl extends _SVGElementImpl implements SVGFEColorMatrixElement {
  _SVGFEColorMatrixElementImpl._wrap(ptr) : super._wrap(ptr);

  SVGAnimatedString get in1() => _wrap(_ptr.in1);

  SVGAnimatedEnumeration get type() => _wrap(_ptr.type);

  SVGAnimatedNumberList get values() => _wrap(_ptr.values);

  // From SVGFilterPrimitiveStandardAttributes

  SVGAnimatedLength get height() => _wrap(_ptr.height);

  SVGAnimatedString get result() => _wrap(_ptr.result);

  SVGAnimatedLength get width() => _wrap(_ptr.width);

  SVGAnimatedLength get x() => _wrap(_ptr.x);

  SVGAnimatedLength get y() => _wrap(_ptr.y);

  // From SVGStylable

  SVGAnimatedString get _svgClassName() => _wrap(_ptr.className);

  CSSStyleDeclaration get style() => _wrap(_ptr.style);

  CSSValue getPresentationAttribute(String name) {
    return _wrap(_ptr.getPresentationAttribute(_unwrap(name)));
  }
}

class _SVGFEComponentTransferElementImpl extends _SVGElementImpl implements SVGFEComponentTransferElement {
  _SVGFEComponentTransferElementImpl._wrap(ptr) : super._wrap(ptr);

  SVGAnimatedString get in1() => _wrap(_ptr.in1);

  // From SVGFilterPrimitiveStandardAttributes

  SVGAnimatedLength get height() => _wrap(_ptr.height);

  SVGAnimatedString get result() => _wrap(_ptr.result);

  SVGAnimatedLength get width() => _wrap(_ptr.width);

  SVGAnimatedLength get x() => _wrap(_ptr.x);

  SVGAnimatedLength get y() => _wrap(_ptr.y);

  // From SVGStylable

  SVGAnimatedString get _svgClassName() => _wrap(_ptr.className);

  CSSStyleDeclaration get style() => _wrap(_ptr.style);

  CSSValue getPresentationAttribute(String name) {
    return _wrap(_ptr.getPresentationAttribute(_unwrap(name)));
  }
}

class _SVGFECompositeElementImpl extends _SVGElementImpl implements SVGFECompositeElement {
  _SVGFECompositeElementImpl._wrap(ptr) : super._wrap(ptr);

  SVGAnimatedString get in1() => _wrap(_ptr.in1);

  SVGAnimatedString get in2() => _wrap(_ptr.in2);

  SVGAnimatedNumber get k1() => _wrap(_ptr.k1);

  SVGAnimatedNumber get k2() => _wrap(_ptr.k2);

  SVGAnimatedNumber get k3() => _wrap(_ptr.k3);

  SVGAnimatedNumber get k4() => _wrap(_ptr.k4);

  SVGAnimatedEnumeration get operator() => _wrap(_ptr.operator);

  // From SVGFilterPrimitiveStandardAttributes

  SVGAnimatedLength get height() => _wrap(_ptr.height);

  SVGAnimatedString get result() => _wrap(_ptr.result);

  SVGAnimatedLength get width() => _wrap(_ptr.width);

  SVGAnimatedLength get x() => _wrap(_ptr.x);

  SVGAnimatedLength get y() => _wrap(_ptr.y);

  // From SVGStylable

  SVGAnimatedString get _svgClassName() => _wrap(_ptr.className);

  CSSStyleDeclaration get style() => _wrap(_ptr.style);

  CSSValue getPresentationAttribute(String name) {
    return _wrap(_ptr.getPresentationAttribute(_unwrap(name)));
  }
}

class _SVGFEConvolveMatrixElementImpl extends _SVGElementImpl implements SVGFEConvolveMatrixElement {
  _SVGFEConvolveMatrixElementImpl._wrap(ptr) : super._wrap(ptr);

  SVGAnimatedNumber get bias() => _wrap(_ptr.bias);

  SVGAnimatedNumber get divisor() => _wrap(_ptr.divisor);

  SVGAnimatedEnumeration get edgeMode() => _wrap(_ptr.edgeMode);

  SVGAnimatedString get in1() => _wrap(_ptr.in1);

  SVGAnimatedNumberList get kernelMatrix() => _wrap(_ptr.kernelMatrix);

  SVGAnimatedNumber get kernelUnitLengthX() => _wrap(_ptr.kernelUnitLengthX);

  SVGAnimatedNumber get kernelUnitLengthY() => _wrap(_ptr.kernelUnitLengthY);

  SVGAnimatedInteger get orderX() => _wrap(_ptr.orderX);

  SVGAnimatedInteger get orderY() => _wrap(_ptr.orderY);

  SVGAnimatedBoolean get preserveAlpha() => _wrap(_ptr.preserveAlpha);

  SVGAnimatedInteger get targetX() => _wrap(_ptr.targetX);

  SVGAnimatedInteger get targetY() => _wrap(_ptr.targetY);

  // From SVGFilterPrimitiveStandardAttributes

  SVGAnimatedLength get height() => _wrap(_ptr.height);

  SVGAnimatedString get result() => _wrap(_ptr.result);

  SVGAnimatedLength get width() => _wrap(_ptr.width);

  SVGAnimatedLength get x() => _wrap(_ptr.x);

  SVGAnimatedLength get y() => _wrap(_ptr.y);

  // From SVGStylable

  SVGAnimatedString get _svgClassName() => _wrap(_ptr.className);

  CSSStyleDeclaration get style() => _wrap(_ptr.style);

  CSSValue getPresentationAttribute(String name) {
    return _wrap(_ptr.getPresentationAttribute(_unwrap(name)));
  }
}

class _SVGFEDiffuseLightingElementImpl extends _SVGElementImpl implements SVGFEDiffuseLightingElement {
  _SVGFEDiffuseLightingElementImpl._wrap(ptr) : super._wrap(ptr);

  SVGAnimatedNumber get diffuseConstant() => _wrap(_ptr.diffuseConstant);

  SVGAnimatedString get in1() => _wrap(_ptr.in1);

  SVGAnimatedNumber get kernelUnitLengthX() => _wrap(_ptr.kernelUnitLengthX);

  SVGAnimatedNumber get kernelUnitLengthY() => _wrap(_ptr.kernelUnitLengthY);

  SVGAnimatedNumber get surfaceScale() => _wrap(_ptr.surfaceScale);

  // From SVGFilterPrimitiveStandardAttributes

  SVGAnimatedLength get height() => _wrap(_ptr.height);

  SVGAnimatedString get result() => _wrap(_ptr.result);

  SVGAnimatedLength get width() => _wrap(_ptr.width);

  SVGAnimatedLength get x() => _wrap(_ptr.x);

  SVGAnimatedLength get y() => _wrap(_ptr.y);

  // From SVGStylable

  SVGAnimatedString get _svgClassName() => _wrap(_ptr.className);

  CSSStyleDeclaration get style() => _wrap(_ptr.style);

  CSSValue getPresentationAttribute(String name) {
    return _wrap(_ptr.getPresentationAttribute(_unwrap(name)));
  }
}

class _SVGFEDisplacementMapElementImpl extends _SVGElementImpl implements SVGFEDisplacementMapElement {
  _SVGFEDisplacementMapElementImpl._wrap(ptr) : super._wrap(ptr);

  SVGAnimatedString get in1() => _wrap(_ptr.in1);

  SVGAnimatedString get in2() => _wrap(_ptr.in2);

  SVGAnimatedNumber get scale() => _wrap(_ptr.scale);

  SVGAnimatedEnumeration get xChannelSelector() => _wrap(_ptr.xChannelSelector);

  SVGAnimatedEnumeration get yChannelSelector() => _wrap(_ptr.yChannelSelector);

  // From SVGFilterPrimitiveStandardAttributes

  SVGAnimatedLength get height() => _wrap(_ptr.height);

  SVGAnimatedString get result() => _wrap(_ptr.result);

  SVGAnimatedLength get width() => _wrap(_ptr.width);

  SVGAnimatedLength get x() => _wrap(_ptr.x);

  SVGAnimatedLength get y() => _wrap(_ptr.y);

  // From SVGStylable

  SVGAnimatedString get _svgClassName() => _wrap(_ptr.className);

  CSSStyleDeclaration get style() => _wrap(_ptr.style);

  CSSValue getPresentationAttribute(String name) {
    return _wrap(_ptr.getPresentationAttribute(_unwrap(name)));
  }
}

class _SVGFEDistantLightElementImpl extends _SVGElementImpl implements SVGFEDistantLightElement {
  _SVGFEDistantLightElementImpl._wrap(ptr) : super._wrap(ptr);

  SVGAnimatedNumber get azimuth() => _wrap(_ptr.azimuth);

  SVGAnimatedNumber get elevation() => _wrap(_ptr.elevation);
}

class _SVGFEDropShadowElementImpl extends _SVGElementImpl implements SVGFEDropShadowElement {
  _SVGFEDropShadowElementImpl._wrap(ptr) : super._wrap(ptr);

  SVGAnimatedNumber get dx() => _wrap(_ptr.dx);

  SVGAnimatedNumber get dy() => _wrap(_ptr.dy);

  SVGAnimatedString get in1() => _wrap(_ptr.in1);

  SVGAnimatedNumber get stdDeviationX() => _wrap(_ptr.stdDeviationX);

  SVGAnimatedNumber get stdDeviationY() => _wrap(_ptr.stdDeviationY);

  void setStdDeviation(num stdDeviationX, num stdDeviationY) {
    _ptr.setStdDeviation(_unwrap(stdDeviationX), _unwrap(stdDeviationY));
    return;
  }

  // From SVGFilterPrimitiveStandardAttributes

  SVGAnimatedLength get height() => _wrap(_ptr.height);

  SVGAnimatedString get result() => _wrap(_ptr.result);

  SVGAnimatedLength get width() => _wrap(_ptr.width);

  SVGAnimatedLength get x() => _wrap(_ptr.x);

  SVGAnimatedLength get y() => _wrap(_ptr.y);

  // From SVGStylable

  SVGAnimatedString get _svgClassName() => _wrap(_ptr.className);

  CSSStyleDeclaration get style() => _wrap(_ptr.style);

  CSSValue getPresentationAttribute(String name) {
    return _wrap(_ptr.getPresentationAttribute(_unwrap(name)));
  }
}

class _SVGFEFloodElementImpl extends _SVGElementImpl implements SVGFEFloodElement {
  _SVGFEFloodElementImpl._wrap(ptr) : super._wrap(ptr);

  // From SVGFilterPrimitiveStandardAttributes

  SVGAnimatedLength get height() => _wrap(_ptr.height);

  SVGAnimatedString get result() => _wrap(_ptr.result);

  SVGAnimatedLength get width() => _wrap(_ptr.width);

  SVGAnimatedLength get x() => _wrap(_ptr.x);

  SVGAnimatedLength get y() => _wrap(_ptr.y);

  // From SVGStylable

  SVGAnimatedString get _svgClassName() => _wrap(_ptr.className);

  CSSStyleDeclaration get style() => _wrap(_ptr.style);

  CSSValue getPresentationAttribute(String name) {
    return _wrap(_ptr.getPresentationAttribute(_unwrap(name)));
  }
}

class _SVGFEFuncAElementImpl extends _SVGComponentTransferFunctionElementImpl implements SVGFEFuncAElement {
  _SVGFEFuncAElementImpl._wrap(ptr) : super._wrap(ptr);
}

class _SVGFEFuncBElementImpl extends _SVGComponentTransferFunctionElementImpl implements SVGFEFuncBElement {
  _SVGFEFuncBElementImpl._wrap(ptr) : super._wrap(ptr);
}

class _SVGFEFuncGElementImpl extends _SVGComponentTransferFunctionElementImpl implements SVGFEFuncGElement {
  _SVGFEFuncGElementImpl._wrap(ptr) : super._wrap(ptr);
}

class _SVGFEFuncRElementImpl extends _SVGComponentTransferFunctionElementImpl implements SVGFEFuncRElement {
  _SVGFEFuncRElementImpl._wrap(ptr) : super._wrap(ptr);
}

class _SVGFEGaussianBlurElementImpl extends _SVGElementImpl implements SVGFEGaussianBlurElement {
  _SVGFEGaussianBlurElementImpl._wrap(ptr) : super._wrap(ptr);

  SVGAnimatedString get in1() => _wrap(_ptr.in1);

  SVGAnimatedNumber get stdDeviationX() => _wrap(_ptr.stdDeviationX);

  SVGAnimatedNumber get stdDeviationY() => _wrap(_ptr.stdDeviationY);

  void setStdDeviation(num stdDeviationX, num stdDeviationY) {
    _ptr.setStdDeviation(_unwrap(stdDeviationX), _unwrap(stdDeviationY));
    return;
  }

  // From SVGFilterPrimitiveStandardAttributes

  SVGAnimatedLength get height() => _wrap(_ptr.height);

  SVGAnimatedString get result() => _wrap(_ptr.result);

  SVGAnimatedLength get width() => _wrap(_ptr.width);

  SVGAnimatedLength get x() => _wrap(_ptr.x);

  SVGAnimatedLength get y() => _wrap(_ptr.y);

  // From SVGStylable

  SVGAnimatedString get _svgClassName() => _wrap(_ptr.className);

  CSSStyleDeclaration get style() => _wrap(_ptr.style);

  CSSValue getPresentationAttribute(String name) {
    return _wrap(_ptr.getPresentationAttribute(_unwrap(name)));
  }
}

class _SVGFEImageElementImpl extends _SVGElementImpl implements SVGFEImageElement {
  _SVGFEImageElementImpl._wrap(ptr) : super._wrap(ptr);

  SVGAnimatedPreserveAspectRatio get preserveAspectRatio() => _wrap(_ptr.preserveAspectRatio);

  // From SVGURIReference

  SVGAnimatedString get href() => _wrap(_ptr.href);

  // From SVGLangSpace

  String get xmllang() => _wrap(_ptr.xmllang);

  void set xmllang(String value) { _ptr.xmllang = _unwrap(value); }

  String get xmlspace() => _wrap(_ptr.xmlspace);

  void set xmlspace(String value) { _ptr.xmlspace = _unwrap(value); }

  // From SVGExternalResourcesRequired

  SVGAnimatedBoolean get externalResourcesRequired() => _wrap(_ptr.externalResourcesRequired);

  // From SVGFilterPrimitiveStandardAttributes

  SVGAnimatedLength get height() => _wrap(_ptr.height);

  SVGAnimatedString get result() => _wrap(_ptr.result);

  SVGAnimatedLength get width() => _wrap(_ptr.width);

  SVGAnimatedLength get x() => _wrap(_ptr.x);

  SVGAnimatedLength get y() => _wrap(_ptr.y);

  // From SVGStylable

  SVGAnimatedString get _svgClassName() => _wrap(_ptr.className);

  CSSStyleDeclaration get style() => _wrap(_ptr.style);

  CSSValue getPresentationAttribute(String name) {
    return _wrap(_ptr.getPresentationAttribute(_unwrap(name)));
  }
}

class _SVGFEMergeElementImpl extends _SVGElementImpl implements SVGFEMergeElement {
  _SVGFEMergeElementImpl._wrap(ptr) : super._wrap(ptr);

  // From SVGFilterPrimitiveStandardAttributes

  SVGAnimatedLength get height() => _wrap(_ptr.height);

  SVGAnimatedString get result() => _wrap(_ptr.result);

  SVGAnimatedLength get width() => _wrap(_ptr.width);

  SVGAnimatedLength get x() => _wrap(_ptr.x);

  SVGAnimatedLength get y() => _wrap(_ptr.y);

  // From SVGStylable

  SVGAnimatedString get _svgClassName() => _wrap(_ptr.className);

  CSSStyleDeclaration get style() => _wrap(_ptr.style);

  CSSValue getPresentationAttribute(String name) {
    return _wrap(_ptr.getPresentationAttribute(_unwrap(name)));
  }
}

class _SVGFEMergeNodeElementImpl extends _SVGElementImpl implements SVGFEMergeNodeElement {
  _SVGFEMergeNodeElementImpl._wrap(ptr) : super._wrap(ptr);

  SVGAnimatedString get in1() => _wrap(_ptr.in1);
}

class _SVGFEMorphologyElementImpl extends _SVGElementImpl implements SVGFEMorphologyElement {
  _SVGFEMorphologyElementImpl._wrap(ptr) : super._wrap(ptr);

  SVGAnimatedString get in1() => _wrap(_ptr.in1);

  SVGAnimatedEnumeration get operator() => _wrap(_ptr.operator);

  SVGAnimatedNumber get radiusX() => _wrap(_ptr.radiusX);

  SVGAnimatedNumber get radiusY() => _wrap(_ptr.radiusY);

  void setRadius(num radiusX, num radiusY) {
    _ptr.setRadius(_unwrap(radiusX), _unwrap(radiusY));
    return;
  }

  // From SVGFilterPrimitiveStandardAttributes

  SVGAnimatedLength get height() => _wrap(_ptr.height);

  SVGAnimatedString get result() => _wrap(_ptr.result);

  SVGAnimatedLength get width() => _wrap(_ptr.width);

  SVGAnimatedLength get x() => _wrap(_ptr.x);

  SVGAnimatedLength get y() => _wrap(_ptr.y);

  // From SVGStylable

  SVGAnimatedString get _svgClassName() => _wrap(_ptr.className);

  CSSStyleDeclaration get style() => _wrap(_ptr.style);

  CSSValue getPresentationAttribute(String name) {
    return _wrap(_ptr.getPresentationAttribute(_unwrap(name)));
  }
}

class _SVGFEOffsetElementImpl extends _SVGElementImpl implements SVGFEOffsetElement {
  _SVGFEOffsetElementImpl._wrap(ptr) : super._wrap(ptr);

  SVGAnimatedNumber get dx() => _wrap(_ptr.dx);

  SVGAnimatedNumber get dy() => _wrap(_ptr.dy);

  SVGAnimatedString get in1() => _wrap(_ptr.in1);

  // From SVGFilterPrimitiveStandardAttributes

  SVGAnimatedLength get height() => _wrap(_ptr.height);

  SVGAnimatedString get result() => _wrap(_ptr.result);

  SVGAnimatedLength get width() => _wrap(_ptr.width);

  SVGAnimatedLength get x() => _wrap(_ptr.x);

  SVGAnimatedLength get y() => _wrap(_ptr.y);

  // From SVGStylable

  SVGAnimatedString get _svgClassName() => _wrap(_ptr.className);

  CSSStyleDeclaration get style() => _wrap(_ptr.style);

  CSSValue getPresentationAttribute(String name) {
    return _wrap(_ptr.getPresentationAttribute(_unwrap(name)));
  }
}

class _SVGFEPointLightElementImpl extends _SVGElementImpl implements SVGFEPointLightElement {
  _SVGFEPointLightElementImpl._wrap(ptr) : super._wrap(ptr);

  SVGAnimatedNumber get x() => _wrap(_ptr.x);

  SVGAnimatedNumber get y() => _wrap(_ptr.y);

  SVGAnimatedNumber get z() => _wrap(_ptr.z);
}

class _SVGFESpecularLightingElementImpl extends _SVGElementImpl implements SVGFESpecularLightingElement {
  _SVGFESpecularLightingElementImpl._wrap(ptr) : super._wrap(ptr);

  SVGAnimatedString get in1() => _wrap(_ptr.in1);

  SVGAnimatedNumber get specularConstant() => _wrap(_ptr.specularConstant);

  SVGAnimatedNumber get specularExponent() => _wrap(_ptr.specularExponent);

  SVGAnimatedNumber get surfaceScale() => _wrap(_ptr.surfaceScale);

  // From SVGFilterPrimitiveStandardAttributes

  SVGAnimatedLength get height() => _wrap(_ptr.height);

  SVGAnimatedString get result() => _wrap(_ptr.result);

  SVGAnimatedLength get width() => _wrap(_ptr.width);

  SVGAnimatedLength get x() => _wrap(_ptr.x);

  SVGAnimatedLength get y() => _wrap(_ptr.y);

  // From SVGStylable

  SVGAnimatedString get _svgClassName() => _wrap(_ptr.className);

  CSSStyleDeclaration get style() => _wrap(_ptr.style);

  CSSValue getPresentationAttribute(String name) {
    return _wrap(_ptr.getPresentationAttribute(_unwrap(name)));
  }
}

class _SVGFESpotLightElementImpl extends _SVGElementImpl implements SVGFESpotLightElement {
  _SVGFESpotLightElementImpl._wrap(ptr) : super._wrap(ptr);

  SVGAnimatedNumber get limitingConeAngle() => _wrap(_ptr.limitingConeAngle);

  SVGAnimatedNumber get pointsAtX() => _wrap(_ptr.pointsAtX);

  SVGAnimatedNumber get pointsAtY() => _wrap(_ptr.pointsAtY);

  SVGAnimatedNumber get pointsAtZ() => _wrap(_ptr.pointsAtZ);

  SVGAnimatedNumber get specularExponent() => _wrap(_ptr.specularExponent);

  SVGAnimatedNumber get x() => _wrap(_ptr.x);

  SVGAnimatedNumber get y() => _wrap(_ptr.y);

  SVGAnimatedNumber get z() => _wrap(_ptr.z);
}

class _SVGFETileElementImpl extends _SVGElementImpl implements SVGFETileElement {
  _SVGFETileElementImpl._wrap(ptr) : super._wrap(ptr);

  SVGAnimatedString get in1() => _wrap(_ptr.in1);

  // From SVGFilterPrimitiveStandardAttributes

  SVGAnimatedLength get height() => _wrap(_ptr.height);

  SVGAnimatedString get result() => _wrap(_ptr.result);

  SVGAnimatedLength get width() => _wrap(_ptr.width);

  SVGAnimatedLength get x() => _wrap(_ptr.x);

  SVGAnimatedLength get y() => _wrap(_ptr.y);

  // From SVGStylable

  SVGAnimatedString get _svgClassName() => _wrap(_ptr.className);

  CSSStyleDeclaration get style() => _wrap(_ptr.style);

  CSSValue getPresentationAttribute(String name) {
    return _wrap(_ptr.getPresentationAttribute(_unwrap(name)));
  }
}

class _SVGFETurbulenceElementImpl extends _SVGElementImpl implements SVGFETurbulenceElement {
  _SVGFETurbulenceElementImpl._wrap(ptr) : super._wrap(ptr);

  SVGAnimatedNumber get baseFrequencyX() => _wrap(_ptr.baseFrequencyX);

  SVGAnimatedNumber get baseFrequencyY() => _wrap(_ptr.baseFrequencyY);

  SVGAnimatedInteger get numOctaves() => _wrap(_ptr.numOctaves);

  SVGAnimatedNumber get seed() => _wrap(_ptr.seed);

  SVGAnimatedEnumeration get stitchTiles() => _wrap(_ptr.stitchTiles);

  SVGAnimatedEnumeration get type() => _wrap(_ptr.type);

  // From SVGFilterPrimitiveStandardAttributes

  SVGAnimatedLength get height() => _wrap(_ptr.height);

  SVGAnimatedString get result() => _wrap(_ptr.result);

  SVGAnimatedLength get width() => _wrap(_ptr.width);

  SVGAnimatedLength get x() => _wrap(_ptr.x);

  SVGAnimatedLength get y() => _wrap(_ptr.y);

  // From SVGStylable

  SVGAnimatedString get _svgClassName() => _wrap(_ptr.className);

  CSSStyleDeclaration get style() => _wrap(_ptr.style);

  CSSValue getPresentationAttribute(String name) {
    return _wrap(_ptr.getPresentationAttribute(_unwrap(name)));
  }
}

class _SVGFilterElementImpl extends _SVGElementImpl implements SVGFilterElement {
  _SVGFilterElementImpl._wrap(ptr) : super._wrap(ptr);

  SVGAnimatedInteger get filterResX() => _wrap(_ptr.filterResX);

  SVGAnimatedInteger get filterResY() => _wrap(_ptr.filterResY);

  SVGAnimatedEnumeration get filterUnits() => _wrap(_ptr.filterUnits);

  SVGAnimatedLength get height() => _wrap(_ptr.height);

  SVGAnimatedEnumeration get primitiveUnits() => _wrap(_ptr.primitiveUnits);

  SVGAnimatedLength get width() => _wrap(_ptr.width);

  SVGAnimatedLength get x() => _wrap(_ptr.x);

  SVGAnimatedLength get y() => _wrap(_ptr.y);

  void setFilterRes(int filterResX, int filterResY) {
    _ptr.setFilterRes(_unwrap(filterResX), _unwrap(filterResY));
    return;
  }

  // From SVGURIReference

  SVGAnimatedString get href() => _wrap(_ptr.href);

  // From SVGLangSpace

  String get xmllang() => _wrap(_ptr.xmllang);

  void set xmllang(String value) { _ptr.xmllang = _unwrap(value); }

  String get xmlspace() => _wrap(_ptr.xmlspace);

  void set xmlspace(String value) { _ptr.xmlspace = _unwrap(value); }

  // From SVGExternalResourcesRequired

  SVGAnimatedBoolean get externalResourcesRequired() => _wrap(_ptr.externalResourcesRequired);

  // From SVGStylable

  SVGAnimatedString get _svgClassName() => _wrap(_ptr.className);

  CSSStyleDeclaration get style() => _wrap(_ptr.style);

  CSSValue getPresentationAttribute(String name) {
    return _wrap(_ptr.getPresentationAttribute(_unwrap(name)));
  }
}

class _SVGFilterPrimitiveStandardAttributesImpl extends _SVGStylableImpl implements SVGFilterPrimitiveStandardAttributes {
  _SVGFilterPrimitiveStandardAttributesImpl._wrap(ptr) : super._wrap(ptr);

  SVGAnimatedLength get height() => _wrap(_ptr.height);

  SVGAnimatedString get result() => _wrap(_ptr.result);

  SVGAnimatedLength get width() => _wrap(_ptr.width);

  SVGAnimatedLength get x() => _wrap(_ptr.x);

  SVGAnimatedLength get y() => _wrap(_ptr.y);
}

class _SVGFitToViewBoxImpl extends _DOMTypeBase implements SVGFitToViewBox {
  _SVGFitToViewBoxImpl._wrap(ptr) : super._wrap(ptr);

  SVGAnimatedPreserveAspectRatio get preserveAspectRatio() => _wrap(_ptr.preserveAspectRatio);

  SVGAnimatedRect get viewBox() => _wrap(_ptr.viewBox);
}

class _SVGFontElementImpl extends _SVGElementImpl implements SVGFontElement {
  _SVGFontElementImpl._wrap(ptr) : super._wrap(ptr);
}

class _SVGFontFaceElementImpl extends _SVGElementImpl implements SVGFontFaceElement {
  _SVGFontFaceElementImpl._wrap(ptr) : super._wrap(ptr);
}

class _SVGFontFaceFormatElementImpl extends _SVGElementImpl implements SVGFontFaceFormatElement {
  _SVGFontFaceFormatElementImpl._wrap(ptr) : super._wrap(ptr);
}

class _SVGFontFaceNameElementImpl extends _SVGElementImpl implements SVGFontFaceNameElement {
  _SVGFontFaceNameElementImpl._wrap(ptr) : super._wrap(ptr);
}

class _SVGFontFaceSrcElementImpl extends _SVGElementImpl implements SVGFontFaceSrcElement {
  _SVGFontFaceSrcElementImpl._wrap(ptr) : super._wrap(ptr);
}

class _SVGFontFaceUriElementImpl extends _SVGElementImpl implements SVGFontFaceUriElement {
  _SVGFontFaceUriElementImpl._wrap(ptr) : super._wrap(ptr);
}

class _SVGForeignObjectElementImpl extends _SVGElementImpl implements SVGForeignObjectElement {
  _SVGForeignObjectElementImpl._wrap(ptr) : super._wrap(ptr);

  SVGAnimatedLength get height() => _wrap(_ptr.height);

  SVGAnimatedLength get width() => _wrap(_ptr.width);

  SVGAnimatedLength get x() => _wrap(_ptr.x);

  SVGAnimatedLength get y() => _wrap(_ptr.y);

  // From SVGTests

  SVGStringList get requiredExtensions() => _wrap(_ptr.requiredExtensions);

  SVGStringList get requiredFeatures() => _wrap(_ptr.requiredFeatures);

  SVGStringList get systemLanguage() => _wrap(_ptr.systemLanguage);

  bool hasExtension(String extension) {
    return _wrap(_ptr.hasExtension(_unwrap(extension)));
  }

  // From SVGLangSpace

  String get xmllang() => _wrap(_ptr.xmllang);

  void set xmllang(String value) { _ptr.xmllang = _unwrap(value); }

  String get xmlspace() => _wrap(_ptr.xmlspace);

  void set xmlspace(String value) { _ptr.xmlspace = _unwrap(value); }

  // From SVGExternalResourcesRequired

  SVGAnimatedBoolean get externalResourcesRequired() => _wrap(_ptr.externalResourcesRequired);

  // From SVGStylable

  SVGAnimatedString get _svgClassName() => _wrap(_ptr.className);

  CSSStyleDeclaration get style() => _wrap(_ptr.style);

  CSSValue getPresentationAttribute(String name) {
    return _wrap(_ptr.getPresentationAttribute(_unwrap(name)));
  }

  // From SVGTransformable

  SVGAnimatedTransformList get transform() => _wrap(_ptr.transform);

  // From SVGLocatable

  SVGElement get farthestViewportElement() => _wrap(_ptr.farthestViewportElement);

  SVGElement get nearestViewportElement() => _wrap(_ptr.nearestViewportElement);

  SVGRect getBBox() {
    return _wrap(_ptr.getBBox());
  }

  SVGMatrix getCTM() {
    return _wrap(_ptr.getCTM());
  }

  SVGMatrix getScreenCTM() {
    return _wrap(_ptr.getScreenCTM());
  }

  SVGMatrix getTransformToElement(SVGElement element) {
    return _wrap(_ptr.getTransformToElement(_unwrap(element)));
  }
}

class _SVGGElementImpl extends _SVGElementImpl implements SVGGElement {
  _SVGGElementImpl._wrap(ptr) : super._wrap(ptr);

  // From SVGTests

  SVGStringList get requiredExtensions() => _wrap(_ptr.requiredExtensions);

  SVGStringList get requiredFeatures() => _wrap(_ptr.requiredFeatures);

  SVGStringList get systemLanguage() => _wrap(_ptr.systemLanguage);

  bool hasExtension(String extension) {
    return _wrap(_ptr.hasExtension(_unwrap(extension)));
  }

  // From SVGLangSpace

  String get xmllang() => _wrap(_ptr.xmllang);

  void set xmllang(String value) { _ptr.xmllang = _unwrap(value); }

  String get xmlspace() => _wrap(_ptr.xmlspace);

  void set xmlspace(String value) { _ptr.xmlspace = _unwrap(value); }

  // From SVGExternalResourcesRequired

  SVGAnimatedBoolean get externalResourcesRequired() => _wrap(_ptr.externalResourcesRequired);

  // From SVGStylable

  SVGAnimatedString get _svgClassName() => _wrap(_ptr.className);

  CSSStyleDeclaration get style() => _wrap(_ptr.style);

  CSSValue getPresentationAttribute(String name) {
    return _wrap(_ptr.getPresentationAttribute(_unwrap(name)));
  }

  // From SVGTransformable

  SVGAnimatedTransformList get transform() => _wrap(_ptr.transform);

  // From SVGLocatable

  SVGElement get farthestViewportElement() => _wrap(_ptr.farthestViewportElement);

  SVGElement get nearestViewportElement() => _wrap(_ptr.nearestViewportElement);

  SVGRect getBBox() {
    return _wrap(_ptr.getBBox());
  }

  SVGMatrix getCTM() {
    return _wrap(_ptr.getCTM());
  }

  SVGMatrix getScreenCTM() {
    return _wrap(_ptr.getScreenCTM());
  }

  SVGMatrix getTransformToElement(SVGElement element) {
    return _wrap(_ptr.getTransformToElement(_unwrap(element)));
  }
}

class _SVGGlyphElementImpl extends _SVGElementImpl implements SVGGlyphElement {
  _SVGGlyphElementImpl._wrap(ptr) : super._wrap(ptr);
}

class _SVGGlyphRefElementImpl extends _SVGElementImpl implements SVGGlyphRefElement {
  _SVGGlyphRefElementImpl._wrap(ptr) : super._wrap(ptr);

  num get dx() => _wrap(_ptr.dx);

  void set dx(num value) { _ptr.dx = _unwrap(value); }

  num get dy() => _wrap(_ptr.dy);

  void set dy(num value) { _ptr.dy = _unwrap(value); }

  String get format() => _wrap(_ptr.format);

  void set format(String value) { _ptr.format = _unwrap(value); }

  String get glyphRef() => _wrap(_ptr.glyphRef);

  void set glyphRef(String value) { _ptr.glyphRef = _unwrap(value); }

  num get x() => _wrap(_ptr.x);

  void set x(num value) { _ptr.x = _unwrap(value); }

  num get y() => _wrap(_ptr.y);

  void set y(num value) { _ptr.y = _unwrap(value); }

  // From SVGURIReference

  SVGAnimatedString get href() => _wrap(_ptr.href);

  // From SVGStylable

  SVGAnimatedString get _svgClassName() => _wrap(_ptr.className);

  CSSStyleDeclaration get style() => _wrap(_ptr.style);

  CSSValue getPresentationAttribute(String name) {
    return _wrap(_ptr.getPresentationAttribute(_unwrap(name)));
  }
}

class _SVGGradientElementImpl extends _SVGElementImpl implements SVGGradientElement {
  _SVGGradientElementImpl._wrap(ptr) : super._wrap(ptr);

  SVGAnimatedTransformList get gradientTransform() => _wrap(_ptr.gradientTransform);

  SVGAnimatedEnumeration get gradientUnits() => _wrap(_ptr.gradientUnits);

  SVGAnimatedEnumeration get spreadMethod() => _wrap(_ptr.spreadMethod);

  // From SVGURIReference

  SVGAnimatedString get href() => _wrap(_ptr.href);

  // From SVGExternalResourcesRequired

  SVGAnimatedBoolean get externalResourcesRequired() => _wrap(_ptr.externalResourcesRequired);

  // From SVGStylable

  SVGAnimatedString get _svgClassName() => _wrap(_ptr.className);

  CSSStyleDeclaration get style() => _wrap(_ptr.style);

  CSSValue getPresentationAttribute(String name) {
    return _wrap(_ptr.getPresentationAttribute(_unwrap(name)));
  }
}

class _SVGHKernElementImpl extends _SVGElementImpl implements SVGHKernElement {
  _SVGHKernElementImpl._wrap(ptr) : super._wrap(ptr);
}

class _SVGImageElementImpl extends _SVGElementImpl implements SVGImageElement {
  _SVGImageElementImpl._wrap(ptr) : super._wrap(ptr);

  SVGAnimatedLength get height() => _wrap(_ptr.height);

  SVGAnimatedPreserveAspectRatio get preserveAspectRatio() => _wrap(_ptr.preserveAspectRatio);

  SVGAnimatedLength get width() => _wrap(_ptr.width);

  SVGAnimatedLength get x() => _wrap(_ptr.x);

  SVGAnimatedLength get y() => _wrap(_ptr.y);

  // From SVGURIReference

  SVGAnimatedString get href() => _wrap(_ptr.href);

  // From SVGTests

  SVGStringList get requiredExtensions() => _wrap(_ptr.requiredExtensions);

  SVGStringList get requiredFeatures() => _wrap(_ptr.requiredFeatures);

  SVGStringList get systemLanguage() => _wrap(_ptr.systemLanguage);

  bool hasExtension(String extension) {
    return _wrap(_ptr.hasExtension(_unwrap(extension)));
  }

  // From SVGLangSpace

  String get xmllang() => _wrap(_ptr.xmllang);

  void set xmllang(String value) { _ptr.xmllang = _unwrap(value); }

  String get xmlspace() => _wrap(_ptr.xmlspace);

  void set xmlspace(String value) { _ptr.xmlspace = _unwrap(value); }

  // From SVGExternalResourcesRequired

  SVGAnimatedBoolean get externalResourcesRequired() => _wrap(_ptr.externalResourcesRequired);

  // From SVGStylable

  SVGAnimatedString get _svgClassName() => _wrap(_ptr.className);

  CSSStyleDeclaration get style() => _wrap(_ptr.style);

  CSSValue getPresentationAttribute(String name) {
    return _wrap(_ptr.getPresentationAttribute(_unwrap(name)));
  }

  // From SVGTransformable

  SVGAnimatedTransformList get transform() => _wrap(_ptr.transform);

  // From SVGLocatable

  SVGElement get farthestViewportElement() => _wrap(_ptr.farthestViewportElement);

  SVGElement get nearestViewportElement() => _wrap(_ptr.nearestViewportElement);

  SVGRect getBBox() {
    return _wrap(_ptr.getBBox());
  }

  SVGMatrix getCTM() {
    return _wrap(_ptr.getCTM());
  }

  SVGMatrix getScreenCTM() {
    return _wrap(_ptr.getScreenCTM());
  }

  SVGMatrix getTransformToElement(SVGElement element) {
    return _wrap(_ptr.getTransformToElement(_unwrap(element)));
  }
}

class _SVGLangSpaceImpl extends _DOMTypeBase implements SVGLangSpace {
  _SVGLangSpaceImpl._wrap(ptr) : super._wrap(ptr);

  String get xmllang() => _wrap(_ptr.xmllang);

  void set xmllang(String value) { _ptr.xmllang = _unwrap(value); }

  String get xmlspace() => _wrap(_ptr.xmlspace);

  void set xmlspace(String value) { _ptr.xmlspace = _unwrap(value); }
}

class _SVGLengthImpl extends _DOMTypeBase implements SVGLength {
  _SVGLengthImpl._wrap(ptr) : super._wrap(ptr);

  int get unitType() => _wrap(_ptr.unitType);

  num get value() => _wrap(_ptr.value);

  void set value(num value) { _ptr.value = _unwrap(value); }

  String get valueAsString() => _wrap(_ptr.valueAsString);

  void set valueAsString(String value) { _ptr.valueAsString = _unwrap(value); }

  num get valueInSpecifiedUnits() => _wrap(_ptr.valueInSpecifiedUnits);

  void set valueInSpecifiedUnits(num value) { _ptr.valueInSpecifiedUnits = _unwrap(value); }

  void convertToSpecifiedUnits(int unitType) {
    _ptr.convertToSpecifiedUnits(_unwrap(unitType));
    return;
  }

  void newValueSpecifiedUnits(int unitType, num valueInSpecifiedUnits) {
    _ptr.newValueSpecifiedUnits(_unwrap(unitType), _unwrap(valueInSpecifiedUnits));
    return;
  }
}

class _SVGLengthListImpl extends _DOMTypeBase implements SVGLengthList {
  _SVGLengthListImpl._wrap(ptr) : super._wrap(ptr);

  int get numberOfItems() => _wrap(_ptr.numberOfItems);

  SVGLength appendItem(SVGLength item) {
    return _wrap(_ptr.appendItem(_unwrap(item)));
  }

  void clear() {
    _ptr.clear();
    return;
  }

  SVGLength getItem(int index) {
    return _wrap(_ptr.getItem(_unwrap(index)));
  }

  SVGLength initialize(SVGLength item) {
    return _wrap(_ptr.initialize(_unwrap(item)));
  }

  SVGLength insertItemBefore(SVGLength item, int index) {
    return _wrap(_ptr.insertItemBefore(_unwrap(item), _unwrap(index)));
  }

  SVGLength removeItem(int index) {
    return _wrap(_ptr.removeItem(_unwrap(index)));
  }

  SVGLength replaceItem(SVGLength item, int index) {
    return _wrap(_ptr.replaceItem(_unwrap(item), _unwrap(index)));
  }
}

class _SVGLineElementImpl extends _SVGElementImpl implements SVGLineElement {
  _SVGLineElementImpl._wrap(ptr) : super._wrap(ptr);

  SVGAnimatedLength get x1() => _wrap(_ptr.x1);

  SVGAnimatedLength get x2() => _wrap(_ptr.x2);

  SVGAnimatedLength get y1() => _wrap(_ptr.y1);

  SVGAnimatedLength get y2() => _wrap(_ptr.y2);

  // From SVGTests

  SVGStringList get requiredExtensions() => _wrap(_ptr.requiredExtensions);

  SVGStringList get requiredFeatures() => _wrap(_ptr.requiredFeatures);

  SVGStringList get systemLanguage() => _wrap(_ptr.systemLanguage);

  bool hasExtension(String extension) {
    return _wrap(_ptr.hasExtension(_unwrap(extension)));
  }

  // From SVGLangSpace

  String get xmllang() => _wrap(_ptr.xmllang);

  void set xmllang(String value) { _ptr.xmllang = _unwrap(value); }

  String get xmlspace() => _wrap(_ptr.xmlspace);

  void set xmlspace(String value) { _ptr.xmlspace = _unwrap(value); }

  // From SVGExternalResourcesRequired

  SVGAnimatedBoolean get externalResourcesRequired() => _wrap(_ptr.externalResourcesRequired);

  // From SVGStylable

  SVGAnimatedString get _svgClassName() => _wrap(_ptr.className);

  CSSStyleDeclaration get style() => _wrap(_ptr.style);

  CSSValue getPresentationAttribute(String name) {
    return _wrap(_ptr.getPresentationAttribute(_unwrap(name)));
  }

  // From SVGTransformable

  SVGAnimatedTransformList get transform() => _wrap(_ptr.transform);

  // From SVGLocatable

  SVGElement get farthestViewportElement() => _wrap(_ptr.farthestViewportElement);

  SVGElement get nearestViewportElement() => _wrap(_ptr.nearestViewportElement);

  SVGRect getBBox() {
    return _wrap(_ptr.getBBox());
  }

  SVGMatrix getCTM() {
    return _wrap(_ptr.getCTM());
  }

  SVGMatrix getScreenCTM() {
    return _wrap(_ptr.getScreenCTM());
  }

  SVGMatrix getTransformToElement(SVGElement element) {
    return _wrap(_ptr.getTransformToElement(_unwrap(element)));
  }
}

class _SVGLinearGradientElementImpl extends _SVGGradientElementImpl implements SVGLinearGradientElement {
  _SVGLinearGradientElementImpl._wrap(ptr) : super._wrap(ptr);

  SVGAnimatedLength get x1() => _wrap(_ptr.x1);

  SVGAnimatedLength get x2() => _wrap(_ptr.x2);

  SVGAnimatedLength get y1() => _wrap(_ptr.y1);

  SVGAnimatedLength get y2() => _wrap(_ptr.y2);
}

class _SVGLocatableImpl extends _DOMTypeBase implements SVGLocatable {
  _SVGLocatableImpl._wrap(ptr) : super._wrap(ptr);

  SVGElement get farthestViewportElement() => _wrap(_ptr.farthestViewportElement);

  SVGElement get nearestViewportElement() => _wrap(_ptr.nearestViewportElement);

  SVGRect getBBox() {
    return _wrap(_ptr.getBBox());
  }

  SVGMatrix getCTM() {
    return _wrap(_ptr.getCTM());
  }

  SVGMatrix getScreenCTM() {
    return _wrap(_ptr.getScreenCTM());
  }

  SVGMatrix getTransformToElement(SVGElement element) {
    return _wrap(_ptr.getTransformToElement(_unwrap(element)));
  }
}

class _SVGMPathElementImpl extends _SVGElementImpl implements SVGMPathElement {
  _SVGMPathElementImpl._wrap(ptr) : super._wrap(ptr);

  // From SVGURIReference

  SVGAnimatedString get href() => _wrap(_ptr.href);

  // From SVGExternalResourcesRequired

  SVGAnimatedBoolean get externalResourcesRequired() => _wrap(_ptr.externalResourcesRequired);
}

class _SVGMarkerElementImpl extends _SVGElementImpl implements SVGMarkerElement {
  _SVGMarkerElementImpl._wrap(ptr) : super._wrap(ptr);

  SVGAnimatedLength get markerHeight() => _wrap(_ptr.markerHeight);

  SVGAnimatedEnumeration get markerUnits() => _wrap(_ptr.markerUnits);

  SVGAnimatedLength get markerWidth() => _wrap(_ptr.markerWidth);

  SVGAnimatedAngle get orientAngle() => _wrap(_ptr.orientAngle);

  SVGAnimatedEnumeration get orientType() => _wrap(_ptr.orientType);

  SVGAnimatedLength get refX() => _wrap(_ptr.refX);

  SVGAnimatedLength get refY() => _wrap(_ptr.refY);

  void setOrientToAngle(SVGAngle angle) {
    _ptr.setOrientToAngle(_unwrap(angle));
    return;
  }

  void setOrientToAuto() {
    _ptr.setOrientToAuto();
    return;
  }

  // From SVGLangSpace

  String get xmllang() => _wrap(_ptr.xmllang);

  void set xmllang(String value) { _ptr.xmllang = _unwrap(value); }

  String get xmlspace() => _wrap(_ptr.xmlspace);

  void set xmlspace(String value) { _ptr.xmlspace = _unwrap(value); }

  // From SVGExternalResourcesRequired

  SVGAnimatedBoolean get externalResourcesRequired() => _wrap(_ptr.externalResourcesRequired);

  // From SVGStylable

  SVGAnimatedString get _svgClassName() => _wrap(_ptr.className);

  CSSStyleDeclaration get style() => _wrap(_ptr.style);

  CSSValue getPresentationAttribute(String name) {
    return _wrap(_ptr.getPresentationAttribute(_unwrap(name)));
  }

  // From SVGFitToViewBox

  SVGAnimatedPreserveAspectRatio get preserveAspectRatio() => _wrap(_ptr.preserveAspectRatio);

  SVGAnimatedRect get viewBox() => _wrap(_ptr.viewBox);
}

class _SVGMaskElementImpl extends _SVGElementImpl implements SVGMaskElement {
  _SVGMaskElementImpl._wrap(ptr) : super._wrap(ptr);

  SVGAnimatedLength get height() => _wrap(_ptr.height);

  SVGAnimatedEnumeration get maskContentUnits() => _wrap(_ptr.maskContentUnits);

  SVGAnimatedEnumeration get maskUnits() => _wrap(_ptr.maskUnits);

  SVGAnimatedLength get width() => _wrap(_ptr.width);

  SVGAnimatedLength get x() => _wrap(_ptr.x);

  SVGAnimatedLength get y() => _wrap(_ptr.y);

  // From SVGTests

  SVGStringList get requiredExtensions() => _wrap(_ptr.requiredExtensions);

  SVGStringList get requiredFeatures() => _wrap(_ptr.requiredFeatures);

  SVGStringList get systemLanguage() => _wrap(_ptr.systemLanguage);

  bool hasExtension(String extension) {
    return _wrap(_ptr.hasExtension(_unwrap(extension)));
  }

  // From SVGLangSpace

  String get xmllang() => _wrap(_ptr.xmllang);

  void set xmllang(String value) { _ptr.xmllang = _unwrap(value); }

  String get xmlspace() => _wrap(_ptr.xmlspace);

  void set xmlspace(String value) { _ptr.xmlspace = _unwrap(value); }

  // From SVGExternalResourcesRequired

  SVGAnimatedBoolean get externalResourcesRequired() => _wrap(_ptr.externalResourcesRequired);

  // From SVGStylable

  SVGAnimatedString get _svgClassName() => _wrap(_ptr.className);

  CSSStyleDeclaration get style() => _wrap(_ptr.style);

  CSSValue getPresentationAttribute(String name) {
    return _wrap(_ptr.getPresentationAttribute(_unwrap(name)));
  }
}

class _SVGMatrixImpl extends _DOMTypeBase implements SVGMatrix {
  _SVGMatrixImpl._wrap(ptr) : super._wrap(ptr);

  num get a() => _wrap(_ptr.a);

  void set a(num value) { _ptr.a = _unwrap(value); }

  num get b() => _wrap(_ptr.b);

  void set b(num value) { _ptr.b = _unwrap(value); }

  num get c() => _wrap(_ptr.c);

  void set c(num value) { _ptr.c = _unwrap(value); }

  num get d() => _wrap(_ptr.d);

  void set d(num value) { _ptr.d = _unwrap(value); }

  num get e() => _wrap(_ptr.e);

  void set e(num value) { _ptr.e = _unwrap(value); }

  num get f() => _wrap(_ptr.f);

  void set f(num value) { _ptr.f = _unwrap(value); }

  SVGMatrix flipX() {
    return _wrap(_ptr.flipX());
  }

  SVGMatrix flipY() {
    return _wrap(_ptr.flipY());
  }

  SVGMatrix inverse() {
    return _wrap(_ptr.inverse());
  }

  SVGMatrix multiply(SVGMatrix secondMatrix) {
    return _wrap(_ptr.multiply(_unwrap(secondMatrix)));
  }

  SVGMatrix rotate(num angle) {
    return _wrap(_ptr.rotate(_unwrap(angle)));
  }

  SVGMatrix rotateFromVector(num x, num y) {
    return _wrap(_ptr.rotateFromVector(_unwrap(x), _unwrap(y)));
  }

  SVGMatrix scale(num scaleFactor) {
    return _wrap(_ptr.scale(_unwrap(scaleFactor)));
  }

  SVGMatrix scaleNonUniform(num scaleFactorX, num scaleFactorY) {
    return _wrap(_ptr.scaleNonUniform(_unwrap(scaleFactorX), _unwrap(scaleFactorY)));
  }

  SVGMatrix skewX(num angle) {
    return _wrap(_ptr.skewX(_unwrap(angle)));
  }

  SVGMatrix skewY(num angle) {
    return _wrap(_ptr.skewY(_unwrap(angle)));
  }

  SVGMatrix translate(num x, num y) {
    return _wrap(_ptr.translate(_unwrap(x), _unwrap(y)));
  }
}

class _SVGMetadataElementImpl extends _SVGElementImpl implements SVGMetadataElement {
  _SVGMetadataElementImpl._wrap(ptr) : super._wrap(ptr);
}

class _SVGMissingGlyphElementImpl extends _SVGElementImpl implements SVGMissingGlyphElement {
  _SVGMissingGlyphElementImpl._wrap(ptr) : super._wrap(ptr);
}

class _SVGNumberImpl extends _DOMTypeBase implements SVGNumber {
  _SVGNumberImpl._wrap(ptr) : super._wrap(ptr);

  num get value() => _wrap(_ptr.value);

  void set value(num value) { _ptr.value = _unwrap(value); }
}

class _SVGNumberListImpl extends _DOMTypeBase implements SVGNumberList {
  _SVGNumberListImpl._wrap(ptr) : super._wrap(ptr);

  int get numberOfItems() => _wrap(_ptr.numberOfItems);

  SVGNumber appendItem(SVGNumber item) {
    return _wrap(_ptr.appendItem(_unwrap(item)));
  }

  void clear() {
    _ptr.clear();
    return;
  }

  SVGNumber getItem(int index) {
    return _wrap(_ptr.getItem(_unwrap(index)));
  }

  SVGNumber initialize(SVGNumber item) {
    return _wrap(_ptr.initialize(_unwrap(item)));
  }

  SVGNumber insertItemBefore(SVGNumber item, int index) {
    return _wrap(_ptr.insertItemBefore(_unwrap(item), _unwrap(index)));
  }

  SVGNumber removeItem(int index) {
    return _wrap(_ptr.removeItem(_unwrap(index)));
  }

  SVGNumber replaceItem(SVGNumber item, int index) {
    return _wrap(_ptr.replaceItem(_unwrap(item), _unwrap(index)));
  }
}

class _SVGPaintImpl extends _SVGColorImpl implements SVGPaint {
  _SVGPaintImpl._wrap(ptr) : super._wrap(ptr);

  int get paintType() => _wrap(_ptr.paintType);

  String get uri() => _wrap(_ptr.uri);

  void setPaint(int paintType, String uri, String rgbColor, String iccColor) {
    _ptr.setPaint(_unwrap(paintType), _unwrap(uri), _unwrap(rgbColor), _unwrap(iccColor));
    return;
  }

  void setUri(String uri) {
    _ptr.setUri(_unwrap(uri));
    return;
  }
}

class _SVGPathElementImpl extends _SVGElementImpl implements SVGPathElement {
  _SVGPathElementImpl._wrap(ptr) : super._wrap(ptr);

  SVGPathSegList get animatedNormalizedPathSegList() => _wrap(_ptr.animatedNormalizedPathSegList);

  SVGPathSegList get animatedPathSegList() => _wrap(_ptr.animatedPathSegList);

  SVGPathSegList get normalizedPathSegList() => _wrap(_ptr.normalizedPathSegList);

  SVGAnimatedNumber get pathLength() => _wrap(_ptr.pathLength);

  SVGPathSegList get pathSegList() => _wrap(_ptr.pathSegList);

  SVGPathSegArcAbs createSVGPathSegArcAbs(num x, num y, num r1, num r2, num angle, bool largeArcFlag, bool sweepFlag) {
    return _wrap(_ptr.createSVGPathSegArcAbs(_unwrap(x), _unwrap(y), _unwrap(r1), _unwrap(r2), _unwrap(angle), _unwrap(largeArcFlag), _unwrap(sweepFlag)));
  }

  SVGPathSegArcRel createSVGPathSegArcRel(num x, num y, num r1, num r2, num angle, bool largeArcFlag, bool sweepFlag) {
    return _wrap(_ptr.createSVGPathSegArcRel(_unwrap(x), _unwrap(y), _unwrap(r1), _unwrap(r2), _unwrap(angle), _unwrap(largeArcFlag), _unwrap(sweepFlag)));
  }

  SVGPathSegClosePath createSVGPathSegClosePath() {
    return _wrap(_ptr.createSVGPathSegClosePath());
  }

  SVGPathSegCurvetoCubicAbs createSVGPathSegCurvetoCubicAbs(num x, num y, num x1, num y1, num x2, num y2) {
    return _wrap(_ptr.createSVGPathSegCurvetoCubicAbs(_unwrap(x), _unwrap(y), _unwrap(x1), _unwrap(y1), _unwrap(x2), _unwrap(y2)));
  }

  SVGPathSegCurvetoCubicRel createSVGPathSegCurvetoCubicRel(num x, num y, num x1, num y1, num x2, num y2) {
    return _wrap(_ptr.createSVGPathSegCurvetoCubicRel(_unwrap(x), _unwrap(y), _unwrap(x1), _unwrap(y1), _unwrap(x2), _unwrap(y2)));
  }

  SVGPathSegCurvetoCubicSmoothAbs createSVGPathSegCurvetoCubicSmoothAbs(num x, num y, num x2, num y2) {
    return _wrap(_ptr.createSVGPathSegCurvetoCubicSmoothAbs(_unwrap(x), _unwrap(y), _unwrap(x2), _unwrap(y2)));
  }

  SVGPathSegCurvetoCubicSmoothRel createSVGPathSegCurvetoCubicSmoothRel(num x, num y, num x2, num y2) {
    return _wrap(_ptr.createSVGPathSegCurvetoCubicSmoothRel(_unwrap(x), _unwrap(y), _unwrap(x2), _unwrap(y2)));
  }

  SVGPathSegCurvetoQuadraticAbs createSVGPathSegCurvetoQuadraticAbs(num x, num y, num x1, num y1) {
    return _wrap(_ptr.createSVGPathSegCurvetoQuadraticAbs(_unwrap(x), _unwrap(y), _unwrap(x1), _unwrap(y1)));
  }

  SVGPathSegCurvetoQuadraticRel createSVGPathSegCurvetoQuadraticRel(num x, num y, num x1, num y1) {
    return _wrap(_ptr.createSVGPathSegCurvetoQuadraticRel(_unwrap(x), _unwrap(y), _unwrap(x1), _unwrap(y1)));
  }

  SVGPathSegCurvetoQuadraticSmoothAbs createSVGPathSegCurvetoQuadraticSmoothAbs(num x, num y) {
    return _wrap(_ptr.createSVGPathSegCurvetoQuadraticSmoothAbs(_unwrap(x), _unwrap(y)));
  }

  SVGPathSegCurvetoQuadraticSmoothRel createSVGPathSegCurvetoQuadraticSmoothRel(num x, num y) {
    return _wrap(_ptr.createSVGPathSegCurvetoQuadraticSmoothRel(_unwrap(x), _unwrap(y)));
  }

  SVGPathSegLinetoAbs createSVGPathSegLinetoAbs(num x, num y) {
    return _wrap(_ptr.createSVGPathSegLinetoAbs(_unwrap(x), _unwrap(y)));
  }

  SVGPathSegLinetoHorizontalAbs createSVGPathSegLinetoHorizontalAbs(num x) {
    return _wrap(_ptr.createSVGPathSegLinetoHorizontalAbs(_unwrap(x)));
  }

  SVGPathSegLinetoHorizontalRel createSVGPathSegLinetoHorizontalRel(num x) {
    return _wrap(_ptr.createSVGPathSegLinetoHorizontalRel(_unwrap(x)));
  }

  SVGPathSegLinetoRel createSVGPathSegLinetoRel(num x, num y) {
    return _wrap(_ptr.createSVGPathSegLinetoRel(_unwrap(x), _unwrap(y)));
  }

  SVGPathSegLinetoVerticalAbs createSVGPathSegLinetoVerticalAbs(num y) {
    return _wrap(_ptr.createSVGPathSegLinetoVerticalAbs(_unwrap(y)));
  }

  SVGPathSegLinetoVerticalRel createSVGPathSegLinetoVerticalRel(num y) {
    return _wrap(_ptr.createSVGPathSegLinetoVerticalRel(_unwrap(y)));
  }

  SVGPathSegMovetoAbs createSVGPathSegMovetoAbs(num x, num y) {
    return _wrap(_ptr.createSVGPathSegMovetoAbs(_unwrap(x), _unwrap(y)));
  }

  SVGPathSegMovetoRel createSVGPathSegMovetoRel(num x, num y) {
    return _wrap(_ptr.createSVGPathSegMovetoRel(_unwrap(x), _unwrap(y)));
  }

  int getPathSegAtLength(num distance) {
    return _wrap(_ptr.getPathSegAtLength(_unwrap(distance)));
  }

  SVGPoint getPointAtLength(num distance) {
    return _wrap(_ptr.getPointAtLength(_unwrap(distance)));
  }

  num getTotalLength() {
    return _wrap(_ptr.getTotalLength());
  }

  // From SVGTests

  SVGStringList get requiredExtensions() => _wrap(_ptr.requiredExtensions);

  SVGStringList get requiredFeatures() => _wrap(_ptr.requiredFeatures);

  SVGStringList get systemLanguage() => _wrap(_ptr.systemLanguage);

  bool hasExtension(String extension) {
    return _wrap(_ptr.hasExtension(_unwrap(extension)));
  }

  // From SVGLangSpace

  String get xmllang() => _wrap(_ptr.xmllang);

  void set xmllang(String value) { _ptr.xmllang = _unwrap(value); }

  String get xmlspace() => _wrap(_ptr.xmlspace);

  void set xmlspace(String value) { _ptr.xmlspace = _unwrap(value); }

  // From SVGExternalResourcesRequired

  SVGAnimatedBoolean get externalResourcesRequired() => _wrap(_ptr.externalResourcesRequired);

  // From SVGStylable

  SVGAnimatedString get _svgClassName() => _wrap(_ptr.className);

  CSSStyleDeclaration get style() => _wrap(_ptr.style);

  CSSValue getPresentationAttribute(String name) {
    return _wrap(_ptr.getPresentationAttribute(_unwrap(name)));
  }

  // From SVGTransformable

  SVGAnimatedTransformList get transform() => _wrap(_ptr.transform);

  // From SVGLocatable

  SVGElement get farthestViewportElement() => _wrap(_ptr.farthestViewportElement);

  SVGElement get nearestViewportElement() => _wrap(_ptr.nearestViewportElement);

  SVGRect getBBox() {
    return _wrap(_ptr.getBBox());
  }

  SVGMatrix getCTM() {
    return _wrap(_ptr.getCTM());
  }

  SVGMatrix getScreenCTM() {
    return _wrap(_ptr.getScreenCTM());
  }

  SVGMatrix getTransformToElement(SVGElement element) {
    return _wrap(_ptr.getTransformToElement(_unwrap(element)));
  }
}

class _SVGPathSegImpl extends _DOMTypeBase implements SVGPathSeg {
  _SVGPathSegImpl._wrap(ptr) : super._wrap(ptr);

  int get pathSegType() => _wrap(_ptr.pathSegType);

  String get pathSegTypeAsLetter() => _wrap(_ptr.pathSegTypeAsLetter);
}

class _SVGPathSegArcAbsImpl extends _SVGPathSegImpl implements SVGPathSegArcAbs {
  _SVGPathSegArcAbsImpl._wrap(ptr) : super._wrap(ptr);

  num get angle() => _wrap(_ptr.angle);

  void set angle(num value) { _ptr.angle = _unwrap(value); }

  bool get largeArcFlag() => _wrap(_ptr.largeArcFlag);

  void set largeArcFlag(bool value) { _ptr.largeArcFlag = _unwrap(value); }

  num get r1() => _wrap(_ptr.r1);

  void set r1(num value) { _ptr.r1 = _unwrap(value); }

  num get r2() => _wrap(_ptr.r2);

  void set r2(num value) { _ptr.r2 = _unwrap(value); }

  bool get sweepFlag() => _wrap(_ptr.sweepFlag);

  void set sweepFlag(bool value) { _ptr.sweepFlag = _unwrap(value); }

  num get x() => _wrap(_ptr.x);

  void set x(num value) { _ptr.x = _unwrap(value); }

  num get y() => _wrap(_ptr.y);

  void set y(num value) { _ptr.y = _unwrap(value); }
}

class _SVGPathSegArcRelImpl extends _SVGPathSegImpl implements SVGPathSegArcRel {
  _SVGPathSegArcRelImpl._wrap(ptr) : super._wrap(ptr);

  num get angle() => _wrap(_ptr.angle);

  void set angle(num value) { _ptr.angle = _unwrap(value); }

  bool get largeArcFlag() => _wrap(_ptr.largeArcFlag);

  void set largeArcFlag(bool value) { _ptr.largeArcFlag = _unwrap(value); }

  num get r1() => _wrap(_ptr.r1);

  void set r1(num value) { _ptr.r1 = _unwrap(value); }

  num get r2() => _wrap(_ptr.r2);

  void set r2(num value) { _ptr.r2 = _unwrap(value); }

  bool get sweepFlag() => _wrap(_ptr.sweepFlag);

  void set sweepFlag(bool value) { _ptr.sweepFlag = _unwrap(value); }

  num get x() => _wrap(_ptr.x);

  void set x(num value) { _ptr.x = _unwrap(value); }

  num get y() => _wrap(_ptr.y);

  void set y(num value) { _ptr.y = _unwrap(value); }
}

class _SVGPathSegClosePathImpl extends _SVGPathSegImpl implements SVGPathSegClosePath {
  _SVGPathSegClosePathImpl._wrap(ptr) : super._wrap(ptr);
}

class _SVGPathSegCurvetoCubicAbsImpl extends _SVGPathSegImpl implements SVGPathSegCurvetoCubicAbs {
  _SVGPathSegCurvetoCubicAbsImpl._wrap(ptr) : super._wrap(ptr);

  num get x() => _wrap(_ptr.x);

  void set x(num value) { _ptr.x = _unwrap(value); }

  num get x1() => _wrap(_ptr.x1);

  void set x1(num value) { _ptr.x1 = _unwrap(value); }

  num get x2() => _wrap(_ptr.x2);

  void set x2(num value) { _ptr.x2 = _unwrap(value); }

  num get y() => _wrap(_ptr.y);

  void set y(num value) { _ptr.y = _unwrap(value); }

  num get y1() => _wrap(_ptr.y1);

  void set y1(num value) { _ptr.y1 = _unwrap(value); }

  num get y2() => _wrap(_ptr.y2);

  void set y2(num value) { _ptr.y2 = _unwrap(value); }
}

class _SVGPathSegCurvetoCubicRelImpl extends _SVGPathSegImpl implements SVGPathSegCurvetoCubicRel {
  _SVGPathSegCurvetoCubicRelImpl._wrap(ptr) : super._wrap(ptr);

  num get x() => _wrap(_ptr.x);

  void set x(num value) { _ptr.x = _unwrap(value); }

  num get x1() => _wrap(_ptr.x1);

  void set x1(num value) { _ptr.x1 = _unwrap(value); }

  num get x2() => _wrap(_ptr.x2);

  void set x2(num value) { _ptr.x2 = _unwrap(value); }

  num get y() => _wrap(_ptr.y);

  void set y(num value) { _ptr.y = _unwrap(value); }

  num get y1() => _wrap(_ptr.y1);

  void set y1(num value) { _ptr.y1 = _unwrap(value); }

  num get y2() => _wrap(_ptr.y2);

  void set y2(num value) { _ptr.y2 = _unwrap(value); }
}

class _SVGPathSegCurvetoCubicSmoothAbsImpl extends _SVGPathSegImpl implements SVGPathSegCurvetoCubicSmoothAbs {
  _SVGPathSegCurvetoCubicSmoothAbsImpl._wrap(ptr) : super._wrap(ptr);

  num get x() => _wrap(_ptr.x);

  void set x(num value) { _ptr.x = _unwrap(value); }

  num get x2() => _wrap(_ptr.x2);

  void set x2(num value) { _ptr.x2 = _unwrap(value); }

  num get y() => _wrap(_ptr.y);

  void set y(num value) { _ptr.y = _unwrap(value); }

  num get y2() => _wrap(_ptr.y2);

  void set y2(num value) { _ptr.y2 = _unwrap(value); }
}

class _SVGPathSegCurvetoCubicSmoothRelImpl extends _SVGPathSegImpl implements SVGPathSegCurvetoCubicSmoothRel {
  _SVGPathSegCurvetoCubicSmoothRelImpl._wrap(ptr) : super._wrap(ptr);

  num get x() => _wrap(_ptr.x);

  void set x(num value) { _ptr.x = _unwrap(value); }

  num get x2() => _wrap(_ptr.x2);

  void set x2(num value) { _ptr.x2 = _unwrap(value); }

  num get y() => _wrap(_ptr.y);

  void set y(num value) { _ptr.y = _unwrap(value); }

  num get y2() => _wrap(_ptr.y2);

  void set y2(num value) { _ptr.y2 = _unwrap(value); }
}

class _SVGPathSegCurvetoQuadraticAbsImpl extends _SVGPathSegImpl implements SVGPathSegCurvetoQuadraticAbs {
  _SVGPathSegCurvetoQuadraticAbsImpl._wrap(ptr) : super._wrap(ptr);

  num get x() => _wrap(_ptr.x);

  void set x(num value) { _ptr.x = _unwrap(value); }

  num get x1() => _wrap(_ptr.x1);

  void set x1(num value) { _ptr.x1 = _unwrap(value); }

  num get y() => _wrap(_ptr.y);

  void set y(num value) { _ptr.y = _unwrap(value); }

  num get y1() => _wrap(_ptr.y1);

  void set y1(num value) { _ptr.y1 = _unwrap(value); }
}

class _SVGPathSegCurvetoQuadraticRelImpl extends _SVGPathSegImpl implements SVGPathSegCurvetoQuadraticRel {
  _SVGPathSegCurvetoQuadraticRelImpl._wrap(ptr) : super._wrap(ptr);

  num get x() => _wrap(_ptr.x);

  void set x(num value) { _ptr.x = _unwrap(value); }

  num get x1() => _wrap(_ptr.x1);

  void set x1(num value) { _ptr.x1 = _unwrap(value); }

  num get y() => _wrap(_ptr.y);

  void set y(num value) { _ptr.y = _unwrap(value); }

  num get y1() => _wrap(_ptr.y1);

  void set y1(num value) { _ptr.y1 = _unwrap(value); }
}

class _SVGPathSegCurvetoQuadraticSmoothAbsImpl extends _SVGPathSegImpl implements SVGPathSegCurvetoQuadraticSmoothAbs {
  _SVGPathSegCurvetoQuadraticSmoothAbsImpl._wrap(ptr) : super._wrap(ptr);

  num get x() => _wrap(_ptr.x);

  void set x(num value) { _ptr.x = _unwrap(value); }

  num get y() => _wrap(_ptr.y);

  void set y(num value) { _ptr.y = _unwrap(value); }
}

class _SVGPathSegCurvetoQuadraticSmoothRelImpl extends _SVGPathSegImpl implements SVGPathSegCurvetoQuadraticSmoothRel {
  _SVGPathSegCurvetoQuadraticSmoothRelImpl._wrap(ptr) : super._wrap(ptr);

  num get x() => _wrap(_ptr.x);

  void set x(num value) { _ptr.x = _unwrap(value); }

  num get y() => _wrap(_ptr.y);

  void set y(num value) { _ptr.y = _unwrap(value); }
}

class _SVGPathSegLinetoAbsImpl extends _SVGPathSegImpl implements SVGPathSegLinetoAbs {
  _SVGPathSegLinetoAbsImpl._wrap(ptr) : super._wrap(ptr);

  num get x() => _wrap(_ptr.x);

  void set x(num value) { _ptr.x = _unwrap(value); }

  num get y() => _wrap(_ptr.y);

  void set y(num value) { _ptr.y = _unwrap(value); }
}

class _SVGPathSegLinetoHorizontalAbsImpl extends _SVGPathSegImpl implements SVGPathSegLinetoHorizontalAbs {
  _SVGPathSegLinetoHorizontalAbsImpl._wrap(ptr) : super._wrap(ptr);

  num get x() => _wrap(_ptr.x);

  void set x(num value) { _ptr.x = _unwrap(value); }
}

class _SVGPathSegLinetoHorizontalRelImpl extends _SVGPathSegImpl implements SVGPathSegLinetoHorizontalRel {
  _SVGPathSegLinetoHorizontalRelImpl._wrap(ptr) : super._wrap(ptr);

  num get x() => _wrap(_ptr.x);

  void set x(num value) { _ptr.x = _unwrap(value); }
}

class _SVGPathSegLinetoRelImpl extends _SVGPathSegImpl implements SVGPathSegLinetoRel {
  _SVGPathSegLinetoRelImpl._wrap(ptr) : super._wrap(ptr);

  num get x() => _wrap(_ptr.x);

  void set x(num value) { _ptr.x = _unwrap(value); }

  num get y() => _wrap(_ptr.y);

  void set y(num value) { _ptr.y = _unwrap(value); }
}

class _SVGPathSegLinetoVerticalAbsImpl extends _SVGPathSegImpl implements SVGPathSegLinetoVerticalAbs {
  _SVGPathSegLinetoVerticalAbsImpl._wrap(ptr) : super._wrap(ptr);

  num get y() => _wrap(_ptr.y);

  void set y(num value) { _ptr.y = _unwrap(value); }
}

class _SVGPathSegLinetoVerticalRelImpl extends _SVGPathSegImpl implements SVGPathSegLinetoVerticalRel {
  _SVGPathSegLinetoVerticalRelImpl._wrap(ptr) : super._wrap(ptr);

  num get y() => _wrap(_ptr.y);

  void set y(num value) { _ptr.y = _unwrap(value); }
}

class _SVGPathSegListImpl extends _DOMTypeBase implements SVGPathSegList {
  _SVGPathSegListImpl._wrap(ptr) : super._wrap(ptr);

  int get numberOfItems() => _wrap(_ptr.numberOfItems);

  SVGPathSeg appendItem(SVGPathSeg newItem) {
    return _wrap(_ptr.appendItem(_unwrap(newItem)));
  }

  void clear() {
    _ptr.clear();
    return;
  }

  SVGPathSeg getItem(int index) {
    return _wrap(_ptr.getItem(_unwrap(index)));
  }

  SVGPathSeg initialize(SVGPathSeg newItem) {
    return _wrap(_ptr.initialize(_unwrap(newItem)));
  }

  SVGPathSeg insertItemBefore(SVGPathSeg newItem, int index) {
    return _wrap(_ptr.insertItemBefore(_unwrap(newItem), _unwrap(index)));
  }

  SVGPathSeg removeItem(int index) {
    return _wrap(_ptr.removeItem(_unwrap(index)));
  }

  SVGPathSeg replaceItem(SVGPathSeg newItem, int index) {
    return _wrap(_ptr.replaceItem(_unwrap(newItem), _unwrap(index)));
  }
}

class _SVGPathSegMovetoAbsImpl extends _SVGPathSegImpl implements SVGPathSegMovetoAbs {
  _SVGPathSegMovetoAbsImpl._wrap(ptr) : super._wrap(ptr);

  num get x() => _wrap(_ptr.x);

  void set x(num value) { _ptr.x = _unwrap(value); }

  num get y() => _wrap(_ptr.y);

  void set y(num value) { _ptr.y = _unwrap(value); }
}

class _SVGPathSegMovetoRelImpl extends _SVGPathSegImpl implements SVGPathSegMovetoRel {
  _SVGPathSegMovetoRelImpl._wrap(ptr) : super._wrap(ptr);

  num get x() => _wrap(_ptr.x);

  void set x(num value) { _ptr.x = _unwrap(value); }

  num get y() => _wrap(_ptr.y);

  void set y(num value) { _ptr.y = _unwrap(value); }
}

class _SVGPatternElementImpl extends _SVGElementImpl implements SVGPatternElement {
  _SVGPatternElementImpl._wrap(ptr) : super._wrap(ptr);

  SVGAnimatedLength get height() => _wrap(_ptr.height);

  SVGAnimatedEnumeration get patternContentUnits() => _wrap(_ptr.patternContentUnits);

  SVGAnimatedTransformList get patternTransform() => _wrap(_ptr.patternTransform);

  SVGAnimatedEnumeration get patternUnits() => _wrap(_ptr.patternUnits);

  SVGAnimatedLength get width() => _wrap(_ptr.width);

  SVGAnimatedLength get x() => _wrap(_ptr.x);

  SVGAnimatedLength get y() => _wrap(_ptr.y);

  // From SVGURIReference

  SVGAnimatedString get href() => _wrap(_ptr.href);

  // From SVGTests

  SVGStringList get requiredExtensions() => _wrap(_ptr.requiredExtensions);

  SVGStringList get requiredFeatures() => _wrap(_ptr.requiredFeatures);

  SVGStringList get systemLanguage() => _wrap(_ptr.systemLanguage);

  bool hasExtension(String extension) {
    return _wrap(_ptr.hasExtension(_unwrap(extension)));
  }

  // From SVGLangSpace

  String get xmllang() => _wrap(_ptr.xmllang);

  void set xmllang(String value) { _ptr.xmllang = _unwrap(value); }

  String get xmlspace() => _wrap(_ptr.xmlspace);

  void set xmlspace(String value) { _ptr.xmlspace = _unwrap(value); }

  // From SVGExternalResourcesRequired

  SVGAnimatedBoolean get externalResourcesRequired() => _wrap(_ptr.externalResourcesRequired);

  // From SVGStylable

  SVGAnimatedString get _svgClassName() => _wrap(_ptr.className);

  CSSStyleDeclaration get style() => _wrap(_ptr.style);

  CSSValue getPresentationAttribute(String name) {
    return _wrap(_ptr.getPresentationAttribute(_unwrap(name)));
  }

  // From SVGFitToViewBox

  SVGAnimatedPreserveAspectRatio get preserveAspectRatio() => _wrap(_ptr.preserveAspectRatio);

  SVGAnimatedRect get viewBox() => _wrap(_ptr.viewBox);
}

class _SVGPointImpl extends _DOMTypeBase implements SVGPoint {
  _SVGPointImpl._wrap(ptr) : super._wrap(ptr);

  num get x() => _wrap(_ptr.x);

  void set x(num value) { _ptr.x = _unwrap(value); }

  num get y() => _wrap(_ptr.y);

  void set y(num value) { _ptr.y = _unwrap(value); }

  SVGPoint matrixTransform(SVGMatrix matrix) {
    return _wrap(_ptr.matrixTransform(_unwrap(matrix)));
  }
}

class _SVGPointListImpl extends _DOMTypeBase implements SVGPointList {
  _SVGPointListImpl._wrap(ptr) : super._wrap(ptr);

  int get numberOfItems() => _wrap(_ptr.numberOfItems);

  SVGPoint appendItem(SVGPoint item) {
    return _wrap(_ptr.appendItem(_unwrap(item)));
  }

  void clear() {
    _ptr.clear();
    return;
  }

  SVGPoint getItem(int index) {
    return _wrap(_ptr.getItem(_unwrap(index)));
  }

  SVGPoint initialize(SVGPoint item) {
    return _wrap(_ptr.initialize(_unwrap(item)));
  }

  SVGPoint insertItemBefore(SVGPoint item, int index) {
    return _wrap(_ptr.insertItemBefore(_unwrap(item), _unwrap(index)));
  }

  SVGPoint removeItem(int index) {
    return _wrap(_ptr.removeItem(_unwrap(index)));
  }

  SVGPoint replaceItem(SVGPoint item, int index) {
    return _wrap(_ptr.replaceItem(_unwrap(item), _unwrap(index)));
  }
}

class _SVGPolygonElementImpl extends _SVGElementImpl implements SVGPolygonElement {
  _SVGPolygonElementImpl._wrap(ptr) : super._wrap(ptr);

  SVGPointList get animatedPoints() => _wrap(_ptr.animatedPoints);

  SVGPointList get points() => _wrap(_ptr.points);

  // From SVGTests

  SVGStringList get requiredExtensions() => _wrap(_ptr.requiredExtensions);

  SVGStringList get requiredFeatures() => _wrap(_ptr.requiredFeatures);

  SVGStringList get systemLanguage() => _wrap(_ptr.systemLanguage);

  bool hasExtension(String extension) {
    return _wrap(_ptr.hasExtension(_unwrap(extension)));
  }

  // From SVGLangSpace

  String get xmllang() => _wrap(_ptr.xmllang);

  void set xmllang(String value) { _ptr.xmllang = _unwrap(value); }

  String get xmlspace() => _wrap(_ptr.xmlspace);

  void set xmlspace(String value) { _ptr.xmlspace = _unwrap(value); }

  // From SVGExternalResourcesRequired

  SVGAnimatedBoolean get externalResourcesRequired() => _wrap(_ptr.externalResourcesRequired);

  // From SVGStylable

  SVGAnimatedString get _svgClassName() => _wrap(_ptr.className);

  CSSStyleDeclaration get style() => _wrap(_ptr.style);

  CSSValue getPresentationAttribute(String name) {
    return _wrap(_ptr.getPresentationAttribute(_unwrap(name)));
  }

  // From SVGTransformable

  SVGAnimatedTransformList get transform() => _wrap(_ptr.transform);

  // From SVGLocatable

  SVGElement get farthestViewportElement() => _wrap(_ptr.farthestViewportElement);

  SVGElement get nearestViewportElement() => _wrap(_ptr.nearestViewportElement);

  SVGRect getBBox() {
    return _wrap(_ptr.getBBox());
  }

  SVGMatrix getCTM() {
    return _wrap(_ptr.getCTM());
  }

  SVGMatrix getScreenCTM() {
    return _wrap(_ptr.getScreenCTM());
  }

  SVGMatrix getTransformToElement(SVGElement element) {
    return _wrap(_ptr.getTransformToElement(_unwrap(element)));
  }
}

class _SVGPolylineElementImpl extends _SVGElementImpl implements SVGPolylineElement {
  _SVGPolylineElementImpl._wrap(ptr) : super._wrap(ptr);

  SVGPointList get animatedPoints() => _wrap(_ptr.animatedPoints);

  SVGPointList get points() => _wrap(_ptr.points);

  // From SVGTests

  SVGStringList get requiredExtensions() => _wrap(_ptr.requiredExtensions);

  SVGStringList get requiredFeatures() => _wrap(_ptr.requiredFeatures);

  SVGStringList get systemLanguage() => _wrap(_ptr.systemLanguage);

  bool hasExtension(String extension) {
    return _wrap(_ptr.hasExtension(_unwrap(extension)));
  }

  // From SVGLangSpace

  String get xmllang() => _wrap(_ptr.xmllang);

  void set xmllang(String value) { _ptr.xmllang = _unwrap(value); }

  String get xmlspace() => _wrap(_ptr.xmlspace);

  void set xmlspace(String value) { _ptr.xmlspace = _unwrap(value); }

  // From SVGExternalResourcesRequired

  SVGAnimatedBoolean get externalResourcesRequired() => _wrap(_ptr.externalResourcesRequired);

  // From SVGStylable

  SVGAnimatedString get _svgClassName() => _wrap(_ptr.className);

  CSSStyleDeclaration get style() => _wrap(_ptr.style);

  CSSValue getPresentationAttribute(String name) {
    return _wrap(_ptr.getPresentationAttribute(_unwrap(name)));
  }

  // From SVGTransformable

  SVGAnimatedTransformList get transform() => _wrap(_ptr.transform);

  // From SVGLocatable

  SVGElement get farthestViewportElement() => _wrap(_ptr.farthestViewportElement);

  SVGElement get nearestViewportElement() => _wrap(_ptr.nearestViewportElement);

  SVGRect getBBox() {
    return _wrap(_ptr.getBBox());
  }

  SVGMatrix getCTM() {
    return _wrap(_ptr.getCTM());
  }

  SVGMatrix getScreenCTM() {
    return _wrap(_ptr.getScreenCTM());
  }

  SVGMatrix getTransformToElement(SVGElement element) {
    return _wrap(_ptr.getTransformToElement(_unwrap(element)));
  }
}

class _SVGPreserveAspectRatioImpl extends _DOMTypeBase implements SVGPreserveAspectRatio {
  _SVGPreserveAspectRatioImpl._wrap(ptr) : super._wrap(ptr);

  int get align() => _wrap(_ptr.align);

  void set align(int value) { _ptr.align = _unwrap(value); }

  int get meetOrSlice() => _wrap(_ptr.meetOrSlice);

  void set meetOrSlice(int value) { _ptr.meetOrSlice = _unwrap(value); }
}

class _SVGRadialGradientElementImpl extends _SVGGradientElementImpl implements SVGRadialGradientElement {
  _SVGRadialGradientElementImpl._wrap(ptr) : super._wrap(ptr);

  SVGAnimatedLength get cx() => _wrap(_ptr.cx);

  SVGAnimatedLength get cy() => _wrap(_ptr.cy);

  SVGAnimatedLength get fx() => _wrap(_ptr.fx);

  SVGAnimatedLength get fy() => _wrap(_ptr.fy);

  SVGAnimatedLength get r() => _wrap(_ptr.r);
}

class _SVGRectImpl extends _DOMTypeBase implements SVGRect {
  _SVGRectImpl._wrap(ptr) : super._wrap(ptr);

  num get height() => _wrap(_ptr.height);

  void set height(num value) { _ptr.height = _unwrap(value); }

  num get width() => _wrap(_ptr.width);

  void set width(num value) { _ptr.width = _unwrap(value); }

  num get x() => _wrap(_ptr.x);

  void set x(num value) { _ptr.x = _unwrap(value); }

  num get y() => _wrap(_ptr.y);

  void set y(num value) { _ptr.y = _unwrap(value); }
}

class _SVGRectElementImpl extends _SVGElementImpl implements SVGRectElement {
  _SVGRectElementImpl._wrap(ptr) : super._wrap(ptr);

  SVGAnimatedLength get height() => _wrap(_ptr.height);

  SVGAnimatedLength get rx() => _wrap(_ptr.rx);

  SVGAnimatedLength get ry() => _wrap(_ptr.ry);

  SVGAnimatedLength get width() => _wrap(_ptr.width);

  SVGAnimatedLength get x() => _wrap(_ptr.x);

  SVGAnimatedLength get y() => _wrap(_ptr.y);

  // From SVGTests

  SVGStringList get requiredExtensions() => _wrap(_ptr.requiredExtensions);

  SVGStringList get requiredFeatures() => _wrap(_ptr.requiredFeatures);

  SVGStringList get systemLanguage() => _wrap(_ptr.systemLanguage);

  bool hasExtension(String extension) {
    return _wrap(_ptr.hasExtension(_unwrap(extension)));
  }

  // From SVGLangSpace

  String get xmllang() => _wrap(_ptr.xmllang);

  void set xmllang(String value) { _ptr.xmllang = _unwrap(value); }

  String get xmlspace() => _wrap(_ptr.xmlspace);

  void set xmlspace(String value) { _ptr.xmlspace = _unwrap(value); }

  // From SVGExternalResourcesRequired

  SVGAnimatedBoolean get externalResourcesRequired() => _wrap(_ptr.externalResourcesRequired);

  // From SVGStylable

  SVGAnimatedString get _svgClassName() => _wrap(_ptr.className);

  CSSStyleDeclaration get style() => _wrap(_ptr.style);

  CSSValue getPresentationAttribute(String name) {
    return _wrap(_ptr.getPresentationAttribute(_unwrap(name)));
  }

  // From SVGTransformable

  SVGAnimatedTransformList get transform() => _wrap(_ptr.transform);

  // From SVGLocatable

  SVGElement get farthestViewportElement() => _wrap(_ptr.farthestViewportElement);

  SVGElement get nearestViewportElement() => _wrap(_ptr.nearestViewportElement);

  SVGRect getBBox() {
    return _wrap(_ptr.getBBox());
  }

  SVGMatrix getCTM() {
    return _wrap(_ptr.getCTM());
  }

  SVGMatrix getScreenCTM() {
    return _wrap(_ptr.getScreenCTM());
  }

  SVGMatrix getTransformToElement(SVGElement element) {
    return _wrap(_ptr.getTransformToElement(_unwrap(element)));
  }
}

class _SVGRenderingIntentImpl extends _DOMTypeBase implements SVGRenderingIntent {
  _SVGRenderingIntentImpl._wrap(ptr) : super._wrap(ptr);
}

class _SVGSVGElementImpl extends _SVGElementImpl implements SVGSVGElement {
  _SVGSVGElementImpl._wrap(ptr) : super._wrap(ptr);

  String get contentScriptType() => _wrap(_ptr.contentScriptType);

  void set contentScriptType(String value) { _ptr.contentScriptType = _unwrap(value); }

  String get contentStyleType() => _wrap(_ptr.contentStyleType);

  void set contentStyleType(String value) { _ptr.contentStyleType = _unwrap(value); }

  num get currentScale() => _wrap(_ptr.currentScale);

  void set currentScale(num value) { _ptr.currentScale = _unwrap(value); }

  SVGPoint get currentTranslate() => _wrap(_ptr.currentTranslate);

  SVGAnimatedLength get height() => _wrap(_ptr.height);

  num get pixelUnitToMillimeterX() => _wrap(_ptr.pixelUnitToMillimeterX);

  num get pixelUnitToMillimeterY() => _wrap(_ptr.pixelUnitToMillimeterY);

  num get screenPixelToMillimeterX() => _wrap(_ptr.screenPixelToMillimeterX);

  num get screenPixelToMillimeterY() => _wrap(_ptr.screenPixelToMillimeterY);

  bool get useCurrentView() => _wrap(_ptr.useCurrentView);

  void set useCurrentView(bool value) { _ptr.useCurrentView = _unwrap(value); }

  SVGRect get viewport() => _wrap(_ptr.viewport);

  SVGAnimatedLength get width() => _wrap(_ptr.width);

  SVGAnimatedLength get x() => _wrap(_ptr.x);

  SVGAnimatedLength get y() => _wrap(_ptr.y);

  bool animationsPaused() {
    return _wrap(_ptr.animationsPaused());
  }

  bool checkEnclosure(SVGElement element, SVGRect rect) {
    return _wrap(_ptr.checkEnclosure(_unwrap(element), _unwrap(rect)));
  }

  bool checkIntersection(SVGElement element, SVGRect rect) {
    return _wrap(_ptr.checkIntersection(_unwrap(element), _unwrap(rect)));
  }

  SVGAngle createSVGAngle() {
    return _wrap(_ptr.createSVGAngle());
  }

  SVGLength createSVGLength() {
    return _wrap(_ptr.createSVGLength());
  }

  SVGMatrix createSVGMatrix() {
    return _wrap(_ptr.createSVGMatrix());
  }

  SVGNumber createSVGNumber() {
    return _wrap(_ptr.createSVGNumber());
  }

  SVGPoint createSVGPoint() {
    return _wrap(_ptr.createSVGPoint());
  }

  SVGRect createSVGRect() {
    return _wrap(_ptr.createSVGRect());
  }

  SVGTransform createSVGTransform() {
    return _wrap(_ptr.createSVGTransform());
  }

  SVGTransform createSVGTransformFromMatrix(SVGMatrix matrix) {
    return _wrap(_ptr.createSVGTransformFromMatrix(_unwrap(matrix)));
  }

  void deselectAll() {
    _ptr.deselectAll();
    return;
  }

  void forceRedraw() {
    _ptr.forceRedraw();
    return;
  }

  num getCurrentTime() {
    return _wrap(_ptr.getCurrentTime());
  }

  Element getElementById(String elementId) {
    return _wrap(_ptr.getElementById(_unwrap(elementId)));
  }

  NodeList getEnclosureList(SVGRect rect, SVGElement referenceElement) {
    return _wrap(_ptr.getEnclosureList(_unwrap(rect), _unwrap(referenceElement)));
  }

  NodeList getIntersectionList(SVGRect rect, SVGElement referenceElement) {
    return _wrap(_ptr.getIntersectionList(_unwrap(rect), _unwrap(referenceElement)));
  }

  void pauseAnimations() {
    _ptr.pauseAnimations();
    return;
  }

  void setCurrentTime(num seconds) {
    _ptr.setCurrentTime(_unwrap(seconds));
    return;
  }

  int suspendRedraw(int maxWaitMilliseconds) {
    return _wrap(_ptr.suspendRedraw(_unwrap(maxWaitMilliseconds)));
  }

  void unpauseAnimations() {
    _ptr.unpauseAnimations();
    return;
  }

  void unsuspendRedraw(int suspendHandleId) {
    _ptr.unsuspendRedraw(_unwrap(suspendHandleId));
    return;
  }

  void unsuspendRedrawAll() {
    _ptr.unsuspendRedrawAll();
    return;
  }

  // From SVGTests

  SVGStringList get requiredExtensions() => _wrap(_ptr.requiredExtensions);

  SVGStringList get requiredFeatures() => _wrap(_ptr.requiredFeatures);

  SVGStringList get systemLanguage() => _wrap(_ptr.systemLanguage);

  bool hasExtension(String extension) {
    return _wrap(_ptr.hasExtension(_unwrap(extension)));
  }

  // From SVGLangSpace

  String get xmllang() => _wrap(_ptr.xmllang);

  void set xmllang(String value) { _ptr.xmllang = _unwrap(value); }

  String get xmlspace() => _wrap(_ptr.xmlspace);

  void set xmlspace(String value) { _ptr.xmlspace = _unwrap(value); }

  // From SVGExternalResourcesRequired

  SVGAnimatedBoolean get externalResourcesRequired() => _wrap(_ptr.externalResourcesRequired);

  // From SVGStylable

  SVGAnimatedString get _svgClassName() => _wrap(_ptr.className);

  CSSStyleDeclaration get style() => _wrap(_ptr.style);

  CSSValue getPresentationAttribute(String name) {
    return _wrap(_ptr.getPresentationAttribute(_unwrap(name)));
  }

  // From SVGLocatable

  SVGElement get farthestViewportElement() => _wrap(_ptr.farthestViewportElement);

  SVGElement get nearestViewportElement() => _wrap(_ptr.nearestViewportElement);

  SVGRect getBBox() {
    return _wrap(_ptr.getBBox());
  }

  SVGMatrix getCTM() {
    return _wrap(_ptr.getCTM());
  }

  SVGMatrix getScreenCTM() {
    return _wrap(_ptr.getScreenCTM());
  }

  SVGMatrix getTransformToElement(SVGElement element) {
    return _wrap(_ptr.getTransformToElement(_unwrap(element)));
  }

  // From SVGFitToViewBox

  SVGAnimatedPreserveAspectRatio get preserveAspectRatio() => _wrap(_ptr.preserveAspectRatio);

  SVGAnimatedRect get viewBox() => _wrap(_ptr.viewBox);

  // From SVGZoomAndPan

  int get zoomAndPan() => _wrap(_ptr.zoomAndPan);

  void set zoomAndPan(int value) { _ptr.zoomAndPan = _unwrap(value); }
}

class _SVGScriptElementImpl extends _SVGElementImpl implements SVGScriptElement {
  _SVGScriptElementImpl._wrap(ptr) : super._wrap(ptr);

  String get type() => _wrap(_ptr.type);

  void set type(String value) { _ptr.type = _unwrap(value); }

  // From SVGURIReference

  SVGAnimatedString get href() => _wrap(_ptr.href);

  // From SVGExternalResourcesRequired

  SVGAnimatedBoolean get externalResourcesRequired() => _wrap(_ptr.externalResourcesRequired);
}

class _SVGSetElementImpl extends _SVGAnimationElementImpl implements SVGSetElement {
  _SVGSetElementImpl._wrap(ptr) : super._wrap(ptr);
}

class _SVGStopElementImpl extends _SVGElementImpl implements SVGStopElement {
  _SVGStopElementImpl._wrap(ptr) : super._wrap(ptr);

  SVGAnimatedNumber get offset() => _wrap(_ptr.offset);

  // From SVGStylable

  SVGAnimatedString get _svgClassName() => _wrap(_ptr.className);

  CSSStyleDeclaration get style() => _wrap(_ptr.style);

  CSSValue getPresentationAttribute(String name) {
    return _wrap(_ptr.getPresentationAttribute(_unwrap(name)));
  }
}

class _SVGStringListImpl extends _DOMTypeBase implements SVGStringList {
  _SVGStringListImpl._wrap(ptr) : super._wrap(ptr);

  int get numberOfItems() => _wrap(_ptr.numberOfItems);

  String appendItem(String item) {
    return _wrap(_ptr.appendItem(_unwrap(item)));
  }

  void clear() {
    _ptr.clear();
    return;
  }

  String getItem(int index) {
    return _wrap(_ptr.getItem(_unwrap(index)));
  }

  String initialize(String item) {
    return _wrap(_ptr.initialize(_unwrap(item)));
  }

  String insertItemBefore(String item, int index) {
    return _wrap(_ptr.insertItemBefore(_unwrap(item), _unwrap(index)));
  }

  String removeItem(int index) {
    return _wrap(_ptr.removeItem(_unwrap(index)));
  }

  String replaceItem(String item, int index) {
    return _wrap(_ptr.replaceItem(_unwrap(item), _unwrap(index)));
  }
}

class _SVGStylableImpl extends _DOMTypeBase implements SVGStylable {
  _SVGStylableImpl._wrap(ptr) : super._wrap(ptr);

  SVGAnimatedString get _svgClassName() => _wrap(_ptr.className);

  CSSStyleDeclaration get style() => _wrap(_ptr.style);

  CSSValue getPresentationAttribute(String name) {
    return _wrap(_ptr.getPresentationAttribute(_unwrap(name)));
  }
}

class _SVGStyleElementImpl extends _SVGElementImpl implements SVGStyleElement {
  _SVGStyleElementImpl._wrap(ptr) : super._wrap(ptr);

  bool get disabled() => _wrap(_ptr.disabled);

  void set disabled(bool value) { _ptr.disabled = _unwrap(value); }

  String get media() => _wrap(_ptr.media);

  void set media(String value) { _ptr.media = _unwrap(value); }

  String get title() => _wrap(_ptr.title);

  void set title(String value) { _ptr.title = _unwrap(value); }

  String get type() => _wrap(_ptr.type);

  void set type(String value) { _ptr.type = _unwrap(value); }

  // From SVGLangSpace

  String get xmllang() => _wrap(_ptr.xmllang);

  void set xmllang(String value) { _ptr.xmllang = _unwrap(value); }

  String get xmlspace() => _wrap(_ptr.xmlspace);

  void set xmlspace(String value) { _ptr.xmlspace = _unwrap(value); }
}

class _SVGSwitchElementImpl extends _SVGElementImpl implements SVGSwitchElement {
  _SVGSwitchElementImpl._wrap(ptr) : super._wrap(ptr);

  // From SVGTests

  SVGStringList get requiredExtensions() => _wrap(_ptr.requiredExtensions);

  SVGStringList get requiredFeatures() => _wrap(_ptr.requiredFeatures);

  SVGStringList get systemLanguage() => _wrap(_ptr.systemLanguage);

  bool hasExtension(String extension) {
    return _wrap(_ptr.hasExtension(_unwrap(extension)));
  }

  // From SVGLangSpace

  String get xmllang() => _wrap(_ptr.xmllang);

  void set xmllang(String value) { _ptr.xmllang = _unwrap(value); }

  String get xmlspace() => _wrap(_ptr.xmlspace);

  void set xmlspace(String value) { _ptr.xmlspace = _unwrap(value); }

  // From SVGExternalResourcesRequired

  SVGAnimatedBoolean get externalResourcesRequired() => _wrap(_ptr.externalResourcesRequired);

  // From SVGStylable

  SVGAnimatedString get _svgClassName() => _wrap(_ptr.className);

  CSSStyleDeclaration get style() => _wrap(_ptr.style);

  CSSValue getPresentationAttribute(String name) {
    return _wrap(_ptr.getPresentationAttribute(_unwrap(name)));
  }

  // From SVGTransformable

  SVGAnimatedTransformList get transform() => _wrap(_ptr.transform);

  // From SVGLocatable

  SVGElement get farthestViewportElement() => _wrap(_ptr.farthestViewportElement);

  SVGElement get nearestViewportElement() => _wrap(_ptr.nearestViewportElement);

  SVGRect getBBox() {
    return _wrap(_ptr.getBBox());
  }

  SVGMatrix getCTM() {
    return _wrap(_ptr.getCTM());
  }

  SVGMatrix getScreenCTM() {
    return _wrap(_ptr.getScreenCTM());
  }

  SVGMatrix getTransformToElement(SVGElement element) {
    return _wrap(_ptr.getTransformToElement(_unwrap(element)));
  }
}

class _SVGSymbolElementImpl extends _SVGElementImpl implements SVGSymbolElement {
  _SVGSymbolElementImpl._wrap(ptr) : super._wrap(ptr);

  // From SVGLangSpace

  String get xmllang() => _wrap(_ptr.xmllang);

  void set xmllang(String value) { _ptr.xmllang = _unwrap(value); }

  String get xmlspace() => _wrap(_ptr.xmlspace);

  void set xmlspace(String value) { _ptr.xmlspace = _unwrap(value); }

  // From SVGExternalResourcesRequired

  SVGAnimatedBoolean get externalResourcesRequired() => _wrap(_ptr.externalResourcesRequired);

  // From SVGStylable

  SVGAnimatedString get _svgClassName() => _wrap(_ptr.className);

  CSSStyleDeclaration get style() => _wrap(_ptr.style);

  CSSValue getPresentationAttribute(String name) {
    return _wrap(_ptr.getPresentationAttribute(_unwrap(name)));
  }

  // From SVGFitToViewBox

  SVGAnimatedPreserveAspectRatio get preserveAspectRatio() => _wrap(_ptr.preserveAspectRatio);

  SVGAnimatedRect get viewBox() => _wrap(_ptr.viewBox);
}

class _SVGTRefElementImpl extends _SVGTextPositioningElementImpl implements SVGTRefElement {
  _SVGTRefElementImpl._wrap(ptr) : super._wrap(ptr);

  // From SVGURIReference

  SVGAnimatedString get href() => _wrap(_ptr.href);
}

class _SVGTSpanElementImpl extends _SVGTextPositioningElementImpl implements SVGTSpanElement {
  _SVGTSpanElementImpl._wrap(ptr) : super._wrap(ptr);
}

class _SVGTestsImpl extends _DOMTypeBase implements SVGTests {
  _SVGTestsImpl._wrap(ptr) : super._wrap(ptr);

  SVGStringList get requiredExtensions() => _wrap(_ptr.requiredExtensions);

  SVGStringList get requiredFeatures() => _wrap(_ptr.requiredFeatures);

  SVGStringList get systemLanguage() => _wrap(_ptr.systemLanguage);

  bool hasExtension(String extension) {
    return _wrap(_ptr.hasExtension(_unwrap(extension)));
  }
}

class _SVGTextContentElementImpl extends _SVGElementImpl implements SVGTextContentElement {
  _SVGTextContentElementImpl._wrap(ptr) : super._wrap(ptr);

  SVGAnimatedEnumeration get lengthAdjust() => _wrap(_ptr.lengthAdjust);

  SVGAnimatedLength get textLength() => _wrap(_ptr.textLength);

  int getCharNumAtPosition(SVGPoint point) {
    return _wrap(_ptr.getCharNumAtPosition(_unwrap(point)));
  }

  num getComputedTextLength() {
    return _wrap(_ptr.getComputedTextLength());
  }

  SVGPoint getEndPositionOfChar(int offset) {
    return _wrap(_ptr.getEndPositionOfChar(_unwrap(offset)));
  }

  SVGRect getExtentOfChar(int offset) {
    return _wrap(_ptr.getExtentOfChar(_unwrap(offset)));
  }

  int getNumberOfChars() {
    return _wrap(_ptr.getNumberOfChars());
  }

  num getRotationOfChar(int offset) {
    return _wrap(_ptr.getRotationOfChar(_unwrap(offset)));
  }

  SVGPoint getStartPositionOfChar(int offset) {
    return _wrap(_ptr.getStartPositionOfChar(_unwrap(offset)));
  }

  num getSubStringLength(int offset, int length) {
    return _wrap(_ptr.getSubStringLength(_unwrap(offset), _unwrap(length)));
  }

  void selectSubString(int offset, int length) {
    _ptr.selectSubString(_unwrap(offset), _unwrap(length));
    return;
  }

  // From SVGTests

  SVGStringList get requiredExtensions() => _wrap(_ptr.requiredExtensions);

  SVGStringList get requiredFeatures() => _wrap(_ptr.requiredFeatures);

  SVGStringList get systemLanguage() => _wrap(_ptr.systemLanguage);

  bool hasExtension(String extension) {
    return _wrap(_ptr.hasExtension(_unwrap(extension)));
  }

  // From SVGLangSpace

  String get xmllang() => _wrap(_ptr.xmllang);

  void set xmllang(String value) { _ptr.xmllang = _unwrap(value); }

  String get xmlspace() => _wrap(_ptr.xmlspace);

  void set xmlspace(String value) { _ptr.xmlspace = _unwrap(value); }

  // From SVGExternalResourcesRequired

  SVGAnimatedBoolean get externalResourcesRequired() => _wrap(_ptr.externalResourcesRequired);

  // From SVGStylable

  SVGAnimatedString get _svgClassName() => _wrap(_ptr.className);

  CSSStyleDeclaration get style() => _wrap(_ptr.style);

  CSSValue getPresentationAttribute(String name) {
    return _wrap(_ptr.getPresentationAttribute(_unwrap(name)));
  }
}

class _SVGTextElementImpl extends _SVGTextPositioningElementImpl implements SVGTextElement {
  _SVGTextElementImpl._wrap(ptr) : super._wrap(ptr);

  // From SVGTransformable

  SVGAnimatedTransformList get transform() => _wrap(_ptr.transform);

  // From SVGLocatable

  SVGElement get farthestViewportElement() => _wrap(_ptr.farthestViewportElement);

  SVGElement get nearestViewportElement() => _wrap(_ptr.nearestViewportElement);

  SVGRect getBBox() {
    return _wrap(_ptr.getBBox());
  }

  SVGMatrix getCTM() {
    return _wrap(_ptr.getCTM());
  }

  SVGMatrix getScreenCTM() {
    return _wrap(_ptr.getScreenCTM());
  }

  SVGMatrix getTransformToElement(SVGElement element) {
    return _wrap(_ptr.getTransformToElement(_unwrap(element)));
  }
}

class _SVGTextPathElementImpl extends _SVGTextContentElementImpl implements SVGTextPathElement {
  _SVGTextPathElementImpl._wrap(ptr) : super._wrap(ptr);

  SVGAnimatedEnumeration get method() => _wrap(_ptr.method);

  SVGAnimatedEnumeration get spacing() => _wrap(_ptr.spacing);

  SVGAnimatedLength get startOffset() => _wrap(_ptr.startOffset);

  // From SVGURIReference

  SVGAnimatedString get href() => _wrap(_ptr.href);
}

class _SVGTextPositioningElementImpl extends _SVGTextContentElementImpl implements SVGTextPositioningElement {
  _SVGTextPositioningElementImpl._wrap(ptr) : super._wrap(ptr);

  SVGAnimatedLengthList get dx() => _wrap(_ptr.dx);

  SVGAnimatedLengthList get dy() => _wrap(_ptr.dy);

  SVGAnimatedNumberList get rotate() => _wrap(_ptr.rotate);

  SVGAnimatedLengthList get x() => _wrap(_ptr.x);

  SVGAnimatedLengthList get y() => _wrap(_ptr.y);
}

class _SVGTitleElementImpl extends _SVGElementImpl implements SVGTitleElement {
  _SVGTitleElementImpl._wrap(ptr) : super._wrap(ptr);

  // From SVGLangSpace

  String get xmllang() => _wrap(_ptr.xmllang);

  void set xmllang(String value) { _ptr.xmllang = _unwrap(value); }

  String get xmlspace() => _wrap(_ptr.xmlspace);

  void set xmlspace(String value) { _ptr.xmlspace = _unwrap(value); }

  // From SVGStylable

  SVGAnimatedString get _svgClassName() => _wrap(_ptr.className);

  CSSStyleDeclaration get style() => _wrap(_ptr.style);

  CSSValue getPresentationAttribute(String name) {
    return _wrap(_ptr.getPresentationAttribute(_unwrap(name)));
  }
}

class _SVGTransformImpl extends _DOMTypeBase implements SVGTransform {
  _SVGTransformImpl._wrap(ptr) : super._wrap(ptr);

  num get angle() => _wrap(_ptr.angle);

  SVGMatrix get matrix() => _wrap(_ptr.matrix);

  int get type() => _wrap(_ptr.type);

  void setMatrix(SVGMatrix matrix) {
    _ptr.setMatrix(_unwrap(matrix));
    return;
  }

  void setRotate(num angle, num cx, num cy) {
    _ptr.setRotate(_unwrap(angle), _unwrap(cx), _unwrap(cy));
    return;
  }

  void setScale(num sx, num sy) {
    _ptr.setScale(_unwrap(sx), _unwrap(sy));
    return;
  }

  void setSkewX(num angle) {
    _ptr.setSkewX(_unwrap(angle));
    return;
  }

  void setSkewY(num angle) {
    _ptr.setSkewY(_unwrap(angle));
    return;
  }

  void setTranslate(num tx, num ty) {
    _ptr.setTranslate(_unwrap(tx), _unwrap(ty));
    return;
  }
}

class _SVGTransformListImpl extends _DOMTypeBase implements SVGTransformList {
  _SVGTransformListImpl._wrap(ptr) : super._wrap(ptr);

  int get numberOfItems() => _wrap(_ptr.numberOfItems);

  SVGTransform appendItem(SVGTransform item) {
    return _wrap(_ptr.appendItem(_unwrap(item)));
  }

  void clear() {
    _ptr.clear();
    return;
  }

  SVGTransform consolidate() {
    return _wrap(_ptr.consolidate());
  }

  SVGTransform createSVGTransformFromMatrix(SVGMatrix matrix) {
    return _wrap(_ptr.createSVGTransformFromMatrix(_unwrap(matrix)));
  }

  SVGTransform getItem(int index) {
    return _wrap(_ptr.getItem(_unwrap(index)));
  }

  SVGTransform initialize(SVGTransform item) {
    return _wrap(_ptr.initialize(_unwrap(item)));
  }

  SVGTransform insertItemBefore(SVGTransform item, int index) {
    return _wrap(_ptr.insertItemBefore(_unwrap(item), _unwrap(index)));
  }

  SVGTransform removeItem(int index) {
    return _wrap(_ptr.removeItem(_unwrap(index)));
  }

  SVGTransform replaceItem(SVGTransform item, int index) {
    return _wrap(_ptr.replaceItem(_unwrap(item), _unwrap(index)));
  }
}

class _SVGTransformableImpl extends _SVGLocatableImpl implements SVGTransformable {
  _SVGTransformableImpl._wrap(ptr) : super._wrap(ptr);

  SVGAnimatedTransformList get transform() => _wrap(_ptr.transform);
}

class _SVGURIReferenceImpl extends _DOMTypeBase implements SVGURIReference {
  _SVGURIReferenceImpl._wrap(ptr) : super._wrap(ptr);

  SVGAnimatedString get href() => _wrap(_ptr.href);
}

class _SVGUnitTypesImpl extends _DOMTypeBase implements SVGUnitTypes {
  _SVGUnitTypesImpl._wrap(ptr) : super._wrap(ptr);
}

class _SVGUseElementImpl extends _SVGElementImpl implements SVGUseElement {
  _SVGUseElementImpl._wrap(ptr) : super._wrap(ptr);

  SVGElementInstance get animatedInstanceRoot() => _wrap(_ptr.animatedInstanceRoot);

  SVGAnimatedLength get height() => _wrap(_ptr.height);

  SVGElementInstance get instanceRoot() => _wrap(_ptr.instanceRoot);

  SVGAnimatedLength get width() => _wrap(_ptr.width);

  SVGAnimatedLength get x() => _wrap(_ptr.x);

  SVGAnimatedLength get y() => _wrap(_ptr.y);

  // From SVGURIReference

  SVGAnimatedString get href() => _wrap(_ptr.href);

  // From SVGTests

  SVGStringList get requiredExtensions() => _wrap(_ptr.requiredExtensions);

  SVGStringList get requiredFeatures() => _wrap(_ptr.requiredFeatures);

  SVGStringList get systemLanguage() => _wrap(_ptr.systemLanguage);

  bool hasExtension(String extension) {
    return _wrap(_ptr.hasExtension(_unwrap(extension)));
  }

  // From SVGLangSpace

  String get xmllang() => _wrap(_ptr.xmllang);

  void set xmllang(String value) { _ptr.xmllang = _unwrap(value); }

  String get xmlspace() => _wrap(_ptr.xmlspace);

  void set xmlspace(String value) { _ptr.xmlspace = _unwrap(value); }

  // From SVGExternalResourcesRequired

  SVGAnimatedBoolean get externalResourcesRequired() => _wrap(_ptr.externalResourcesRequired);

  // From SVGStylable

  SVGAnimatedString get _svgClassName() => _wrap(_ptr.className);

  CSSStyleDeclaration get style() => _wrap(_ptr.style);

  CSSValue getPresentationAttribute(String name) {
    return _wrap(_ptr.getPresentationAttribute(_unwrap(name)));
  }

  // From SVGTransformable

  SVGAnimatedTransformList get transform() => _wrap(_ptr.transform);

  // From SVGLocatable

  SVGElement get farthestViewportElement() => _wrap(_ptr.farthestViewportElement);

  SVGElement get nearestViewportElement() => _wrap(_ptr.nearestViewportElement);

  SVGRect getBBox() {
    return _wrap(_ptr.getBBox());
  }

  SVGMatrix getCTM() {
    return _wrap(_ptr.getCTM());
  }

  SVGMatrix getScreenCTM() {
    return _wrap(_ptr.getScreenCTM());
  }

  SVGMatrix getTransformToElement(SVGElement element) {
    return _wrap(_ptr.getTransformToElement(_unwrap(element)));
  }
}

class _SVGVKernElementImpl extends _SVGElementImpl implements SVGVKernElement {
  _SVGVKernElementImpl._wrap(ptr) : super._wrap(ptr);
}

class _SVGViewElementImpl extends _SVGElementImpl implements SVGViewElement {
  _SVGViewElementImpl._wrap(ptr) : super._wrap(ptr);

  SVGStringList get viewTarget() => _wrap(_ptr.viewTarget);

  // From SVGExternalResourcesRequired

  SVGAnimatedBoolean get externalResourcesRequired() => _wrap(_ptr.externalResourcesRequired);

  // From SVGFitToViewBox

  SVGAnimatedPreserveAspectRatio get preserveAspectRatio() => _wrap(_ptr.preserveAspectRatio);

  SVGAnimatedRect get viewBox() => _wrap(_ptr.viewBox);

  // From SVGZoomAndPan

  int get zoomAndPan() => _wrap(_ptr.zoomAndPan);

  void set zoomAndPan(int value) { _ptr.zoomAndPan = _unwrap(value); }
}

class _SVGViewSpecImpl extends _SVGZoomAndPanImpl implements SVGViewSpec {
  _SVGViewSpecImpl._wrap(ptr) : super._wrap(ptr);

  String get preserveAspectRatioString() => _wrap(_ptr.preserveAspectRatioString);

  SVGTransformList get transform() => _wrap(_ptr.transform);

  String get transformString() => _wrap(_ptr.transformString);

  String get viewBoxString() => _wrap(_ptr.viewBoxString);

  SVGElement get viewTarget() => _wrap(_ptr.viewTarget);

  String get viewTargetString() => _wrap(_ptr.viewTargetString);

  // From SVGFitToViewBox

  SVGAnimatedPreserveAspectRatio get preserveAspectRatio() => _wrap(_ptr.preserveAspectRatio);

  SVGAnimatedRect get viewBox() => _wrap(_ptr.viewBox);
}

class _SVGZoomAndPanImpl extends _DOMTypeBase implements SVGZoomAndPan {
  _SVGZoomAndPanImpl._wrap(ptr) : super._wrap(ptr);

  int get zoomAndPan() => _wrap(_ptr.zoomAndPan);

  void set zoomAndPan(int value) { _ptr.zoomAndPan = _unwrap(value); }
}

class _SVGZoomEventImpl extends _UIEventImpl implements SVGZoomEvent {
  _SVGZoomEventImpl._wrap(ptr) : super._wrap(ptr);

  num get newScale() => _wrap(_ptr.newScale);

  SVGPoint get newTranslate() => _wrap(_ptr.newTranslate);

  num get previousScale() => _wrap(_ptr.previousScale);

  SVGPoint get previousTranslate() => _wrap(_ptr.previousTranslate);

  SVGRect get zoomRectScreen() => _wrap(_ptr.zoomRectScreen);
}

class _ScreenImpl extends _DOMTypeBase implements Screen {
  _ScreenImpl._wrap(ptr) : super._wrap(ptr);

  int get availHeight() => _wrap(_ptr.availHeight);

  int get availLeft() => _wrap(_ptr.availLeft);

  int get availTop() => _wrap(_ptr.availTop);

  int get availWidth() => _wrap(_ptr.availWidth);

  int get colorDepth() => _wrap(_ptr.colorDepth);

  int get height() => _wrap(_ptr.height);

  int get pixelDepth() => _wrap(_ptr.pixelDepth);

  int get width() => _wrap(_ptr.width);
}

class _ScriptElementImpl extends _ElementImpl implements ScriptElement {
  _ScriptElementImpl._wrap(ptr) : super._wrap(ptr);

  bool get async() => _wrap(_ptr.async);

  void set async(bool value) { _ptr.async = _unwrap(value); }

  String get charset() => _wrap(_ptr.charset);

  void set charset(String value) { _ptr.charset = _unwrap(value); }

  String get crossOrigin() => _wrap(_ptr.crossOrigin);

  void set crossOrigin(String value) { _ptr.crossOrigin = _unwrap(value); }

  bool get defer() => _wrap(_ptr.defer);

  void set defer(bool value) { _ptr.defer = _unwrap(value); }

  String get event() => _wrap(_ptr.event);

  void set event(String value) { _ptr.event = _unwrap(value); }

  String get htmlFor() => _wrap(_ptr.htmlFor);

  void set htmlFor(String value) { _ptr.htmlFor = _unwrap(value); }

  String get src() => _wrap(_ptr.src);

  void set src(String value) { _ptr.src = _unwrap(value); }

  String get type() => _wrap(_ptr.type);

  void set type(String value) { _ptr.type = _unwrap(value); }
}

class _ScriptProfileImpl extends _DOMTypeBase implements ScriptProfile {
  _ScriptProfileImpl._wrap(ptr) : super._wrap(ptr);

  ScriptProfileNode get head() => _wrap(_ptr.head);

  String get title() => _wrap(_ptr.title);

  int get uid() => _wrap(_ptr.uid);
}

class _ScriptProfileNodeImpl extends _DOMTypeBase implements ScriptProfileNode {
  _ScriptProfileNodeImpl._wrap(ptr) : super._wrap(ptr);

  int get callUID() => _wrap(_ptr.callUID);

  List get children() => _wrap(_ptr.children);

  String get functionName() => _wrap(_ptr.functionName);

  int get lineNumber() => _wrap(_ptr.lineNumber);

  int get numberOfCalls() => _wrap(_ptr.numberOfCalls);

  num get selfTime() => _wrap(_ptr.selfTime);

  num get totalTime() => _wrap(_ptr.totalTime);

  String get url() => _wrap(_ptr.url);

  bool get visible() => _wrap(_ptr.visible);
}

class _SelectElementImpl extends _ElementImpl implements SelectElement {
  _SelectElementImpl._wrap(ptr) : super._wrap(ptr);

  bool get autofocus() => _wrap(_ptr.autofocus);

  void set autofocus(bool value) { _ptr.autofocus = _unwrap(value); }

  bool get disabled() => _wrap(_ptr.disabled);

  void set disabled(bool value) { _ptr.disabled = _unwrap(value); }

  FormElement get form() => _wrap(_ptr.form);

  NodeList get labels() => _wrap(_ptr.labels);

  int get length() => _wrap(_ptr.length);

  void set length(int value) { _ptr.length = _unwrap(value); }

  bool get multiple() => _wrap(_ptr.multiple);

  void set multiple(bool value) { _ptr.multiple = _unwrap(value); }

  String get name() => _wrap(_ptr.name);

  void set name(String value) { _ptr.name = _unwrap(value); }

  HTMLOptionsCollection get options() => _wrap(_ptr.options);

  bool get required() => _wrap(_ptr.required);

  void set required(bool value) { _ptr.required = _unwrap(value); }

  int get selectedIndex() => _wrap(_ptr.selectedIndex);

  void set selectedIndex(int value) { _ptr.selectedIndex = _unwrap(value); }

  HTMLCollection get selectedOptions() => _wrap(_ptr.selectedOptions);

  int get size() => _wrap(_ptr.size);

  void set size(int value) { _ptr.size = _unwrap(value); }

  String get type() => _wrap(_ptr.type);

  String get validationMessage() => _wrap(_ptr.validationMessage);

  ValidityState get validity() => _wrap(_ptr.validity);

  String get value() => _wrap(_ptr.value);

  void set value(String value) { _ptr.value = _unwrap(value); }

  bool get willValidate() => _wrap(_ptr.willValidate);

  void add(Element element, Element before) {
    _ptr.add(_unwrap(element), _unwrap(before));
    return;
  }

  bool checkValidity() {
    return _wrap(_ptr.checkValidity());
  }

  Node item(int index) {
    return _wrap(_ptr.item(_unwrap(index)));
  }

  Node namedItem(String name) {
    return _wrap(_ptr.namedItem(_unwrap(name)));
  }

  void setCustomValidity(String error) {
    _ptr.setCustomValidity(_unwrap(error));
    return;
  }
}

class _SessionDescriptionImpl extends _DOMTypeBase implements SessionDescription {
  _SessionDescriptionImpl._wrap(ptr) : super._wrap(ptr);

  void addCandidate(IceCandidate candidate) {
    _ptr.addCandidate(_unwrap(candidate));
    return;
  }

  String toSdp() {
    return _wrap(_ptr.toSdp());
  }
}

class _ShadowElementImpl extends _ElementImpl implements ShadowElement {
  _ShadowElementImpl._wrap(ptr) : super._wrap(ptr);
}

class _ShadowRootImpl extends _DocumentFragmentImpl implements ShadowRoot {
  _ShadowRootImpl._wrap(ptr) : super._wrap(ptr);

  Element get activeElement() => _wrap(_ptr.activeElement);

  Element get host() => _wrap(_ptr.host);

  String get innerHTML() => _wrap(_ptr.innerHTML);

  void set innerHTML(String value) { _ptr.innerHTML = _unwrap(value); }

  Element getElementById(String elementId) {
    return _wrap(_ptr.getElementById(_unwrap(elementId)));
  }

  NodeList getElementsByClassName(String className) {
    return _wrap(_ptr.getElementsByClassName(_unwrap(className)));
  }

  NodeList getElementsByTagName(String tagName) {
    return _wrap(_ptr.getElementsByTagName(_unwrap(tagName)));
  }

  NodeList getElementsByTagNameNS(String namespaceURI, String localName) {
    return _wrap(_ptr.getElementsByTagNameNS(_unwrap(namespaceURI), _unwrap(localName)));
  }
}

class _SharedWorkerImpl extends _AbstractWorkerImpl implements SharedWorker {
  _SharedWorkerImpl._wrap(ptr) : super._wrap(ptr);

  MessagePort get port() => _wrap(_ptr.port);
}

class _SharedWorkerContextImpl extends _WorkerContextImpl implements SharedWorkerContext {
  _SharedWorkerContextImpl._wrap(ptr) : super._wrap(ptr);

  String get name() => _wrap(_ptr.name);

  EventListener get onconnect() => _wrap(_ptr.onconnect);

  void set onconnect(EventListener value) { _ptr.onconnect = _unwrap(value); }
}

class _SourceElementImpl extends _ElementImpl implements SourceElement {
  _SourceElementImpl._wrap(ptr) : super._wrap(ptr);

  String get media() => _wrap(_ptr.media);

  void set media(String value) { _ptr.media = _unwrap(value); }

  String get src() => _wrap(_ptr.src);

  void set src(String value) { _ptr.src = _unwrap(value); }

  String get type() => _wrap(_ptr.type);

  void set type(String value) { _ptr.type = _unwrap(value); }
}

class _SpanElementImpl extends _ElementImpl implements SpanElement {
  _SpanElementImpl._wrap(ptr) : super._wrap(ptr);
}

class _SpeechGrammarImpl extends _DOMTypeBase implements SpeechGrammar {
  _SpeechGrammarImpl._wrap(ptr) : super._wrap(ptr);

  String get src() => _wrap(_ptr.src);

  void set src(String value) { _ptr.src = _unwrap(value); }

  num get weight() => _wrap(_ptr.weight);

  void set weight(num value) { _ptr.weight = _unwrap(value); }
}

class _SpeechGrammarListImpl extends _DOMTypeBase implements SpeechGrammarList {
  _SpeechGrammarListImpl._wrap(ptr) : super._wrap(ptr);

  int get length() => _wrap(_ptr.length);

  void addFromString(String string, [num weight = null]) {
    if (weight === null) {
      _ptr.addFromString(_unwrap(string));
      return;
    } else {
      _ptr.addFromString(_unwrap(string), _unwrap(weight));
      return;
    }
  }

  void addFromUri(String src, [num weight = null]) {
    if (weight === null) {
      _ptr.addFromUri(_unwrap(src));
      return;
    } else {
      _ptr.addFromUri(_unwrap(src), _unwrap(weight));
      return;
    }
  }

  SpeechGrammar item(int index) {
    return _wrap(_ptr.item(_unwrap(index)));
  }
}

class _SpeechInputEventImpl extends _EventImpl implements SpeechInputEvent {
  _SpeechInputEventImpl._wrap(ptr) : super._wrap(ptr);

  SpeechInputResultList get results() => _wrap(_ptr.results);
}

class _SpeechInputResultImpl extends _DOMTypeBase implements SpeechInputResult {
  _SpeechInputResultImpl._wrap(ptr) : super._wrap(ptr);

  num get confidence() => _wrap(_ptr.confidence);

  String get utterance() => _wrap(_ptr.utterance);
}

class _SpeechInputResultListImpl extends _DOMTypeBase implements SpeechInputResultList {
  _SpeechInputResultListImpl._wrap(ptr) : super._wrap(ptr);

  int get length() => _wrap(_ptr.length);

  SpeechInputResult item(int index) {
    return _wrap(_ptr.item(_unwrap(index)));
  }
}

class _SpeechRecognitionImpl extends _DOMTypeBase implements SpeechRecognition {
  _SpeechRecognitionImpl._wrap(ptr) : super._wrap(ptr);

  bool get continuous() => _wrap(_ptr.continuous);

  void set continuous(bool value) { _ptr.continuous = _unwrap(value); }

  SpeechGrammarList get grammars() => _wrap(_ptr.grammars);

  void set grammars(SpeechGrammarList value) { _ptr.grammars = _unwrap(value); }

  String get lang() => _wrap(_ptr.lang);

  void set lang(String value) { _ptr.lang = _unwrap(value); }

  EventListener get onaudioend() => _wrap(_ptr.onaudioend);

  void set onaudioend(EventListener value) { _ptr.onaudioend = _unwrap(value); }

  EventListener get onaudiostart() => _wrap(_ptr.onaudiostart);

  void set onaudiostart(EventListener value) { _ptr.onaudiostart = _unwrap(value); }

  EventListener get onend() => _wrap(_ptr.onend);

  void set onend(EventListener value) { _ptr.onend = _unwrap(value); }

  EventListener get onerror() => _wrap(_ptr.onerror);

  void set onerror(EventListener value) { _ptr.onerror = _unwrap(value); }

  EventListener get onnomatch() => _wrap(_ptr.onnomatch);

  void set onnomatch(EventListener value) { _ptr.onnomatch = _unwrap(value); }

  EventListener get onresult() => _wrap(_ptr.onresult);

  void set onresult(EventListener value) { _ptr.onresult = _unwrap(value); }

  EventListener get onresultdeleted() => _wrap(_ptr.onresultdeleted);

  void set onresultdeleted(EventListener value) { _ptr.onresultdeleted = _unwrap(value); }

  EventListener get onsoundend() => _wrap(_ptr.onsoundend);

  void set onsoundend(EventListener value) { _ptr.onsoundend = _unwrap(value); }

  EventListener get onsoundstart() => _wrap(_ptr.onsoundstart);

  void set onsoundstart(EventListener value) { _ptr.onsoundstart = _unwrap(value); }

  EventListener get onspeechend() => _wrap(_ptr.onspeechend);

  void set onspeechend(EventListener value) { _ptr.onspeechend = _unwrap(value); }

  EventListener get onspeechstart() => _wrap(_ptr.onspeechstart);

  void set onspeechstart(EventListener value) { _ptr.onspeechstart = _unwrap(value); }

  EventListener get onstart() => _wrap(_ptr.onstart);

  void set onstart(EventListener value) { _ptr.onstart = _unwrap(value); }

  void abort() {
    _ptr.abort();
    return;
  }

  void start() {
    _ptr.start();
    return;
  }

  void stop() {
    _ptr.stop();
    return;
  }
}

class _SpeechRecognitionAlternativeImpl extends _DOMTypeBase implements SpeechRecognitionAlternative {
  _SpeechRecognitionAlternativeImpl._wrap(ptr) : super._wrap(ptr);

  num get confidence() => _wrap(_ptr.confidence);

  String get transcript() => _wrap(_ptr.transcript);
}

class _SpeechRecognitionErrorImpl extends _DOMTypeBase implements SpeechRecognitionError {
  _SpeechRecognitionErrorImpl._wrap(ptr) : super._wrap(ptr);

  int get code() => _wrap(_ptr.code);

  String get message() => _wrap(_ptr.message);
}

class _SpeechRecognitionEventImpl extends _EventImpl implements SpeechRecognitionEvent {
  _SpeechRecognitionEventImpl._wrap(ptr) : super._wrap(ptr);

  SpeechRecognitionError get error() => _wrap(_ptr.error);

  SpeechRecognitionResult get result() => _wrap(_ptr.result);

  SpeechRecognitionResultList get resultHistory() => _wrap(_ptr.resultHistory);

  int get resultIndex() => _wrap(_ptr.resultIndex);
}

class _SpeechRecognitionResultImpl extends _DOMTypeBase implements SpeechRecognitionResult {
  _SpeechRecognitionResultImpl._wrap(ptr) : super._wrap(ptr);

  bool get finalValue() => _wrap(_ptr.finalValue);

  int get length() => _wrap(_ptr.length);

  SpeechRecognitionAlternative item(int index) {
    return _wrap(_ptr.item(_unwrap(index)));
  }
}

class _SpeechRecognitionResultListImpl extends _DOMTypeBase implements SpeechRecognitionResultList {
  _SpeechRecognitionResultListImpl._wrap(ptr) : super._wrap(ptr);

  int get length() => _wrap(_ptr.length);

  SpeechRecognitionResult item(int index) {
    return _wrap(_ptr.item(_unwrap(index)));
  }
}

class _StorageImpl extends _DOMTypeBase implements Storage {
  _StorageImpl._wrap(ptr) : super._wrap(ptr);

  int get length() => _wrap(_ptr.length);

  void clear() {
    _ptr.clear();
    return;
  }

  String getItem(String key) {
    return _wrap(_ptr.getItem(_unwrap(key)));
  }

  String key(int index) {
    return _wrap(_ptr.key(_unwrap(index)));
  }

  void removeItem(String key) {
    _ptr.removeItem(_unwrap(key));
    return;
  }

  void setItem(String key, String data) {
    _ptr.setItem(_unwrap(key), _unwrap(data));
    return;
  }
}

class _StorageEventImpl extends _EventImpl implements StorageEvent {
  _StorageEventImpl._wrap(ptr) : super._wrap(ptr);

  String get key() => _wrap(_ptr.key);

  String get newValue() => _wrap(_ptr.newValue);

  String get oldValue() => _wrap(_ptr.oldValue);

  Storage get storageArea() => _wrap(_ptr.storageArea);

  String get url() => _wrap(_ptr.url);

  void initStorageEvent(String typeArg, bool canBubbleArg, bool cancelableArg, String keyArg, String oldValueArg, String newValueArg, String urlArg, Storage storageAreaArg) {
    _ptr.initStorageEvent(_unwrap(typeArg), _unwrap(canBubbleArg), _unwrap(cancelableArg), _unwrap(keyArg), _unwrap(oldValueArg), _unwrap(newValueArg), _unwrap(urlArg), _unwrap(storageAreaArg));
    return;
  }
}

class _StorageInfoImpl extends _DOMTypeBase implements StorageInfo {
  _StorageInfoImpl._wrap(ptr) : super._wrap(ptr);

  void queryUsageAndQuota(int storageType, [StorageInfoUsageCallback usageCallback = null, StorageInfoErrorCallback errorCallback = null]) {
    if (usageCallback === null) {
      if (errorCallback === null) {
        _ptr.queryUsageAndQuota(_unwrap(storageType));
        return;
      }
    } else {
      if (errorCallback === null) {
        _ptr.queryUsageAndQuota(_unwrap(storageType), _unwrap(usageCallback));
        return;
      } else {
        _ptr.queryUsageAndQuota(_unwrap(storageType), _unwrap(usageCallback), _unwrap(errorCallback));
        return;
      }
    }
    throw "Incorrect number or type of arguments";
  }

  void requestQuota(int storageType, int newQuotaInBytes, [StorageInfoQuotaCallback quotaCallback = null, StorageInfoErrorCallback errorCallback = null]) {
    if (quotaCallback === null) {
      if (errorCallback === null) {
        _ptr.requestQuota(_unwrap(storageType), _unwrap(newQuotaInBytes));
        return;
      }
    } else {
      if (errorCallback === null) {
        _ptr.requestQuota(_unwrap(storageType), _unwrap(newQuotaInBytes), _unwrap(quotaCallback));
        return;
      } else {
        _ptr.requestQuota(_unwrap(storageType), _unwrap(newQuotaInBytes), _unwrap(quotaCallback), _unwrap(errorCallback));
        return;
      }
    }
    throw "Incorrect number or type of arguments";
  }
}

class _StyleElementImpl extends _ElementImpl implements StyleElement {
  _StyleElementImpl._wrap(ptr) : super._wrap(ptr);

  bool get disabled() => _wrap(_ptr.disabled);

  void set disabled(bool value) { _ptr.disabled = _unwrap(value); }

  String get media() => _wrap(_ptr.media);

  void set media(String value) { _ptr.media = _unwrap(value); }

  StyleSheet get sheet() => _wrap(_ptr.sheet);

  String get type() => _wrap(_ptr.type);

  void set type(String value) { _ptr.type = _unwrap(value); }
}

class _StyleMediaImpl extends _DOMTypeBase implements StyleMedia {
  _StyleMediaImpl._wrap(ptr) : super._wrap(ptr);

  String get type() => _wrap(_ptr.type);

  bool matchMedium(String mediaquery) {
    return _wrap(_ptr.matchMedium(_unwrap(mediaquery)));
  }
}

class _StyleSheetImpl extends _DOMTypeBase implements StyleSheet {
  _StyleSheetImpl._wrap(ptr) : super._wrap(ptr);

  bool get disabled() => _wrap(_ptr.disabled);

  void set disabled(bool value) { _ptr.disabled = _unwrap(value); }

  String get href() => _wrap(_ptr.href);

  MediaList get media() => _wrap(_ptr.media);

  Node get ownerNode() => _wrap(_ptr.ownerNode);

  StyleSheet get parentStyleSheet() => _wrap(_ptr.parentStyleSheet);

  String get title() => _wrap(_ptr.title);

  String get type() => _wrap(_ptr.type);
}

class _StyleSheetListImpl extends _DOMTypeBase implements StyleSheetList {
  _StyleSheetListImpl._wrap(ptr) : super._wrap(ptr);

  int get length() => _wrap(_ptr.length);

  StyleSheet operator[](int index) => _wrap(_ptr[index]);


  void operator[]=(int index, StyleSheet value) {
    throw new UnsupportedOperationException("Cannot assign element of immutable List.");
  }

  void add(StyleSheet value) {
    throw new UnsupportedOperationException("Cannot add to immutable List.");
  }

  void addLast(StyleSheet value) {
    throw new UnsupportedOperationException("Cannot add to immutable List.");
  }

  void addAll(Collection<StyleSheet> collection) {
    throw new UnsupportedOperationException("Cannot add to immutable List.");
  }

  void sort(int compare(StyleSheet a, StyleSheet b)) {
    throw new UnsupportedOperationException("Cannot sort immutable List.");
  }

  void copyFrom(List<Object> src, int srcStart, int dstStart, int count) {
    throw new UnsupportedOperationException("This object is immutable.");
  }

  int indexOf(StyleSheet element, [int start = 0]) {
    return _Lists.indexOf(this, element, start, this.length);
  }

  int lastIndexOf(StyleSheet element, [int start = null]) {
    if (start === null) start = length - 1;
    return _Lists.lastIndexOf(this, element, start);
  }

  int clear() {
    throw new UnsupportedOperationException("Cannot clear immutable List.");
  }

  StyleSheet removeLast() {
    throw new UnsupportedOperationException("Cannot removeLast on immutable List.");
  }

  StyleSheet last() {
    return this[length - 1];
  }

  void forEach(void f(StyleSheet element)) {
    _Collections.forEach(this, f);
  }

  Collection map(f(StyleSheet element)) {
    return _Collections.map(this, [], f);
  }

  Collection<StyleSheet> filter(bool f(StyleSheet element)) {
    return _Collections.filter(this, new List<StyleSheet>(), f);
  }

  bool every(bool f(StyleSheet element)) {
    return _Collections.every(this, f);
  }

  bool some(bool f(StyleSheet element)) {
    return _Collections.some(this, f);
  }

  void setRange(int start, int length, List<StyleSheet> from, [int startFrom]) {
    throw new UnsupportedOperationException("Cannot setRange on immutable List.");
  }

  void removeRange(int start, int length) {
    throw new UnsupportedOperationException("Cannot removeRange on immutable List.");
  }

  void insertRange(int start, int length, [StyleSheet initialValue]) {
    throw new UnsupportedOperationException("Cannot insertRange on immutable List.");
  }

  List<StyleSheet> getRange(int start, int length) {
    throw new NotImplementedException();
  }

  bool isEmpty() {
    return length == 0;
  }

  Iterator<StyleSheet> iterator() {
    return new _FixedSizeListIterator<StyleSheet>(this);
  }

  StyleSheet item(int index) {
    return _wrap(_ptr.item(_unwrap(index)));
  }
}

class _TableCaptionElementImpl extends _ElementImpl implements TableCaptionElement {
  _TableCaptionElementImpl._wrap(ptr) : super._wrap(ptr);

  String get align() => _wrap(_ptr.align);

  void set align(String value) { _ptr.align = _unwrap(value); }
}

class _TableCellElementImpl extends _ElementImpl implements TableCellElement {
  _TableCellElementImpl._wrap(ptr) : super._wrap(ptr);

  String get abbr() => _wrap(_ptr.abbr);

  void set abbr(String value) { _ptr.abbr = _unwrap(value); }

  String get align() => _wrap(_ptr.align);

  void set align(String value) { _ptr.align = _unwrap(value); }

  String get axis() => _wrap(_ptr.axis);

  void set axis(String value) { _ptr.axis = _unwrap(value); }

  String get bgColor() => _wrap(_ptr.bgColor);

  void set bgColor(String value) { _ptr.bgColor = _unwrap(value); }

  int get cellIndex() => _wrap(_ptr.cellIndex);

  String get ch() => _wrap(_ptr.ch);

  void set ch(String value) { _ptr.ch = _unwrap(value); }

  String get chOff() => _wrap(_ptr.chOff);

  void set chOff(String value) { _ptr.chOff = _unwrap(value); }

  int get colSpan() => _wrap(_ptr.colSpan);

  void set colSpan(int value) { _ptr.colSpan = _unwrap(value); }

  String get headers() => _wrap(_ptr.headers);

  void set headers(String value) { _ptr.headers = _unwrap(value); }

  String get height() => _wrap(_ptr.height);

  void set height(String value) { _ptr.height = _unwrap(value); }

  bool get noWrap() => _wrap(_ptr.noWrap);

  void set noWrap(bool value) { _ptr.noWrap = _unwrap(value); }

  int get rowSpan() => _wrap(_ptr.rowSpan);

  void set rowSpan(int value) { _ptr.rowSpan = _unwrap(value); }

  String get scope() => _wrap(_ptr.scope);

  void set scope(String value) { _ptr.scope = _unwrap(value); }

  String get vAlign() => _wrap(_ptr.vAlign);

  void set vAlign(String value) { _ptr.vAlign = _unwrap(value); }

  String get width() => _wrap(_ptr.width);

  void set width(String value) { _ptr.width = _unwrap(value); }
}

class _TableColElementImpl extends _ElementImpl implements TableColElement {
  _TableColElementImpl._wrap(ptr) : super._wrap(ptr);

  String get align() => _wrap(_ptr.align);

  void set align(String value) { _ptr.align = _unwrap(value); }

  String get ch() => _wrap(_ptr.ch);

  void set ch(String value) { _ptr.ch = _unwrap(value); }

  String get chOff() => _wrap(_ptr.chOff);

  void set chOff(String value) { _ptr.chOff = _unwrap(value); }

  int get span() => _wrap(_ptr.span);

  void set span(int value) { _ptr.span = _unwrap(value); }

  String get vAlign() => _wrap(_ptr.vAlign);

  void set vAlign(String value) { _ptr.vAlign = _unwrap(value); }

  String get width() => _wrap(_ptr.width);

  void set width(String value) { _ptr.width = _unwrap(value); }
}

class _TableElementImpl extends _ElementImpl implements TableElement {
  _TableElementImpl._wrap(ptr) : super._wrap(ptr);

  String get align() => _wrap(_ptr.align);

  void set align(String value) { _ptr.align = _unwrap(value); }

  String get bgColor() => _wrap(_ptr.bgColor);

  void set bgColor(String value) { _ptr.bgColor = _unwrap(value); }

  String get border() => _wrap(_ptr.border);

  void set border(String value) { _ptr.border = _unwrap(value); }

  TableCaptionElement get caption() => _wrap(_ptr.caption);

  void set caption(TableCaptionElement value) { _ptr.caption = _unwrap(value); }

  String get cellPadding() => _wrap(_ptr.cellPadding);

  void set cellPadding(String value) { _ptr.cellPadding = _unwrap(value); }

  String get cellSpacing() => _wrap(_ptr.cellSpacing);

  void set cellSpacing(String value) { _ptr.cellSpacing = _unwrap(value); }

  String get frame() => _wrap(_ptr.frame);

  void set frame(String value) { _ptr.frame = _unwrap(value); }

  HTMLCollection get rows() => _wrap(_ptr.rows);

  String get rules() => _wrap(_ptr.rules);

  void set rules(String value) { _ptr.rules = _unwrap(value); }

  String get summary() => _wrap(_ptr.summary);

  void set summary(String value) { _ptr.summary = _unwrap(value); }

  HTMLCollection get tBodies() => _wrap(_ptr.tBodies);

  TableSectionElement get tFoot() => _wrap(_ptr.tFoot);

  void set tFoot(TableSectionElement value) { _ptr.tFoot = _unwrap(value); }

  TableSectionElement get tHead() => _wrap(_ptr.tHead);

  void set tHead(TableSectionElement value) { _ptr.tHead = _unwrap(value); }

  String get width() => _wrap(_ptr.width);

  void set width(String value) { _ptr.width = _unwrap(value); }

  Element createCaption() {
    return _wrap(_ptr.createCaption());
  }

  Element createTFoot() {
    return _wrap(_ptr.createTFoot());
  }

  Element createTHead() {
    return _wrap(_ptr.createTHead());
  }

  void deleteCaption() {
    _ptr.deleteCaption();
    return;
  }

  void deleteRow(int index) {
    _ptr.deleteRow(_unwrap(index));
    return;
  }

  void deleteTFoot() {
    _ptr.deleteTFoot();
    return;
  }

  void deleteTHead() {
    _ptr.deleteTHead();
    return;
  }

  Element insertRow(int index) {
    return _wrap(_ptr.insertRow(_unwrap(index)));
  }
}

class _TableRowElementImpl extends _ElementImpl implements TableRowElement {
  _TableRowElementImpl._wrap(ptr) : super._wrap(ptr);

  String get align() => _wrap(_ptr.align);

  void set align(String value) { _ptr.align = _unwrap(value); }

  String get bgColor() => _wrap(_ptr.bgColor);

  void set bgColor(String value) { _ptr.bgColor = _unwrap(value); }

  HTMLCollection get cells() => _wrap(_ptr.cells);

  String get ch() => _wrap(_ptr.ch);

  void set ch(String value) { _ptr.ch = _unwrap(value); }

  String get chOff() => _wrap(_ptr.chOff);

  void set chOff(String value) { _ptr.chOff = _unwrap(value); }

  int get rowIndex() => _wrap(_ptr.rowIndex);

  int get sectionRowIndex() => _wrap(_ptr.sectionRowIndex);

  String get vAlign() => _wrap(_ptr.vAlign);

  void set vAlign(String value) { _ptr.vAlign = _unwrap(value); }

  void deleteCell(int index) {
    _ptr.deleteCell(_unwrap(index));
    return;
  }

  Element insertCell(int index) {
    return _wrap(_ptr.insertCell(_unwrap(index)));
  }
}

class _TableSectionElementImpl extends _ElementImpl implements TableSectionElement {
  _TableSectionElementImpl._wrap(ptr) : super._wrap(ptr);

  String get align() => _wrap(_ptr.align);

  void set align(String value) { _ptr.align = _unwrap(value); }

  String get ch() => _wrap(_ptr.ch);

  void set ch(String value) { _ptr.ch = _unwrap(value); }

  String get chOff() => _wrap(_ptr.chOff);

  void set chOff(String value) { _ptr.chOff = _unwrap(value); }

  HTMLCollection get rows() => _wrap(_ptr.rows);

  String get vAlign() => _wrap(_ptr.vAlign);

  void set vAlign(String value) { _ptr.vAlign = _unwrap(value); }

  void deleteRow(int index) {
    _ptr.deleteRow(_unwrap(index));
    return;
  }

  Element insertRow(int index) {
    return _wrap(_ptr.insertRow(_unwrap(index)));
  }
}

class _TextImpl extends _CharacterDataImpl implements Text {
  _TextImpl._wrap(ptr) : super._wrap(ptr);

  String get wholeText() => _wrap(_ptr.wholeText);

  Text replaceWholeText(String content) {
    return _wrap(_ptr.replaceWholeText(_unwrap(content)));
  }

  Text splitText(int offset) {
    return _wrap(_ptr.splitText(_unwrap(offset)));
  }
}

class _TextAreaElementImpl extends _ElementImpl implements TextAreaElement {
  _TextAreaElementImpl._wrap(ptr) : super._wrap(ptr);

  bool get autofocus() => _wrap(_ptr.autofocus);

  void set autofocus(bool value) { _ptr.autofocus = _unwrap(value); }

  int get cols() => _wrap(_ptr.cols);

  void set cols(int value) { _ptr.cols = _unwrap(value); }

  String get defaultValue() => _wrap(_ptr.defaultValue);

  void set defaultValue(String value) { _ptr.defaultValue = _unwrap(value); }

  bool get disabled() => _wrap(_ptr.disabled);

  void set disabled(bool value) { _ptr.disabled = _unwrap(value); }

  FormElement get form() => _wrap(_ptr.form);

  NodeList get labels() => _wrap(_ptr.labels);

  int get maxLength() => _wrap(_ptr.maxLength);

  void set maxLength(int value) { _ptr.maxLength = _unwrap(value); }

  String get name() => _wrap(_ptr.name);

  void set name(String value) { _ptr.name = _unwrap(value); }

  String get placeholder() => _wrap(_ptr.placeholder);

  void set placeholder(String value) { _ptr.placeholder = _unwrap(value); }

  bool get readOnly() => _wrap(_ptr.readOnly);

  void set readOnly(bool value) { _ptr.readOnly = _unwrap(value); }

  bool get required() => _wrap(_ptr.required);

  void set required(bool value) { _ptr.required = _unwrap(value); }

  int get rows() => _wrap(_ptr.rows);

  void set rows(int value) { _ptr.rows = _unwrap(value); }

  String get selectionDirection() => _wrap(_ptr.selectionDirection);

  void set selectionDirection(String value) { _ptr.selectionDirection = _unwrap(value); }

  int get selectionEnd() => _wrap(_ptr.selectionEnd);

  void set selectionEnd(int value) { _ptr.selectionEnd = _unwrap(value); }

  int get selectionStart() => _wrap(_ptr.selectionStart);

  void set selectionStart(int value) { _ptr.selectionStart = _unwrap(value); }

  int get textLength() => _wrap(_ptr.textLength);

  String get type() => _wrap(_ptr.type);

  String get validationMessage() => _wrap(_ptr.validationMessage);

  ValidityState get validity() => _wrap(_ptr.validity);

  String get value() => _wrap(_ptr.value);

  void set value(String value) { _ptr.value = _unwrap(value); }

  bool get willValidate() => _wrap(_ptr.willValidate);

  String get wrap() => _wrap(_ptr.wrap);

  void set wrap(String value) { _ptr.wrap = _unwrap(value); }

  bool checkValidity() {
    return _wrap(_ptr.checkValidity());
  }

  void select() {
    _ptr.select();
    return;
  }

  void setCustomValidity(String error) {
    _ptr.setCustomValidity(_unwrap(error));
    return;
  }

  void setSelectionRange(int start, int end, [String direction = null]) {
    if (direction === null) {
      _ptr.setSelectionRange(_unwrap(start), _unwrap(end));
      return;
    } else {
      _ptr.setSelectionRange(_unwrap(start), _unwrap(end), _unwrap(direction));
      return;
    }
  }
}

class _TextEventImpl extends _UIEventImpl implements TextEvent {
  _TextEventImpl._wrap(ptr) : super._wrap(ptr);

  String get data() => _wrap(_ptr.data);

  void initTextEvent(String typeArg, bool canBubbleArg, bool cancelableArg, Window viewArg, String dataArg) {
    _ptr.initTextEvent(_unwrap(typeArg), _unwrap(canBubbleArg), _unwrap(cancelableArg), _unwrap(viewArg), _unwrap(dataArg));
    return;
  }
}

class _TextMetricsImpl extends _DOMTypeBase implements TextMetrics {
  _TextMetricsImpl._wrap(ptr) : super._wrap(ptr);

  num get width() => _wrap(_ptr.width);
}

class _TextTrackImpl extends _DOMTypeBase implements TextTrack {
  _TextTrackImpl._wrap(ptr) : super._wrap(ptr);

  TextTrackCueList get activeCues() => _wrap(_ptr.activeCues);

  TextTrackCueList get cues() => _wrap(_ptr.cues);

  String get kind() => _wrap(_ptr.kind);

  String get label() => _wrap(_ptr.label);

  String get language() => _wrap(_ptr.language);

  int get mode() => _wrap(_ptr.mode);

  void set mode(int value) { _ptr.mode = _unwrap(value); }

  EventListener get oncuechange() => _wrap(_ptr.oncuechange);

  void set oncuechange(EventListener value) { _ptr.oncuechange = _unwrap(value); }

  void addCue(TextTrackCue cue) {
    _ptr.addCue(_unwrap(cue));
    return;
  }

  void addEventListener(String type, EventListener listener, [bool useCapture = null]) {
    if (useCapture === null) {
      _ptr.addEventListener(_unwrap(type), _unwrap(listener));
      return;
    } else {
      _ptr.addEventListener(_unwrap(type), _unwrap(listener), _unwrap(useCapture));
      return;
    }
  }

  bool dispatchEvent(Event evt) {
    return _wrap(_ptr.dispatchEvent(_unwrap(evt)));
  }

  void removeCue(TextTrackCue cue) {
    _ptr.removeCue(_unwrap(cue));
    return;
  }

  void removeEventListener(String type, EventListener listener, [bool useCapture = null]) {
    if (useCapture === null) {
      _ptr.removeEventListener(_unwrap(type), _unwrap(listener));
      return;
    } else {
      _ptr.removeEventListener(_unwrap(type), _unwrap(listener), _unwrap(useCapture));
      return;
    }
  }
}

class _TextTrackCueImpl extends _DOMTypeBase implements TextTrackCue {
  _TextTrackCueImpl._wrap(ptr) : super._wrap(ptr);

  String get align() => _wrap(_ptr.align);

  void set align(String value) { _ptr.align = _unwrap(value); }

  num get endTime() => _wrap(_ptr.endTime);

  void set endTime(num value) { _ptr.endTime = _unwrap(value); }

  String get id() => _wrap(_ptr.id);

  void set id(String value) { _ptr.id = _unwrap(value); }

  int get line() => _wrap(_ptr.line);

  void set line(int value) { _ptr.line = _unwrap(value); }

  EventListener get onenter() => _wrap(_ptr.onenter);

  void set onenter(EventListener value) { _ptr.onenter = _unwrap(value); }

  EventListener get onexit() => _wrap(_ptr.onexit);

  void set onexit(EventListener value) { _ptr.onexit = _unwrap(value); }

  bool get pauseOnExit() => _wrap(_ptr.pauseOnExit);

  void set pauseOnExit(bool value) { _ptr.pauseOnExit = _unwrap(value); }

  int get position() => _wrap(_ptr.position);

  void set position(int value) { _ptr.position = _unwrap(value); }

  int get size() => _wrap(_ptr.size);

  void set size(int value) { _ptr.size = _unwrap(value); }

  bool get snapToLines() => _wrap(_ptr.snapToLines);

  void set snapToLines(bool value) { _ptr.snapToLines = _unwrap(value); }

  num get startTime() => _wrap(_ptr.startTime);

  void set startTime(num value) { _ptr.startTime = _unwrap(value); }

  String get text() => _wrap(_ptr.text);

  void set text(String value) { _ptr.text = _unwrap(value); }

  TextTrack get track() => _wrap(_ptr.track);

  String get vertical() => _wrap(_ptr.vertical);

  void set vertical(String value) { _ptr.vertical = _unwrap(value); }

  void addEventListener(String type, EventListener listener, [bool useCapture = null]) {
    if (useCapture === null) {
      _ptr.addEventListener(_unwrap(type), _unwrap(listener));
      return;
    } else {
      _ptr.addEventListener(_unwrap(type), _unwrap(listener), _unwrap(useCapture));
      return;
    }
  }

  bool dispatchEvent(Event evt) {
    return _wrap(_ptr.dispatchEvent(_unwrap(evt)));
  }

  DocumentFragment getCueAsHTML() {
    return _wrap(_ptr.getCueAsHTML());
  }

  void removeEventListener(String type, EventListener listener, [bool useCapture = null]) {
    if (useCapture === null) {
      _ptr.removeEventListener(_unwrap(type), _unwrap(listener));
      return;
    } else {
      _ptr.removeEventListener(_unwrap(type), _unwrap(listener), _unwrap(useCapture));
      return;
    }
  }
}

class _TextTrackCueListImpl extends _DOMTypeBase implements TextTrackCueList {
  _TextTrackCueListImpl._wrap(ptr) : super._wrap(ptr);

  int get length() => _wrap(_ptr.length);

  TextTrackCue getCueById(String id) {
    return _wrap(_ptr.getCueById(_unwrap(id)));
  }

  TextTrackCue item(int index) {
    return _wrap(_ptr.item(_unwrap(index)));
  }
}

class _TextTrackListImpl extends _DOMTypeBase implements TextTrackList {
  _TextTrackListImpl._wrap(ptr) : super._wrap(ptr);

  int get length() => _wrap(_ptr.length);

  EventListener get onaddtrack() => _wrap(_ptr.onaddtrack);

  void set onaddtrack(EventListener value) { _ptr.onaddtrack = _unwrap(value); }

  void addEventListener(String type, EventListener listener, [bool useCapture = null]) {
    if (useCapture === null) {
      _ptr.addEventListener(_unwrap(type), _unwrap(listener));
      return;
    } else {
      _ptr.addEventListener(_unwrap(type), _unwrap(listener), _unwrap(useCapture));
      return;
    }
  }

  bool dispatchEvent(Event evt) {
    return _wrap(_ptr.dispatchEvent(_unwrap(evt)));
  }

  TextTrack item(int index) {
    return _wrap(_ptr.item(_unwrap(index)));
  }

  void removeEventListener(String type, EventListener listener, [bool useCapture = null]) {
    if (useCapture === null) {
      _ptr.removeEventListener(_unwrap(type), _unwrap(listener));
      return;
    } else {
      _ptr.removeEventListener(_unwrap(type), _unwrap(listener), _unwrap(useCapture));
      return;
    }
  }
}

class _TimeRangesImpl extends _DOMTypeBase implements TimeRanges {
  _TimeRangesImpl._wrap(ptr) : super._wrap(ptr);

  int get length() => _wrap(_ptr.length);

  num end(int index) {
    return _wrap(_ptr.end(_unwrap(index)));
  }

  num start(int index) {
    return _wrap(_ptr.start(_unwrap(index)));
  }
}

class _TitleElementImpl extends _ElementImpl implements TitleElement {
  _TitleElementImpl._wrap(ptr) : super._wrap(ptr);
}

class _TouchImpl extends _DOMTypeBase implements Touch {
  _TouchImpl._wrap(ptr) : super._wrap(ptr);

  int get clientX() => _wrap(_ptr.clientX);

  int get clientY() => _wrap(_ptr.clientY);

  int get identifier() => _wrap(_ptr.identifier);

  int get pageX() => _wrap(_ptr.pageX);

  int get pageY() => _wrap(_ptr.pageY);

  int get screenX() => _wrap(_ptr.screenX);

  int get screenY() => _wrap(_ptr.screenY);

  EventTarget get target() => _FixHtmlDocumentReference(_wrap(_ptr.target));

  num get webkitForce() => _wrap(_ptr.webkitForce);

  int get webkitRadiusX() => _wrap(_ptr.webkitRadiusX);

  int get webkitRadiusY() => _wrap(_ptr.webkitRadiusY);

  num get webkitRotationAngle() => _wrap(_ptr.webkitRotationAngle);
}

class _TouchEventImpl extends _UIEventImpl implements TouchEvent {
  _TouchEventImpl._wrap(ptr) : super._wrap(ptr);

  bool get altKey() => _wrap(_ptr.altKey);

  TouchList get changedTouches() => _wrap(_ptr.changedTouches);

  bool get ctrlKey() => _wrap(_ptr.ctrlKey);

  bool get metaKey() => _wrap(_ptr.metaKey);

  bool get shiftKey() => _wrap(_ptr.shiftKey);

  TouchList get targetTouches() => _wrap(_ptr.targetTouches);

  TouchList get touches() => _wrap(_ptr.touches);

  void initTouchEvent(TouchList touches, TouchList targetTouches, TouchList changedTouches, String type, Window view, int screenX, int screenY, int clientX, int clientY, bool ctrlKey, bool altKey, bool shiftKey, bool metaKey) {
    _ptr.initTouchEvent(_unwrap(touches), _unwrap(targetTouches), _unwrap(changedTouches), _unwrap(type), _unwrap(view), _unwrap(screenX), _unwrap(screenY), _unwrap(clientX), _unwrap(clientY), _unwrap(ctrlKey), _unwrap(altKey), _unwrap(shiftKey), _unwrap(metaKey));
    return;
  }
}

class _TouchListImpl extends _DOMTypeBase implements TouchList {
  _TouchListImpl._wrap(ptr) : super._wrap(ptr);

  int get length() => _wrap(_ptr.length);

  Touch operator[](int index) => _wrap(_ptr[index]);


  void operator[]=(int index, Touch value) {
    throw new UnsupportedOperationException("Cannot assign element of immutable List.");
  }

  void add(Touch value) {
    throw new UnsupportedOperationException("Cannot add to immutable List.");
  }

  void addLast(Touch value) {
    throw new UnsupportedOperationException("Cannot add to immutable List.");
  }

  void addAll(Collection<Touch> collection) {
    throw new UnsupportedOperationException("Cannot add to immutable List.");
  }

  void sort(int compare(Touch a, Touch b)) {
    throw new UnsupportedOperationException("Cannot sort immutable List.");
  }

  void copyFrom(List<Object> src, int srcStart, int dstStart, int count) {
    throw new UnsupportedOperationException("This object is immutable.");
  }

  int indexOf(Touch element, [int start = 0]) {
    return _Lists.indexOf(this, element, start, this.length);
  }

  int lastIndexOf(Touch element, [int start = null]) {
    if (start === null) start = length - 1;
    return _Lists.lastIndexOf(this, element, start);
  }

  int clear() {
    throw new UnsupportedOperationException("Cannot clear immutable List.");
  }

  Touch removeLast() {
    throw new UnsupportedOperationException("Cannot removeLast on immutable List.");
  }

  Touch last() {
    return this[length - 1];
  }

  void forEach(void f(Touch element)) {
    _Collections.forEach(this, f);
  }

  Collection map(f(Touch element)) {
    return _Collections.map(this, [], f);
  }

  Collection<Touch> filter(bool f(Touch element)) {
    return _Collections.filter(this, new List<Touch>(), f);
  }

  bool every(bool f(Touch element)) {
    return _Collections.every(this, f);
  }

  bool some(bool f(Touch element)) {
    return _Collections.some(this, f);
  }

  void setRange(int start, int length, List<Touch> from, [int startFrom]) {
    throw new UnsupportedOperationException("Cannot setRange on immutable List.");
  }

  void removeRange(int start, int length) {
    throw new UnsupportedOperationException("Cannot removeRange on immutable List.");
  }

  void insertRange(int start, int length, [Touch initialValue]) {
    throw new UnsupportedOperationException("Cannot insertRange on immutable List.");
  }

  List<Touch> getRange(int start, int length) {
    throw new NotImplementedException();
  }

  bool isEmpty() {
    return length == 0;
  }

  Iterator<Touch> iterator() {
    return new _FixedSizeListIterator<Touch>(this);
  }

  Touch item(int index) {
    return _wrap(_ptr.item(_unwrap(index)));
  }
}

class _TrackElementImpl extends _ElementImpl implements TrackElement {
  _TrackElementImpl._wrap(ptr) : super._wrap(ptr);

  bool get defaultValue() => _wrap(_ptr.defaultValue);

  void set defaultValue(bool value) { _ptr.defaultValue = _unwrap(value); }

  String get kind() => _wrap(_ptr.kind);

  void set kind(String value) { _ptr.kind = _unwrap(value); }

  String get label() => _wrap(_ptr.label);

  void set label(String value) { _ptr.label = _unwrap(value); }

  int get readyState() => _wrap(_ptr.readyState);

  String get src() => _wrap(_ptr.src);

  void set src(String value) { _ptr.src = _unwrap(value); }

  String get srclang() => _wrap(_ptr.srclang);

  void set srclang(String value) { _ptr.srclang = _unwrap(value); }

  TextTrack get track() => _wrap(_ptr.track);
}

class _TrackEventImpl extends _EventImpl implements TrackEvent {
  _TrackEventImpl._wrap(ptr) : super._wrap(ptr);

  Object get track() => _wrap(_ptr.track);
}

class _TransitionEventImpl extends _EventImpl implements TransitionEvent {
  _TransitionEventImpl._wrap(ptr) : super._wrap(ptr);

  num get elapsedTime() => _wrap(_ptr.elapsedTime);

  String get propertyName() => _wrap(_ptr.propertyName);
}

class _TreeWalkerImpl extends _DOMTypeBase implements TreeWalker {
  _TreeWalkerImpl._wrap(ptr) : super._wrap(ptr);

  Node get currentNode() => _wrap(_ptr.currentNode);

  void set currentNode(Node value) { _ptr.currentNode = _unwrap(value); }

  bool get expandEntityReferences() => _wrap(_ptr.expandEntityReferences);

  NodeFilter get filter() => _wrap(_ptr.filter);

  Node get root() => _wrap(_ptr.root);

  int get whatToShow() => _wrap(_ptr.whatToShow);

  Node firstChild() {
    return _wrap(_ptr.firstChild());
  }

  Node lastChild() {
    return _wrap(_ptr.lastChild());
  }

  Node nextNode() {
    return _wrap(_ptr.nextNode());
  }

  Node nextSibling() {
    return _wrap(_ptr.nextSibling());
  }

  Node parentNode() {
    return _wrap(_ptr.parentNode());
  }

  Node previousNode() {
    return _wrap(_ptr.previousNode());
  }

  Node previousSibling() {
    return _wrap(_ptr.previousSibling());
  }
}

class _UIEventImpl extends _EventImpl implements UIEvent {
  _UIEventImpl._wrap(ptr) : super._wrap(ptr);

  int get charCode() => _wrap(_ptr.charCode);

  int get detail() => _wrap(_ptr.detail);

  int get keyCode() => _wrap(_ptr.keyCode);

  int get layerX() => _wrap(_ptr.layerX);

  int get layerY() => _wrap(_ptr.layerY);

  int get pageX() => _wrap(_ptr.pageX);

  int get pageY() => _wrap(_ptr.pageY);

  Window get view() => _wrap(_ptr.view);

  int get which() => _wrap(_ptr.which);

  void initUIEvent(String type, bool canBubble, bool cancelable, Window view, int detail) {
    _ptr.initUIEvent(_unwrap(type), _unwrap(canBubble), _unwrap(cancelable), _unwrap(view), _unwrap(detail));
    return;
  }
}

class _UListElementImpl extends _ElementImpl implements UListElement {
  _UListElementImpl._wrap(ptr) : super._wrap(ptr);

  bool get compact() => _wrap(_ptr.compact);

  void set compact(bool value) { _ptr.compact = _unwrap(value); }

  String get type() => _wrap(_ptr.type);

  void set type(String value) { _ptr.type = _unwrap(value); }
}

class _Uint16ArrayImpl extends _ArrayBufferViewImpl implements Uint16Array, List<int> {
  _Uint16ArrayImpl._wrap(ptr) : super._wrap(ptr);

  int get length() => _wrap(_ptr.length);

  int operator[](int index) => _wrap(_ptr[index]);


  void operator[]=(int index, int value) {
    throw new UnsupportedOperationException("Cannot assign element of immutable List.");
  }

  void add(int value) {
    throw new UnsupportedOperationException("Cannot add to immutable List.");
  }

  void addLast(int value) {
    throw new UnsupportedOperationException("Cannot add to immutable List.");
  }

  void addAll(Collection<int> collection) {
    throw new UnsupportedOperationException("Cannot add to immutable List.");
  }

  void sort(int compare(int a, int b)) {
    throw new UnsupportedOperationException("Cannot sort immutable List.");
  }

  void copyFrom(List<Object> src, int srcStart, int dstStart, int count) {
    throw new UnsupportedOperationException("This object is immutable.");
  }

  int indexOf(int element, [int start = 0]) {
    return _Lists.indexOf(this, element, start, this.length);
  }

  int lastIndexOf(int element, [int start = null]) {
    if (start === null) start = length - 1;
    return _Lists.lastIndexOf(this, element, start);
  }

  int clear() {
    throw new UnsupportedOperationException("Cannot clear immutable List.");
  }

  int removeLast() {
    throw new UnsupportedOperationException("Cannot removeLast on immutable List.");
  }

  int last() {
    return this[length - 1];
  }

  void forEach(void f(int element)) {
    _Collections.forEach(this, f);
  }

  Collection map(f(int element)) {
    return _Collections.map(this, [], f);
  }

  Collection<int> filter(bool f(int element)) {
    return _Collections.filter(this, new List<int>(), f);
  }

  bool every(bool f(int element)) {
    return _Collections.every(this, f);
  }

  bool some(bool f(int element)) {
    return _Collections.some(this, f);
  }

  void setRange(int start, int length, List<int> from, [int startFrom]) {
    throw new UnsupportedOperationException("Cannot setRange on immutable List.");
  }

  void removeRange(int start, int length) {
    throw new UnsupportedOperationException("Cannot removeRange on immutable List.");
  }

  void insertRange(int start, int length, [int initialValue]) {
    throw new UnsupportedOperationException("Cannot insertRange on immutable List.");
  }

  List<int> getRange(int start, int length) {
    throw new NotImplementedException();
  }

  bool isEmpty() {
    return length == 0;
  }

  Iterator<int> iterator() {
    return new _FixedSizeListIterator<int>(this);
  }

  void setElements(Object array, [int offset = null]) {
    if (offset === null) {
      _ptr.setElements(_unwrap(array));
      return;
    } else {
      _ptr.setElements(_unwrap(array), _unwrap(offset));
      return;
    }
  }

  Uint16Array subarray(int start, [int end = null]) {
    if (end === null) {
      return _wrap(_ptr.subarray(_unwrap(start)));
    } else {
      return _wrap(_ptr.subarray(_unwrap(start), _unwrap(end)));
    }
  }
}

class _Uint32ArrayImpl extends _ArrayBufferViewImpl implements Uint32Array, List<int> {
  _Uint32ArrayImpl._wrap(ptr) : super._wrap(ptr);

  int get length() => _wrap(_ptr.length);

  int operator[](int index) => _wrap(_ptr[index]);


  void operator[]=(int index, int value) {
    throw new UnsupportedOperationException("Cannot assign element of immutable List.");
  }

  void add(int value) {
    throw new UnsupportedOperationException("Cannot add to immutable List.");
  }

  void addLast(int value) {
    throw new UnsupportedOperationException("Cannot add to immutable List.");
  }

  void addAll(Collection<int> collection) {
    throw new UnsupportedOperationException("Cannot add to immutable List.");
  }

  void sort(int compare(int a, int b)) {
    throw new UnsupportedOperationException("Cannot sort immutable List.");
  }

  void copyFrom(List<Object> src, int srcStart, int dstStart, int count) {
    throw new UnsupportedOperationException("This object is immutable.");
  }

  int indexOf(int element, [int start = 0]) {
    return _Lists.indexOf(this, element, start, this.length);
  }

  int lastIndexOf(int element, [int start = null]) {
    if (start === null) start = length - 1;
    return _Lists.lastIndexOf(this, element, start);
  }

  int clear() {
    throw new UnsupportedOperationException("Cannot clear immutable List.");
  }

  int removeLast() {
    throw new UnsupportedOperationException("Cannot removeLast on immutable List.");
  }

  int last() {
    return this[length - 1];
  }

  void forEach(void f(int element)) {
    _Collections.forEach(this, f);
  }

  Collection map(f(int element)) {
    return _Collections.map(this, [], f);
  }

  Collection<int> filter(bool f(int element)) {
    return _Collections.filter(this, new List<int>(), f);
  }

  bool every(bool f(int element)) {
    return _Collections.every(this, f);
  }

  bool some(bool f(int element)) {
    return _Collections.some(this, f);
  }

  void setRange(int start, int length, List<int> from, [int startFrom]) {
    throw new UnsupportedOperationException("Cannot setRange on immutable List.");
  }

  void removeRange(int start, int length) {
    throw new UnsupportedOperationException("Cannot removeRange on immutable List.");
  }

  void insertRange(int start, int length, [int initialValue]) {
    throw new UnsupportedOperationException("Cannot insertRange on immutable List.");
  }

  List<int> getRange(int start, int length) {
    throw new NotImplementedException();
  }

  bool isEmpty() {
    return length == 0;
  }

  Iterator<int> iterator() {
    return new _FixedSizeListIterator<int>(this);
  }

  void setElements(Object array, [int offset = null]) {
    if (offset === null) {
      _ptr.setElements(_unwrap(array));
      return;
    } else {
      _ptr.setElements(_unwrap(array), _unwrap(offset));
      return;
    }
  }

  Uint32Array subarray(int start, [int end = null]) {
    if (end === null) {
      return _wrap(_ptr.subarray(_unwrap(start)));
    } else {
      return _wrap(_ptr.subarray(_unwrap(start), _unwrap(end)));
    }
  }
}

class _Uint8ArrayImpl extends _ArrayBufferViewImpl implements Uint8Array, List<int> {
  _Uint8ArrayImpl._wrap(ptr) : super._wrap(ptr);

  int get length() => _wrap(_ptr.length);

  int operator[](int index) => _wrap(_ptr[index]);


  void operator[]=(int index, int value) {
    throw new UnsupportedOperationException("Cannot assign element of immutable List.");
  }

  void add(int value) {
    throw new UnsupportedOperationException("Cannot add to immutable List.");
  }

  void addLast(int value) {
    throw new UnsupportedOperationException("Cannot add to immutable List.");
  }

  void addAll(Collection<int> collection) {
    throw new UnsupportedOperationException("Cannot add to immutable List.");
  }

  void sort(int compare(int a, int b)) {
    throw new UnsupportedOperationException("Cannot sort immutable List.");
  }

  void copyFrom(List<Object> src, int srcStart, int dstStart, int count) {
    throw new UnsupportedOperationException("This object is immutable.");
  }

  int indexOf(int element, [int start = 0]) {
    return _Lists.indexOf(this, element, start, this.length);
  }

  int lastIndexOf(int element, [int start = null]) {
    if (start === null) start = length - 1;
    return _Lists.lastIndexOf(this, element, start);
  }

  int clear() {
    throw new UnsupportedOperationException("Cannot clear immutable List.");
  }

  int removeLast() {
    throw new UnsupportedOperationException("Cannot removeLast on immutable List.");
  }

  int last() {
    return this[length - 1];
  }

  void forEach(void f(int element)) {
    _Collections.forEach(this, f);
  }

  Collection map(f(int element)) {
    return _Collections.map(this, [], f);
  }

  Collection<int> filter(bool f(int element)) {
    return _Collections.filter(this, new List<int>(), f);
  }

  bool every(bool f(int element)) {
    return _Collections.every(this, f);
  }

  bool some(bool f(int element)) {
    return _Collections.some(this, f);
  }

  void setRange(int start, int length, List<int> from, [int startFrom]) {
    throw new UnsupportedOperationException("Cannot setRange on immutable List.");
  }

  void removeRange(int start, int length) {
    throw new UnsupportedOperationException("Cannot removeRange on immutable List.");
  }

  void insertRange(int start, int length, [int initialValue]) {
    throw new UnsupportedOperationException("Cannot insertRange on immutable List.");
  }

  List<int> getRange(int start, int length) {
    throw new NotImplementedException();
  }

  bool isEmpty() {
    return length == 0;
  }

  Iterator<int> iterator() {
    return new _FixedSizeListIterator<int>(this);
  }

  void setElements(Object array, [int offset = null]) {
    if (offset === null) {
      _ptr.setElements(_unwrap(array));
      return;
    } else {
      _ptr.setElements(_unwrap(array), _unwrap(offset));
      return;
    }
  }

  Uint8Array subarray(int start, [int end = null]) {
    if (end === null) {
      return _wrap(_ptr.subarray(_unwrap(start)));
    } else {
      return _wrap(_ptr.subarray(_unwrap(start), _unwrap(end)));
    }
  }
}

class _Uint8ClampedArrayImpl extends _Uint8ArrayImpl implements Uint8ClampedArray, List<int> {
  _Uint8ClampedArrayImpl._wrap(ptr) : super._wrap(ptr);

  int get length() => _wrap(_ptr.length);

  void setElements(Object array, [int offset = null]) {
    if (offset === null) {
      _ptr.setElements(_unwrap(array));
      return;
    } else {
      _ptr.setElements(_unwrap(array), _unwrap(offset));
      return;
    }
  }

  Uint8ClampedArray subarray(int start, [int end = null]) {
    if (end === null) {
      return _wrap(_ptr.subarray(_unwrap(start)));
    } else {
      return _wrap(_ptr.subarray(_unwrap(start), _unwrap(end)));
    }
  }
}

class _UnknownElementImpl extends _ElementImpl implements UnknownElement {
  _UnknownElementImpl._wrap(ptr) : super._wrap(ptr);
}

class _ValidityStateImpl extends _DOMTypeBase implements ValidityState {
  _ValidityStateImpl._wrap(ptr) : super._wrap(ptr);

  bool get customError() => _wrap(_ptr.customError);

  bool get patternMismatch() => _wrap(_ptr.patternMismatch);

  bool get rangeOverflow() => _wrap(_ptr.rangeOverflow);

  bool get rangeUnderflow() => _wrap(_ptr.rangeUnderflow);

  bool get stepMismatch() => _wrap(_ptr.stepMismatch);

  bool get tooLong() => _wrap(_ptr.tooLong);

  bool get typeMismatch() => _wrap(_ptr.typeMismatch);

  bool get valid() => _wrap(_ptr.valid);

  bool get valueMissing() => _wrap(_ptr.valueMissing);
}

class _VideoElementImpl extends _MediaElementImpl implements VideoElement {
  _VideoElementImpl._wrap(ptr) : super._wrap(ptr);

  int get height() => _wrap(_ptr.height);

  void set height(int value) { _ptr.height = _unwrap(value); }

  String get poster() => _wrap(_ptr.poster);

  void set poster(String value) { _ptr.poster = _unwrap(value); }

  int get videoHeight() => _wrap(_ptr.videoHeight);

  int get videoWidth() => _wrap(_ptr.videoWidth);

  int get webkitDecodedFrameCount() => _wrap(_ptr.webkitDecodedFrameCount);

  bool get webkitDisplayingFullscreen() => _wrap(_ptr.webkitDisplayingFullscreen);

  int get webkitDroppedFrameCount() => _wrap(_ptr.webkitDroppedFrameCount);

  bool get webkitSupportsFullscreen() => _wrap(_ptr.webkitSupportsFullscreen);

  int get width() => _wrap(_ptr.width);

  void set width(int value) { _ptr.width = _unwrap(value); }

  void webkitEnterFullScreen() {
    _ptr.webkitEnterFullScreen();
    return;
  }

  void webkitEnterFullscreen() {
    _ptr.webkitEnterFullscreen();
    return;
  }

  void webkitExitFullScreen() {
    _ptr.webkitExitFullScreen();
    return;
  }

  void webkitExitFullscreen() {
    _ptr.webkitExitFullscreen();
    return;
  }
}

class _WaveShaperNodeImpl extends _AudioNodeImpl implements WaveShaperNode {
  _WaveShaperNodeImpl._wrap(ptr) : super._wrap(ptr);

  Float32Array get curve() => _wrap(_ptr.curve);

  void set curve(Float32Array value) { _ptr.curve = _unwrap(value); }
}

class _WebGLActiveInfoImpl extends _DOMTypeBase implements WebGLActiveInfo {
  _WebGLActiveInfoImpl._wrap(ptr) : super._wrap(ptr);

  String get name() => _wrap(_ptr.name);

  int get size() => _wrap(_ptr.size);

  int get type() => _wrap(_ptr.type);
}

class _WebGLBufferImpl extends _DOMTypeBase implements WebGLBuffer {
  _WebGLBufferImpl._wrap(ptr) : super._wrap(ptr);
}

class _WebGLCompressedTextureS3TCImpl extends _DOMTypeBase implements WebGLCompressedTextureS3TC {
  _WebGLCompressedTextureS3TCImpl._wrap(ptr) : super._wrap(ptr);
}

class _WebGLContextAttributesImpl extends _DOMTypeBase implements WebGLContextAttributes {
  _WebGLContextAttributesImpl._wrap(ptr) : super._wrap(ptr);

  bool get alpha() => _wrap(_ptr.alpha);

  void set alpha(bool value) { _ptr.alpha = _unwrap(value); }

  bool get antialias() => _wrap(_ptr.antialias);

  void set antialias(bool value) { _ptr.antialias = _unwrap(value); }

  bool get depth() => _wrap(_ptr.depth);

  void set depth(bool value) { _ptr.depth = _unwrap(value); }

  bool get premultipliedAlpha() => _wrap(_ptr.premultipliedAlpha);

  void set premultipliedAlpha(bool value) { _ptr.premultipliedAlpha = _unwrap(value); }

  bool get preserveDrawingBuffer() => _wrap(_ptr.preserveDrawingBuffer);

  void set preserveDrawingBuffer(bool value) { _ptr.preserveDrawingBuffer = _unwrap(value); }

  bool get stencil() => _wrap(_ptr.stencil);

  void set stencil(bool value) { _ptr.stencil = _unwrap(value); }
}

class _WebGLContextEventImpl extends _EventImpl implements WebGLContextEvent {
  _WebGLContextEventImpl._wrap(ptr) : super._wrap(ptr);

  String get statusMessage() => _wrap(_ptr.statusMessage);
}

class _WebGLDebugRendererInfoImpl extends _DOMTypeBase implements WebGLDebugRendererInfo {
  _WebGLDebugRendererInfoImpl._wrap(ptr) : super._wrap(ptr);
}

class _WebGLDebugShadersImpl extends _DOMTypeBase implements WebGLDebugShaders {
  _WebGLDebugShadersImpl._wrap(ptr) : super._wrap(ptr);

  String getTranslatedShaderSource(WebGLShader shader) {
    return _wrap(_ptr.getTranslatedShaderSource(_unwrap(shader)));
  }
}

class _WebGLFramebufferImpl extends _DOMTypeBase implements WebGLFramebuffer {
  _WebGLFramebufferImpl._wrap(ptr) : super._wrap(ptr);
}

class _WebGLLoseContextImpl extends _DOMTypeBase implements WebGLLoseContext {
  _WebGLLoseContextImpl._wrap(ptr) : super._wrap(ptr);

  void loseContext() {
    _ptr.loseContext();
    return;
  }

  void restoreContext() {
    _ptr.restoreContext();
    return;
  }
}

class _WebGLProgramImpl extends _DOMTypeBase implements WebGLProgram {
  _WebGLProgramImpl._wrap(ptr) : super._wrap(ptr);
}

class _WebGLRenderbufferImpl extends _DOMTypeBase implements WebGLRenderbuffer {
  _WebGLRenderbufferImpl._wrap(ptr) : super._wrap(ptr);
}

class _WebGLRenderingContextImpl extends _CanvasRenderingContextImpl implements WebGLRenderingContext {
  _WebGLRenderingContextImpl._wrap(ptr) : super._wrap(ptr);

  int get drawingBufferHeight() => _wrap(_ptr.drawingBufferHeight);

  int get drawingBufferWidth() => _wrap(_ptr.drawingBufferWidth);

  void activeTexture(int texture) {
    _ptr.activeTexture(_unwrap(texture));
    return;
  }

  void attachShader(WebGLProgram program, WebGLShader shader) {
    _ptr.attachShader(_unwrap(program), _unwrap(shader));
    return;
  }

  void bindAttribLocation(WebGLProgram program, int index, String name) {
    _ptr.bindAttribLocation(_unwrap(program), _unwrap(index), _unwrap(name));
    return;
  }

  void bindBuffer(int target, WebGLBuffer buffer) {
    _ptr.bindBuffer(_unwrap(target), _unwrap(buffer));
    return;
  }

  void bindFramebuffer(int target, WebGLFramebuffer framebuffer) {
    _ptr.bindFramebuffer(_unwrap(target), _unwrap(framebuffer));
    return;
  }

  void bindRenderbuffer(int target, WebGLRenderbuffer renderbuffer) {
    _ptr.bindRenderbuffer(_unwrap(target), _unwrap(renderbuffer));
    return;
  }

  void bindTexture(int target, WebGLTexture texture) {
    _ptr.bindTexture(_unwrap(target), _unwrap(texture));
    return;
  }

  void blendColor(num red, num green, num blue, num alpha) {
    _ptr.blendColor(_unwrap(red), _unwrap(green), _unwrap(blue), _unwrap(alpha));
    return;
  }

  void blendEquation(int mode) {
    _ptr.blendEquation(_unwrap(mode));
    return;
  }

  void blendEquationSeparate(int modeRGB, int modeAlpha) {
    _ptr.blendEquationSeparate(_unwrap(modeRGB), _unwrap(modeAlpha));
    return;
  }

  void blendFunc(int sfactor, int dfactor) {
    _ptr.blendFunc(_unwrap(sfactor), _unwrap(dfactor));
    return;
  }

  void blendFuncSeparate(int srcRGB, int dstRGB, int srcAlpha, int dstAlpha) {
    _ptr.blendFuncSeparate(_unwrap(srcRGB), _unwrap(dstRGB), _unwrap(srcAlpha), _unwrap(dstAlpha));
    return;
  }

  void bufferData(int target, var data_OR_size, int usage) {
    if (data_OR_size is ArrayBuffer) {
      _ptr.bufferData(_unwrap(target), _unwrap(data_OR_size), _unwrap(usage));
      return;
    } else {
      if (data_OR_size is ArrayBufferView) {
        _ptr.bufferData(_unwrap(target), _unwrap(data_OR_size), _unwrap(usage));
        return;
      } else {
        if (data_OR_size is int) {
          _ptr.bufferData(_unwrap(target), _unwrap(data_OR_size), _unwrap(usage));
          return;
        }
      }
    }
    throw "Incorrect number or type of arguments";
  }

  void bufferSubData(int target, int offset, var data) {
    if (data is ArrayBuffer) {
      _ptr.bufferSubData(_unwrap(target), _unwrap(offset), _unwrap(data));
      return;
    } else {
      if (data is ArrayBufferView) {
        _ptr.bufferSubData(_unwrap(target), _unwrap(offset), _unwrap(data));
        return;
      }
    }
    throw "Incorrect number or type of arguments";
  }

  int checkFramebufferStatus(int target) {
    return _wrap(_ptr.checkFramebufferStatus(_unwrap(target)));
  }

  void clear(int mask) {
    _ptr.clear(_unwrap(mask));
    return;
  }

  void clearColor(num red, num green, num blue, num alpha) {
    _ptr.clearColor(_unwrap(red), _unwrap(green), _unwrap(blue), _unwrap(alpha));
    return;
  }

  void clearDepth(num depth) {
    _ptr.clearDepth(_unwrap(depth));
    return;
  }

  void clearStencil(int s) {
    _ptr.clearStencil(_unwrap(s));
    return;
  }

  void colorMask(bool red, bool green, bool blue, bool alpha) {
    _ptr.colorMask(_unwrap(red), _unwrap(green), _unwrap(blue), _unwrap(alpha));
    return;
  }

  void compileShader(WebGLShader shader) {
    _ptr.compileShader(_unwrap(shader));
    return;
  }

  void compressedTexImage2D(int target, int level, int internalformat, int width, int height, int border, ArrayBufferView data) {
    _ptr.compressedTexImage2D(_unwrap(target), _unwrap(level), _unwrap(internalformat), _unwrap(width), _unwrap(height), _unwrap(border), _unwrap(data));
    return;
  }

  void compressedTexSubImage2D(int target, int level, int xoffset, int yoffset, int width, int height, int format, ArrayBufferView data) {
    _ptr.compressedTexSubImage2D(_unwrap(target), _unwrap(level), _unwrap(xoffset), _unwrap(yoffset), _unwrap(width), _unwrap(height), _unwrap(format), _unwrap(data));
    return;
  }

  void copyTexImage2D(int target, int level, int internalformat, int x, int y, int width, int height, int border) {
    _ptr.copyTexImage2D(_unwrap(target), _unwrap(level), _unwrap(internalformat), _unwrap(x), _unwrap(y), _unwrap(width), _unwrap(height), _unwrap(border));
    return;
  }

  void copyTexSubImage2D(int target, int level, int xoffset, int yoffset, int x, int y, int width, int height) {
    _ptr.copyTexSubImage2D(_unwrap(target), _unwrap(level), _unwrap(xoffset), _unwrap(yoffset), _unwrap(x), _unwrap(y), _unwrap(width), _unwrap(height));
    return;
  }

  WebGLBuffer createBuffer() {
    return _wrap(_ptr.createBuffer());
  }

  WebGLFramebuffer createFramebuffer() {
    return _wrap(_ptr.createFramebuffer());
  }

  WebGLProgram createProgram() {
    return _wrap(_ptr.createProgram());
  }

  WebGLRenderbuffer createRenderbuffer() {
    return _wrap(_ptr.createRenderbuffer());
  }

  WebGLShader createShader(int type) {
    return _wrap(_ptr.createShader(_unwrap(type)));
  }

  WebGLTexture createTexture() {
    return _wrap(_ptr.createTexture());
  }

  void cullFace(int mode) {
    _ptr.cullFace(_unwrap(mode));
    return;
  }

  void deleteBuffer(WebGLBuffer buffer) {
    _ptr.deleteBuffer(_unwrap(buffer));
    return;
  }

  void deleteFramebuffer(WebGLFramebuffer framebuffer) {
    _ptr.deleteFramebuffer(_unwrap(framebuffer));
    return;
  }

  void deleteProgram(WebGLProgram program) {
    _ptr.deleteProgram(_unwrap(program));
    return;
  }

  void deleteRenderbuffer(WebGLRenderbuffer renderbuffer) {
    _ptr.deleteRenderbuffer(_unwrap(renderbuffer));
    return;
  }

  void deleteShader(WebGLShader shader) {
    _ptr.deleteShader(_unwrap(shader));
    return;
  }

  void deleteTexture(WebGLTexture texture) {
    _ptr.deleteTexture(_unwrap(texture));
    return;
  }

  void depthFunc(int func) {
    _ptr.depthFunc(_unwrap(func));
    return;
  }

  void depthMask(bool flag) {
    _ptr.depthMask(_unwrap(flag));
    return;
  }

  void depthRange(num zNear, num zFar) {
    _ptr.depthRange(_unwrap(zNear), _unwrap(zFar));
    return;
  }

  void detachShader(WebGLProgram program, WebGLShader shader) {
    _ptr.detachShader(_unwrap(program), _unwrap(shader));
    return;
  }

  void disable(int cap) {
    _ptr.disable(_unwrap(cap));
    return;
  }

  void disableVertexAttribArray(int index) {
    _ptr.disableVertexAttribArray(_unwrap(index));
    return;
  }

  void drawArrays(int mode, int first, int count) {
    _ptr.drawArrays(_unwrap(mode), _unwrap(first), _unwrap(count));
    return;
  }

  void drawElements(int mode, int count, int type, int offset) {
    _ptr.drawElements(_unwrap(mode), _unwrap(count), _unwrap(type), _unwrap(offset));
    return;
  }

  void enable(int cap) {
    _ptr.enable(_unwrap(cap));
    return;
  }

  void enableVertexAttribArray(int index) {
    _ptr.enableVertexAttribArray(_unwrap(index));
    return;
  }

  void finish() {
    _ptr.finish();
    return;
  }

  void flush() {
    _ptr.flush();
    return;
  }

  void framebufferRenderbuffer(int target, int attachment, int renderbuffertarget, WebGLRenderbuffer renderbuffer) {
    _ptr.framebufferRenderbuffer(_unwrap(target), _unwrap(attachment), _unwrap(renderbuffertarget), _unwrap(renderbuffer));
    return;
  }

  void framebufferTexture2D(int target, int attachment, int textarget, WebGLTexture texture, int level) {
    _ptr.framebufferTexture2D(_unwrap(target), _unwrap(attachment), _unwrap(textarget), _unwrap(texture), _unwrap(level));
    return;
  }

  void frontFace(int mode) {
    _ptr.frontFace(_unwrap(mode));
    return;
  }

  void generateMipmap(int target) {
    _ptr.generateMipmap(_unwrap(target));
    return;
  }

  WebGLActiveInfo getActiveAttrib(WebGLProgram program, int index) {
    return _wrap(_ptr.getActiveAttrib(_unwrap(program), _unwrap(index)));
  }

  WebGLActiveInfo getActiveUniform(WebGLProgram program, int index) {
    return _wrap(_ptr.getActiveUniform(_unwrap(program), _unwrap(index)));
  }

  List getAttachedShaders(WebGLProgram program) {
    return _wrap(_ptr.getAttachedShaders(_unwrap(program)));
  }

  int getAttribLocation(WebGLProgram program, String name) {
    return _wrap(_ptr.getAttribLocation(_unwrap(program), _unwrap(name)));
  }

  Object getBufferParameter(int target, int pname) {
    return _wrap(_ptr.getBufferParameter(_unwrap(target), _unwrap(pname)));
  }

  WebGLContextAttributes getContextAttributes() {
    return _wrap(_ptr.getContextAttributes());
  }

  int getError() {
    return _wrap(_ptr.getError());
  }

  Object getExtension(String name) {
    return _wrap(_ptr.getExtension(_unwrap(name)));
  }

  Object getFramebufferAttachmentParameter(int target, int attachment, int pname) {
    return _wrap(_ptr.getFramebufferAttachmentParameter(_unwrap(target), _unwrap(attachment), _unwrap(pname)));
  }

  Object getParameter(int pname) {
    return _wrap(_ptr.getParameter(_unwrap(pname)));
  }

  String getProgramInfoLog(WebGLProgram program) {
    return _wrap(_ptr.getProgramInfoLog(_unwrap(program)));
  }

  Object getProgramParameter(WebGLProgram program, int pname) {
    return _wrap(_ptr.getProgramParameter(_unwrap(program), _unwrap(pname)));
  }

  Object getRenderbufferParameter(int target, int pname) {
    return _wrap(_ptr.getRenderbufferParameter(_unwrap(target), _unwrap(pname)));
  }

  String getShaderInfoLog(WebGLShader shader) {
    return _wrap(_ptr.getShaderInfoLog(_unwrap(shader)));
  }

  Object getShaderParameter(WebGLShader shader, int pname) {
    return _wrap(_ptr.getShaderParameter(_unwrap(shader), _unwrap(pname)));
  }

  String getShaderSource(WebGLShader shader) {
    return _wrap(_ptr.getShaderSource(_unwrap(shader)));
  }

  Object getTexParameter(int target, int pname) {
    return _wrap(_ptr.getTexParameter(_unwrap(target), _unwrap(pname)));
  }

  Object getUniform(WebGLProgram program, WebGLUniformLocation location) {
    return _wrap(_ptr.getUniform(_unwrap(program), _unwrap(location)));
  }

  WebGLUniformLocation getUniformLocation(WebGLProgram program, String name) {
    return _wrap(_ptr.getUniformLocation(_unwrap(program), _unwrap(name)));
  }

  Object getVertexAttrib(int index, int pname) {
    return _wrap(_ptr.getVertexAttrib(_unwrap(index), _unwrap(pname)));
  }

  int getVertexAttribOffset(int index, int pname) {
    return _wrap(_ptr.getVertexAttribOffset(_unwrap(index), _unwrap(pname)));
  }

  void hint(int target, int mode) {
    _ptr.hint(_unwrap(target), _unwrap(mode));
    return;
  }

  bool isBuffer(WebGLBuffer buffer) {
    return _wrap(_ptr.isBuffer(_unwrap(buffer)));
  }

  bool isContextLost() {
    return _wrap(_ptr.isContextLost());
  }

  bool isEnabled(int cap) {
    return _wrap(_ptr.isEnabled(_unwrap(cap)));
  }

  bool isFramebuffer(WebGLFramebuffer framebuffer) {
    return _wrap(_ptr.isFramebuffer(_unwrap(framebuffer)));
  }

  bool isProgram(WebGLProgram program) {
    return _wrap(_ptr.isProgram(_unwrap(program)));
  }

  bool isRenderbuffer(WebGLRenderbuffer renderbuffer) {
    return _wrap(_ptr.isRenderbuffer(_unwrap(renderbuffer)));
  }

  bool isShader(WebGLShader shader) {
    return _wrap(_ptr.isShader(_unwrap(shader)));
  }

  bool isTexture(WebGLTexture texture) {
    return _wrap(_ptr.isTexture(_unwrap(texture)));
  }

  void lineWidth(num width) {
    _ptr.lineWidth(_unwrap(width));
    return;
  }

  void linkProgram(WebGLProgram program) {
    _ptr.linkProgram(_unwrap(program));
    return;
  }

  void pixelStorei(int pname, int param) {
    _ptr.pixelStorei(_unwrap(pname), _unwrap(param));
    return;
  }

  void polygonOffset(num factor, num units) {
    _ptr.polygonOffset(_unwrap(factor), _unwrap(units));
    return;
  }

  void readPixels(int x, int y, int width, int height, int format, int type, ArrayBufferView pixels) {
    _ptr.readPixels(_unwrap(x), _unwrap(y), _unwrap(width), _unwrap(height), _unwrap(format), _unwrap(type), _unwrap(pixels));
    return;
  }

  void releaseShaderCompiler() {
    _ptr.releaseShaderCompiler();
    return;
  }

  void renderbufferStorage(int target, int internalformat, int width, int height) {
    _ptr.renderbufferStorage(_unwrap(target), _unwrap(internalformat), _unwrap(width), _unwrap(height));
    return;
  }

  void sampleCoverage(num value, bool invert) {
    _ptr.sampleCoverage(_unwrap(value), _unwrap(invert));
    return;
  }

  void scissor(int x, int y, int width, int height) {
    _ptr.scissor(_unwrap(x), _unwrap(y), _unwrap(width), _unwrap(height));
    return;
  }

  void shaderSource(WebGLShader shader, String string) {
    _ptr.shaderSource(_unwrap(shader), _unwrap(string));
    return;
  }

  void stencilFunc(int func, int ref, int mask) {
    _ptr.stencilFunc(_unwrap(func), _unwrap(ref), _unwrap(mask));
    return;
  }

  void stencilFuncSeparate(int face, int func, int ref, int mask) {
    _ptr.stencilFuncSeparate(_unwrap(face), _unwrap(func), _unwrap(ref), _unwrap(mask));
    return;
  }

  void stencilMask(int mask) {
    _ptr.stencilMask(_unwrap(mask));
    return;
  }

  void stencilMaskSeparate(int face, int mask) {
    _ptr.stencilMaskSeparate(_unwrap(face), _unwrap(mask));
    return;
  }

  void stencilOp(int fail, int zfail, int zpass) {
    _ptr.stencilOp(_unwrap(fail), _unwrap(zfail), _unwrap(zpass));
    return;
  }

  void stencilOpSeparate(int face, int fail, int zfail, int zpass) {
    _ptr.stencilOpSeparate(_unwrap(face), _unwrap(fail), _unwrap(zfail), _unwrap(zpass));
    return;
  }

  void texImage2D(int target, int level, int internalformat, int format_OR_width, int height_OR_type, var border_OR_canvas_OR_image_OR_pixels_OR_video, [int format = null, int type = null, ArrayBufferView pixels = null]) {
    if (border_OR_canvas_OR_image_OR_pixels_OR_video is ImageData) {
      if (format === null) {
        if (type === null) {
          if (pixels === null) {
            _ptr.texImage2D(_unwrap(target), _unwrap(level), _unwrap(internalformat), _unwrap(format_OR_width), _unwrap(height_OR_type), _unwrap(border_OR_canvas_OR_image_OR_pixels_OR_video));
            return;
          }
        }
      }
    } else {
      if (border_OR_canvas_OR_image_OR_pixels_OR_video is ImageElement) {
        if (format === null) {
          if (type === null) {
            if (pixels === null) {
              _ptr.texImage2D(_unwrap(target), _unwrap(level), _unwrap(internalformat), _unwrap(format_OR_width), _unwrap(height_OR_type), _unwrap(border_OR_canvas_OR_image_OR_pixels_OR_video));
              return;
            }
          }
        }
      } else {
        if (border_OR_canvas_OR_image_OR_pixels_OR_video is CanvasElement) {
          if (format === null) {
            if (type === null) {
              if (pixels === null) {
                _ptr.texImage2D(_unwrap(target), _unwrap(level), _unwrap(internalformat), _unwrap(format_OR_width), _unwrap(height_OR_type), _unwrap(border_OR_canvas_OR_image_OR_pixels_OR_video));
                return;
              }
            }
          }
        } else {
          if (border_OR_canvas_OR_image_OR_pixels_OR_video is VideoElement) {
            if (format === null) {
              if (type === null) {
                if (pixels === null) {
                  _ptr.texImage2D(_unwrap(target), _unwrap(level), _unwrap(internalformat), _unwrap(format_OR_width), _unwrap(height_OR_type), _unwrap(border_OR_canvas_OR_image_OR_pixels_OR_video));
                  return;
                }
              }
            }
          } else {
            if (border_OR_canvas_OR_image_OR_pixels_OR_video is int) {
              _ptr.texImage2D(_unwrap(target), _unwrap(level), _unwrap(internalformat), _unwrap(format_OR_width), _unwrap(height_OR_type), _unwrap(border_OR_canvas_OR_image_OR_pixels_OR_video), _unwrap(format), _unwrap(type), _unwrap(pixels));
              return;
            }
          }
        }
      }
    }
    throw "Incorrect number or type of arguments";
  }

  void texParameterf(int target, int pname, num param) {
    _ptr.texParameterf(_unwrap(target), _unwrap(pname), _unwrap(param));
    return;
  }

  void texParameteri(int target, int pname, int param) {
    _ptr.texParameteri(_unwrap(target), _unwrap(pname), _unwrap(param));
    return;
  }

  void texSubImage2D(int target, int level, int xoffset, int yoffset, int format_OR_width, int height_OR_type, var canvas_OR_format_OR_image_OR_pixels_OR_video, [int type = null, ArrayBufferView pixels = null]) {
    if (canvas_OR_format_OR_image_OR_pixels_OR_video is ImageData) {
      if (type === null) {
        if (pixels === null) {
          _ptr.texSubImage2D(_unwrap(target), _unwrap(level), _unwrap(xoffset), _unwrap(yoffset), _unwrap(format_OR_width), _unwrap(height_OR_type), _unwrap(canvas_OR_format_OR_image_OR_pixels_OR_video));
          return;
        }
      }
    } else {
      if (canvas_OR_format_OR_image_OR_pixels_OR_video is ImageElement) {
        if (type === null) {
          if (pixels === null) {
            _ptr.texSubImage2D(_unwrap(target), _unwrap(level), _unwrap(xoffset), _unwrap(yoffset), _unwrap(format_OR_width), _unwrap(height_OR_type), _unwrap(canvas_OR_format_OR_image_OR_pixels_OR_video));
            return;
          }
        }
      } else {
        if (canvas_OR_format_OR_image_OR_pixels_OR_video is CanvasElement) {
          if (type === null) {
            if (pixels === null) {
              _ptr.texSubImage2D(_unwrap(target), _unwrap(level), _unwrap(xoffset), _unwrap(yoffset), _unwrap(format_OR_width), _unwrap(height_OR_type), _unwrap(canvas_OR_format_OR_image_OR_pixels_OR_video));
              return;
            }
          }
        } else {
          if (canvas_OR_format_OR_image_OR_pixels_OR_video is VideoElement) {
            if (type === null) {
              if (pixels === null) {
                _ptr.texSubImage2D(_unwrap(target), _unwrap(level), _unwrap(xoffset), _unwrap(yoffset), _unwrap(format_OR_width), _unwrap(height_OR_type), _unwrap(canvas_OR_format_OR_image_OR_pixels_OR_video));
                return;
              }
            }
          } else {
            if (canvas_OR_format_OR_image_OR_pixels_OR_video is int) {
              _ptr.texSubImage2D(_unwrap(target), _unwrap(level), _unwrap(xoffset), _unwrap(yoffset), _unwrap(format_OR_width), _unwrap(height_OR_type), _unwrap(canvas_OR_format_OR_image_OR_pixels_OR_video), _unwrap(type), _unwrap(pixels));
              return;
            }
          }
        }
      }
    }
    throw "Incorrect number or type of arguments";
  }

  void uniform1f(WebGLUniformLocation location, num x) {
    _ptr.uniform1f(_unwrap(location), _unwrap(x));
    return;
  }

  void uniform1fv(WebGLUniformLocation location, Float32Array v) {
    _ptr.uniform1fv(_unwrap(location), _unwrap(v));
    return;
  }

  void uniform1i(WebGLUniformLocation location, int x) {
    _ptr.uniform1i(_unwrap(location), _unwrap(x));
    return;
  }

  void uniform1iv(WebGLUniformLocation location, Int32Array v) {
    _ptr.uniform1iv(_unwrap(location), _unwrap(v));
    return;
  }

  void uniform2f(WebGLUniformLocation location, num x, num y) {
    _ptr.uniform2f(_unwrap(location), _unwrap(x), _unwrap(y));
    return;
  }

  void uniform2fv(WebGLUniformLocation location, Float32Array v) {
    _ptr.uniform2fv(_unwrap(location), _unwrap(v));
    return;
  }

  void uniform2i(WebGLUniformLocation location, int x, int y) {
    _ptr.uniform2i(_unwrap(location), _unwrap(x), _unwrap(y));
    return;
  }

  void uniform2iv(WebGLUniformLocation location, Int32Array v) {
    _ptr.uniform2iv(_unwrap(location), _unwrap(v));
    return;
  }

  void uniform3f(WebGLUniformLocation location, num x, num y, num z) {
    _ptr.uniform3f(_unwrap(location), _unwrap(x), _unwrap(y), _unwrap(z));
    return;
  }

  void uniform3fv(WebGLUniformLocation location, Float32Array v) {
    _ptr.uniform3fv(_unwrap(location), _unwrap(v));
    return;
  }

  void uniform3i(WebGLUniformLocation location, int x, int y, int z) {
    _ptr.uniform3i(_unwrap(location), _unwrap(x), _unwrap(y), _unwrap(z));
    return;
  }

  void uniform3iv(WebGLUniformLocation location, Int32Array v) {
    _ptr.uniform3iv(_unwrap(location), _unwrap(v));
    return;
  }

  void uniform4f(WebGLUniformLocation location, num x, num y, num z, num w) {
    _ptr.uniform4f(_unwrap(location), _unwrap(x), _unwrap(y), _unwrap(z), _unwrap(w));
    return;
  }

  void uniform4fv(WebGLUniformLocation location, Float32Array v) {
    _ptr.uniform4fv(_unwrap(location), _unwrap(v));
    return;
  }

  void uniform4i(WebGLUniformLocation location, int x, int y, int z, int w) {
    _ptr.uniform4i(_unwrap(location), _unwrap(x), _unwrap(y), _unwrap(z), _unwrap(w));
    return;
  }

  void uniform4iv(WebGLUniformLocation location, Int32Array v) {
    _ptr.uniform4iv(_unwrap(location), _unwrap(v));
    return;
  }

  void uniformMatrix2fv(WebGLUniformLocation location, bool transpose, Float32Array array) {
    _ptr.uniformMatrix2fv(_unwrap(location), _unwrap(transpose), _unwrap(array));
    return;
  }

  void uniformMatrix3fv(WebGLUniformLocation location, bool transpose, Float32Array array) {
    _ptr.uniformMatrix3fv(_unwrap(location), _unwrap(transpose), _unwrap(array));
    return;
  }

  void uniformMatrix4fv(WebGLUniformLocation location, bool transpose, Float32Array array) {
    _ptr.uniformMatrix4fv(_unwrap(location), _unwrap(transpose), _unwrap(array));
    return;
  }

  void useProgram(WebGLProgram program) {
    _ptr.useProgram(_unwrap(program));
    return;
  }

  void validateProgram(WebGLProgram program) {
    _ptr.validateProgram(_unwrap(program));
    return;
  }

  void vertexAttrib1f(int indx, num x) {
    _ptr.vertexAttrib1f(_unwrap(indx), _unwrap(x));
    return;
  }

  void vertexAttrib1fv(int indx, Float32Array values) {
    _ptr.vertexAttrib1fv(_unwrap(indx), _unwrap(values));
    return;
  }

  void vertexAttrib2f(int indx, num x, num y) {
    _ptr.vertexAttrib2f(_unwrap(indx), _unwrap(x), _unwrap(y));
    return;
  }

  void vertexAttrib2fv(int indx, Float32Array values) {
    _ptr.vertexAttrib2fv(_unwrap(indx), _unwrap(values));
    return;
  }

  void vertexAttrib3f(int indx, num x, num y, num z) {
    _ptr.vertexAttrib3f(_unwrap(indx), _unwrap(x), _unwrap(y), _unwrap(z));
    return;
  }

  void vertexAttrib3fv(int indx, Float32Array values) {
    _ptr.vertexAttrib3fv(_unwrap(indx), _unwrap(values));
    return;
  }

  void vertexAttrib4f(int indx, num x, num y, num z, num w) {
    _ptr.vertexAttrib4f(_unwrap(indx), _unwrap(x), _unwrap(y), _unwrap(z), _unwrap(w));
    return;
  }

  void vertexAttrib4fv(int indx, Float32Array values) {
    _ptr.vertexAttrib4fv(_unwrap(indx), _unwrap(values));
    return;
  }

  void vertexAttribPointer(int indx, int size, int type, bool normalized, int stride, int offset) {
    _ptr.vertexAttribPointer(_unwrap(indx), _unwrap(size), _unwrap(type), _unwrap(normalized), _unwrap(stride), _unwrap(offset));
    return;
  }

  void viewport(int x, int y, int width, int height) {
    _ptr.viewport(_unwrap(x), _unwrap(y), _unwrap(width), _unwrap(height));
    return;
  }
}

class _WebGLShaderImpl extends _DOMTypeBase implements WebGLShader {
  _WebGLShaderImpl._wrap(ptr) : super._wrap(ptr);
}

class _WebGLTextureImpl extends _DOMTypeBase implements WebGLTexture {
  _WebGLTextureImpl._wrap(ptr) : super._wrap(ptr);
}

class _WebGLUniformLocationImpl extends _DOMTypeBase implements WebGLUniformLocation {
  _WebGLUniformLocationImpl._wrap(ptr) : super._wrap(ptr);
}

class _WebGLVertexArrayObjectOESImpl extends _DOMTypeBase implements WebGLVertexArrayObjectOES {
  _WebGLVertexArrayObjectOESImpl._wrap(ptr) : super._wrap(ptr);
}

class _WebKitCSSRegionRuleImpl extends _CSSRuleImpl implements WebKitCSSRegionRule {
  _WebKitCSSRegionRuleImpl._wrap(ptr) : super._wrap(ptr);

  CSSRuleList get cssRules() => _wrap(_ptr.cssRules);
}

class _WebKitNamedFlowImpl extends _DOMTypeBase implements WebKitNamedFlow {
  _WebKitNamedFlowImpl._wrap(ptr) : super._wrap(ptr);

  bool get overflow() => _wrap(_ptr.overflow);

  NodeList getRegionsByContentNode(Node contentNode) {
    return _wrap(_ptr.getRegionsByContentNode(_unwrap(contentNode)));
  }
}

class _WebSocketImpl extends _EventTargetImpl implements WebSocket {
  _WebSocketImpl._wrap(ptr) : super._wrap(ptr);

  _WebSocketEventsImpl get on() {
    if (_on == null) _on = new _WebSocketEventsImpl(this);
    return _on;
  }

  String get URL() => _wrap(_ptr.URL);

  String get binaryType() => _wrap(_ptr.binaryType);

  void set binaryType(String value) { _ptr.binaryType = _unwrap(value); }

  int get bufferedAmount() => _wrap(_ptr.bufferedAmount);

  String get extensions() => _wrap(_ptr.extensions);

  String get protocol() => _wrap(_ptr.protocol);

  int get readyState() => _wrap(_ptr.readyState);

  String get url() => _wrap(_ptr.url);

  void _addEventListener(String type, EventListener listener, [bool useCapture = null]) {
    if (useCapture === null) {
      _ptr.addEventListener(_unwrap(type), _unwrap(listener));
      return;
    } else {
      _ptr.addEventListener(_unwrap(type), _unwrap(listener), _unwrap(useCapture));
      return;
    }
  }

  void close([int code = null, String reason = null]) {
    if (code === null) {
      if (reason === null) {
        _ptr.close();
        return;
      }
    } else {
      if (reason === null) {
        _ptr.close(_unwrap(code));
        return;
      } else {
        _ptr.close(_unwrap(code), _unwrap(reason));
        return;
      }
    }
    throw "Incorrect number or type of arguments";
  }

  bool _dispatchEvent(Event evt) {
    return _wrap(_ptr.dispatchEvent(_unwrap(evt)));
  }

  void _removeEventListener(String type, EventListener listener, [bool useCapture = null]) {
    if (useCapture === null) {
      _ptr.removeEventListener(_unwrap(type), _unwrap(listener));
      return;
    } else {
      _ptr.removeEventListener(_unwrap(type), _unwrap(listener), _unwrap(useCapture));
      return;
    }
  }

  bool send(String data) {
    return _wrap(_ptr.send(_unwrap(data)));
  }
}

class _WebSocketEventsImpl extends _EventsImpl implements WebSocketEvents {
  _WebSocketEventsImpl(_ptr) : super(_ptr);

  EventListenerList get close() => _get('close');

  EventListenerList get error() => _get('error');

  EventListenerList get message() => _get('message');

  EventListenerList get open() => _get('open');
}

class _WheelEventImpl extends _UIEventImpl implements WheelEvent {
  _WheelEventImpl._wrap(ptr) : super._wrap(ptr);

  bool get altKey() => _wrap(_ptr.altKey);

  int get clientX() => _wrap(_ptr.clientX);

  int get clientY() => _wrap(_ptr.clientY);

  bool get ctrlKey() => _wrap(_ptr.ctrlKey);

  bool get metaKey() => _wrap(_ptr.metaKey);

  int get offsetX() => _wrap(_ptr.offsetX);

  int get offsetY() => _wrap(_ptr.offsetY);

  int get screenX() => _wrap(_ptr.screenX);

  int get screenY() => _wrap(_ptr.screenY);

  bool get shiftKey() => _wrap(_ptr.shiftKey);

  bool get webkitDirectionInvertedFromDevice() => _wrap(_ptr.webkitDirectionInvertedFromDevice);

  int get wheelDelta() => _wrap(_ptr.wheelDelta);

  int get wheelDeltaX() => _wrap(_ptr.wheelDeltaX);

  int get wheelDeltaY() => _wrap(_ptr.wheelDeltaY);

  int get x() => _wrap(_ptr.x);

  int get y() => _wrap(_ptr.y);

  void initWebKitWheelEvent(int wheelDeltaX, int wheelDeltaY, Window view, int screenX, int screenY, int clientX, int clientY, bool ctrlKey, bool altKey, bool shiftKey, bool metaKey) {
    _ptr.initWebKitWheelEvent(_unwrap(wheelDeltaX), _unwrap(wheelDeltaY), _unwrap(view), _unwrap(screenX), _unwrap(screenY), _unwrap(clientX), _unwrap(clientY), _unwrap(ctrlKey), _unwrap(altKey), _unwrap(shiftKey), _unwrap(metaKey));
    return;
  }
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

class _WindowImpl extends _EventTargetImpl implements Window {

  _DocumentImpl get document() => _wrap(_ptr.document.documentElement);

  void requestLayoutFrame(TimeoutHandler callback) {
    _addMeasurementFrameCallback(callback);
  }

  _WindowImpl._wrap(ptr) : super._wrap(ptr);

  _WindowEventsImpl get on() {
    if (_on == null) _on = new _WindowEventsImpl(this);
    return _on;
  }

  DOMApplicationCache get applicationCache() => _wrap(_ptr.applicationCache);

  Navigator get clientInformation() => _wrap(_ptr.clientInformation);

  bool get closed() => _wrap(_ptr.closed);

  Console get console() => _wrap(_ptr.console);

  Crypto get crypto() => _wrap(_ptr.crypto);

  String get defaultStatus() => _wrap(_ptr.defaultStatus);

  void set defaultStatus(String value) { _ptr.defaultStatus = _unwrap(value); }

  String get defaultstatus() => _wrap(_ptr.defaultstatus);

  void set defaultstatus(String value) { _ptr.defaultstatus = _unwrap(value); }

  num get devicePixelRatio() => _wrap(_ptr.devicePixelRatio);

  Event get event() => _wrap(_ptr.event);

  Element get frameElement() => _wrap(_ptr.frameElement);

  Window get frames() => _wrap(_ptr.frames);

  History get history() => _wrap(_ptr.history);

  int get innerHeight() => _wrap(_ptr.innerHeight);

  int get innerWidth() => _wrap(_ptr.innerWidth);

  int get length() => _wrap(_ptr.length);

  Storage get localStorage() => _wrap(_ptr.localStorage);

  Location get location() => _wrap(_ptr.location);

  void set location(Location value) { _ptr.location = _unwrap(value); }

  BarInfo get locationbar() => _wrap(_ptr.locationbar);

  BarInfo get menubar() => _wrap(_ptr.menubar);

  String get name() => _wrap(_ptr.name);

  void set name(String value) { _ptr.name = _unwrap(value); }

  Navigator get navigator() => _wrap(_ptr.navigator);

  bool get offscreenBuffering() => _wrap(_ptr.offscreenBuffering);

  Window get opener() => _wrap(_ptr.opener);

  int get outerHeight() => _wrap(_ptr.outerHeight);

  int get outerWidth() => _wrap(_ptr.outerWidth);

  int get pageXOffset() => _wrap(_ptr.pageXOffset);

  int get pageYOffset() => _wrap(_ptr.pageYOffset);

  Window get parent() => _wrap(_ptr.parent);

  Performance get performance() => _wrap(_ptr.performance);

  BarInfo get personalbar() => _wrap(_ptr.personalbar);

  Screen get screen() => _wrap(_ptr.screen);

  int get screenLeft() => _wrap(_ptr.screenLeft);

  int get screenTop() => _wrap(_ptr.screenTop);

  int get screenX() => _wrap(_ptr.screenX);

  int get screenY() => _wrap(_ptr.screenY);

  int get scrollX() => _wrap(_ptr.scrollX);

  int get scrollY() => _wrap(_ptr.scrollY);

  BarInfo get scrollbars() => _wrap(_ptr.scrollbars);

  Window get self() => _wrap(_ptr.self);

  Storage get sessionStorage() => _wrap(_ptr.sessionStorage);

  String get status() => _wrap(_ptr.status);

  void set status(String value) { _ptr.status = _unwrap(value); }

  BarInfo get statusbar() => _wrap(_ptr.statusbar);

  StyleMedia get styleMedia() => _wrap(_ptr.styleMedia);

  BarInfo get toolbar() => _wrap(_ptr.toolbar);

  Window get top() => _wrap(_ptr.top);

  IDBFactory get webkitIndexedDB() => _wrap(_ptr.webkitIndexedDB);

  NotificationCenter get webkitNotifications() => _wrap(_ptr.webkitNotifications);

  StorageInfo get webkitStorageInfo() => _wrap(_ptr.webkitStorageInfo);

  Window get window() => _wrap(_ptr.window);

  void _addEventListener(String type, EventListener listener, [bool useCapture = null]) {
    if (useCapture === null) {
      _ptr.addEventListener(_unwrap(type), _unwrap(listener));
      return;
    } else {
      _ptr.addEventListener(_unwrap(type), _unwrap(listener), _unwrap(useCapture));
      return;
    }
  }

  void alert(String message) {
    _ptr.alert(_unwrap(message));
    return;
  }

  String atob(String string) {
    return _wrap(_ptr.atob(_unwrap(string)));
  }

  void blur() {
    _ptr.blur();
    return;
  }

  String btoa(String string) {
    return _wrap(_ptr.btoa(_unwrap(string)));
  }

  void captureEvents() {
    _ptr.captureEvents();
    return;
  }

  void clearInterval(int handle) {
    _ptr.clearInterval(_unwrap(handle));
    return;
  }

  void clearTimeout(int handle) {
    _ptr.clearTimeout(_unwrap(handle));
    return;
  }

  void close() {
    _ptr.close();
    return;
  }

  bool confirm(String message) {
    return _wrap(_ptr.confirm(_unwrap(message)));
  }

  bool _dispatchEvent(Event evt) {
    return _wrap(_ptr.dispatchEvent(_unwrap(evt)));
  }

  bool find(String string, bool caseSensitive, bool backwards, bool wrap, bool wholeWord, bool searchInFrames, bool showDialog) {
    return _wrap(_ptr.find(_unwrap(string), _unwrap(caseSensitive), _unwrap(backwards), _unwrap(wrap), _unwrap(wholeWord), _unwrap(searchInFrames), _unwrap(showDialog)));
  }

  void focus() {
    _ptr.focus();
    return;
  }

  CSSStyleDeclaration _getComputedStyle(Element element, String pseudoElement) {
    return _wrap(_ptr.getComputedStyle(_unwrap(element), _unwrap(pseudoElement)));
  }

  CSSRuleList getMatchedCSSRules(Element element, String pseudoElement) {
    return _wrap(_ptr.getMatchedCSSRules(_unwrap(element), _unwrap(pseudoElement)));
  }

  DOMSelection getSelection() {
    return _wrap(_ptr.getSelection());
  }

  MediaQueryList matchMedia(String query) {
    return _wrap(_ptr.matchMedia(_unwrap(query)));
  }

  void moveBy(num x, num y) {
    _ptr.moveBy(_unwrap(x), _unwrap(y));
    return;
  }

  void moveTo(num x, num y) {
    _ptr.moveTo(_unwrap(x), _unwrap(y));
    return;
  }

  Window open(String url, String name, [String options = null]) {
    if (options === null) {
      return _wrap(_ptr.open(_unwrap(url), _unwrap(name)));
    } else {
      return _wrap(_ptr.open(_unwrap(url), _unwrap(name), _unwrap(options)));
    }
  }

  Database openDatabase(String name, String version, String displayName, int estimatedSize, [DatabaseCallback creationCallback = null]) {
    if (creationCallback === null) {
      return _wrap(_ptr.openDatabase(_unwrap(name), _unwrap(version), _unwrap(displayName), _unwrap(estimatedSize)));
    } else {
      return _wrap(_ptr.openDatabase(_unwrap(name), _unwrap(version), _unwrap(displayName), _unwrap(estimatedSize), _unwrap(creationCallback)));
    }
  }

  void postMessage(Dynamic message, String targetOrigin, [List messagePorts = null]) {
    if (messagePorts === null) {
      _ptr.postMessage(_unwrap(message), _unwrap(targetOrigin));
      return;
    } else {
      _ptr.postMessage(_unwrap(message), _unwrap(targetOrigin), _unwrap(messagePorts));
      return;
    }
  }

  void print() {
    _ptr.print();
    return;
  }

  String prompt(String message, String defaultValue) {
    return _wrap(_ptr.prompt(_unwrap(message), _unwrap(defaultValue)));
  }

  void releaseEvents() {
    _ptr.releaseEvents();
    return;
  }

  void _removeEventListener(String type, EventListener listener, [bool useCapture = null]) {
    if (useCapture === null) {
      _ptr.removeEventListener(_unwrap(type), _unwrap(listener));
      return;
    } else {
      _ptr.removeEventListener(_unwrap(type), _unwrap(listener), _unwrap(useCapture));
      return;
    }
  }

  void resizeBy(num x, num y) {
    _ptr.resizeBy(_unwrap(x), _unwrap(y));
    return;
  }

  void resizeTo(num width, num height) {
    _ptr.resizeTo(_unwrap(width), _unwrap(height));
    return;
  }

  void scroll(int x, int y) {
    _ptr.scroll(_unwrap(x), _unwrap(y));
    return;
  }

  void scrollBy(int x, int y) {
    _ptr.scrollBy(_unwrap(x), _unwrap(y));
    return;
  }

  void scrollTo(int x, int y) {
    _ptr.scrollTo(_unwrap(x), _unwrap(y));
    return;
  }

  int setInterval(TimeoutHandler handler, int timeout) {
    return _wrap(_ptr.setInterval(_unwrap(handler), _unwrap(timeout)));
  }

  int setTimeout(TimeoutHandler handler, int timeout) {
    return _wrap(_ptr.setTimeout(_unwrap(handler), _unwrap(timeout)));
  }

  Object showModalDialog(String url, [Object dialogArgs = null, String featureArgs = null]) {
    if (dialogArgs === null) {
      if (featureArgs === null) {
        return _wrap(_ptr.showModalDialog(_unwrap(url)));
      }
    } else {
      if (featureArgs === null) {
        return _wrap(_ptr.showModalDialog(_unwrap(url), _unwrap(dialogArgs)));
      } else {
        return _wrap(_ptr.showModalDialog(_unwrap(url), _unwrap(dialogArgs), _unwrap(featureArgs)));
      }
    }
    throw "Incorrect number or type of arguments";
  }

  void stop() {
    _ptr.stop();
    return;
  }

  void webkitCancelAnimationFrame(int id) {
    _ptr.webkitCancelAnimationFrame(_unwrap(id));
    return;
  }

  void webkitCancelRequestAnimationFrame(int id) {
    _ptr.webkitCancelRequestAnimationFrame(_unwrap(id));
    return;
  }

  Point webkitConvertPointFromNodeToPage(Node node, Point p) {
    return _wrap(_ptr.webkitConvertPointFromNodeToPage(_unwrap(node), _unwrap(p)));
  }

  Point webkitConvertPointFromPageToNode(Node node, Point p) {
    return _wrap(_ptr.webkitConvertPointFromPageToNode(_unwrap(node), _unwrap(p)));
  }

  void webkitPostMessage(Dynamic message, String targetOrigin, [List transferList = null]) {
    if (transferList === null) {
      _ptr.webkitPostMessage(_unwrap(message), _unwrap(targetOrigin));
      return;
    } else {
      _ptr.webkitPostMessage(_unwrap(message), _unwrap(targetOrigin), _unwrap(transferList));
      return;
    }
  }

  int webkitRequestAnimationFrame(RequestAnimationFrameCallback callback, Element element) {
    return _wrap(_ptr.webkitRequestAnimationFrame(_unwrap(callback), _unwrap(element)));
  }

  void webkitRequestFileSystem(int type, int size, FileSystemCallback successCallback, [ErrorCallback errorCallback = null]) {
    if (errorCallback === null) {
      _ptr.webkitRequestFileSystem(_unwrap(type), _unwrap(size), _unwrap(successCallback));
      return;
    } else {
      _ptr.webkitRequestFileSystem(_unwrap(type), _unwrap(size), _unwrap(successCallback), _unwrap(errorCallback));
      return;
    }
  }

  void webkitResolveLocalFileSystemURL(String url, [EntryCallback successCallback = null, ErrorCallback errorCallback = null]) {
    if (successCallback === null) {
      if (errorCallback === null) {
        _ptr.webkitResolveLocalFileSystemURL(_unwrap(url));
        return;
      }
    } else {
      if (errorCallback === null) {
        _ptr.webkitResolveLocalFileSystemURL(_unwrap(url), _unwrap(successCallback));
        return;
      } else {
        _ptr.webkitResolveLocalFileSystemURL(_unwrap(url), _unwrap(successCallback), _unwrap(errorCallback));
        return;
      }
    }
    throw "Incorrect number or type of arguments";
  }

}

class _WindowEventsImpl extends _EventsImpl implements WindowEvents {
  _WindowEventsImpl(_ptr) : super(_ptr);

  EventListenerList get abort() => _get('abort');

  EventListenerList get animationEnd() => _get('webkitAnimationEnd');

  EventListenerList get animationIteration() => _get('webkitAnimationIteration');

  EventListenerList get animationStart() => _get('webkitAnimationStart');

  EventListenerList get beforeUnload() => _get('beforeunload');

  EventListenerList get blur() => _get('blur');

  EventListenerList get canPlay() => _get('canplay');

  EventListenerList get canPlayThrough() => _get('canplaythrough');

  EventListenerList get change() => _get('change');

  EventListenerList get click() => _get('click');

  EventListenerList get contentLoaded() => _get('DOMContentLoaded');

  EventListenerList get contextMenu() => _get('contextmenu');

  EventListenerList get deviceMotion() => _get('devicemotion');

  EventListenerList get deviceOrientation() => _get('deviceorientation');

  EventListenerList get doubleClick() => _get('dblclick');

  EventListenerList get drag() => _get('drag');

  EventListenerList get dragEnd() => _get('dragend');

  EventListenerList get dragEnter() => _get('dragenter');

  EventListenerList get dragLeave() => _get('dragleave');

  EventListenerList get dragOver() => _get('dragover');

  EventListenerList get dragStart() => _get('dragstart');

  EventListenerList get drop() => _get('drop');

  EventListenerList get durationChange() => _get('durationchange');

  EventListenerList get emptied() => _get('emptied');

  EventListenerList get ended() => _get('ended');

  EventListenerList get error() => _get('error');

  EventListenerList get focus() => _get('focus');

  EventListenerList get hashChange() => _get('hashchange');

  EventListenerList get input() => _get('input');

  EventListenerList get invalid() => _get('invalid');

  EventListenerList get keyDown() => _get('keydown');

  EventListenerList get keyPress() => _get('keypress');

  EventListenerList get keyUp() => _get('keyup');

  EventListenerList get load() => _get('load');

  EventListenerList get loadStart() => _get('loadstart');

  EventListenerList get loadedData() => _get('loadeddata');

  EventListenerList get loadedMetadata() => _get('loadedmetadata');

  EventListenerList get message() => _get('message');

  EventListenerList get mouseDown() => _get('mousedown');

  EventListenerList get mouseMove() => _get('mousemove');

  EventListenerList get mouseOut() => _get('mouseout');

  EventListenerList get mouseOver() => _get('mouseover');

  EventListenerList get mouseUp() => _get('mouseup');

  EventListenerList get mouseWheel() => _get('mousewheel');

  EventListenerList get offline() => _get('offline');

  EventListenerList get online() => _get('online');

  EventListenerList get pageHide() => _get('pagehide');

  EventListenerList get pageShow() => _get('pageshow');

  EventListenerList get pause() => _get('pause');

  EventListenerList get play() => _get('play');

  EventListenerList get playing() => _get('playing');

  EventListenerList get popState() => _get('popstate');

  EventListenerList get progress() => _get('progress');

  EventListenerList get rateChange() => _get('ratechange');

  EventListenerList get reset() => _get('reset');

  EventListenerList get resize() => _get('resize');

  EventListenerList get scroll() => _get('scroll');

  EventListenerList get search() => _get('search');

  EventListenerList get seeked() => _get('seeked');

  EventListenerList get seeking() => _get('seeking');

  EventListenerList get select() => _get('select');

  EventListenerList get stalled() => _get('stalled');

  EventListenerList get storage() => _get('storage');

  EventListenerList get submit() => _get('submit');

  EventListenerList get suspend() => _get('suspend');

  EventListenerList get timeUpdate() => _get('timeupdate');

  EventListenerList get touchCancel() => _get('touchcancel');

  EventListenerList get touchEnd() => _get('touchend');

  EventListenerList get touchMove() => _get('touchmove');

  EventListenerList get touchStart() => _get('touchstart');

  EventListenerList get transitionEnd() => _get('webkitTransitionEnd');

  EventListenerList get unload() => _get('unload');

  EventListenerList get volumeChange() => _get('volumechange');

  EventListenerList get waiting() => _get('waiting');
}

class _WorkerImpl extends _AbstractWorkerImpl implements Worker {
  _WorkerImpl._wrap(ptr) : super._wrap(ptr);

  _WorkerEventsImpl get on() {
    if (_on == null) _on = new _WorkerEventsImpl(this);
    return _on;
  }

  void postMessage(Dynamic message, [List messagePorts = null]) {
    if (messagePorts === null) {
      _ptr.postMessage(_unwrap(message));
      return;
    } else {
      _ptr.postMessage(_unwrap(message), _unwrap(messagePorts));
      return;
    }
  }

  void terminate() {
    _ptr.terminate();
    return;
  }

  void webkitPostMessage(Dynamic message, [List messagePorts = null]) {
    if (messagePorts === null) {
      _ptr.webkitPostMessage(_unwrap(message));
      return;
    } else {
      _ptr.webkitPostMessage(_unwrap(message), _unwrap(messagePorts));
      return;
    }
  }
}

class _WorkerEventsImpl extends _AbstractWorkerEventsImpl implements WorkerEvents {
  _WorkerEventsImpl(_ptr) : super(_ptr);

  EventListenerList get message() => _get('message');
}

class _WorkerContextImpl extends _DOMTypeBase implements WorkerContext {
  _WorkerContextImpl._wrap(ptr) : super._wrap(ptr);

  WorkerLocation get location() => _wrap(_ptr.location);

  WorkerNavigator get navigator() => _wrap(_ptr.navigator);

  EventListener get onerror() => _wrap(_ptr.onerror);

  void set onerror(EventListener value) { _ptr.onerror = _unwrap(value); }

  WorkerContext get self() => _wrap(_ptr.self);

  IDBFactory get webkitIndexedDB() => _wrap(_ptr.webkitIndexedDB);

  NotificationCenter get webkitNotifications() => _wrap(_ptr.webkitNotifications);

  void addEventListener(String type, EventListener listener, [bool useCapture = null]) {
    if (useCapture === null) {
      _ptr.addEventListener(_unwrap(type), _unwrap(listener));
      return;
    } else {
      _ptr.addEventListener(_unwrap(type), _unwrap(listener), _unwrap(useCapture));
      return;
    }
  }

  void clearInterval(int handle) {
    _ptr.clearInterval(_unwrap(handle));
    return;
  }

  void clearTimeout(int handle) {
    _ptr.clearTimeout(_unwrap(handle));
    return;
  }

  void close() {
    _ptr.close();
    return;
  }

  bool dispatchEvent(Event evt) {
    return _wrap(_ptr.dispatchEvent(_unwrap(evt)));
  }

  void importScripts() {
    _ptr.importScripts();
    return;
  }

  Database openDatabase(String name, String version, String displayName, int estimatedSize, [DatabaseCallback creationCallback = null]) {
    if (creationCallback === null) {
      return _wrap(_ptr.openDatabase(_unwrap(name), _unwrap(version), _unwrap(displayName), _unwrap(estimatedSize)));
    } else {
      return _wrap(_ptr.openDatabase(_unwrap(name), _unwrap(version), _unwrap(displayName), _unwrap(estimatedSize), _unwrap(creationCallback)));
    }
  }

  DatabaseSync openDatabaseSync(String name, String version, String displayName, int estimatedSize, [DatabaseCallback creationCallback = null]) {
    if (creationCallback === null) {
      return _wrap(_ptr.openDatabaseSync(_unwrap(name), _unwrap(version), _unwrap(displayName), _unwrap(estimatedSize)));
    } else {
      return _wrap(_ptr.openDatabaseSync(_unwrap(name), _unwrap(version), _unwrap(displayName), _unwrap(estimatedSize), _unwrap(creationCallback)));
    }
  }

  void removeEventListener(String type, EventListener listener, [bool useCapture = null]) {
    if (useCapture === null) {
      _ptr.removeEventListener(_unwrap(type), _unwrap(listener));
      return;
    } else {
      _ptr.removeEventListener(_unwrap(type), _unwrap(listener), _unwrap(useCapture));
      return;
    }
  }

  int setInterval(TimeoutHandler handler, int timeout) {
    return _wrap(_ptr.setInterval(_unwrap(handler), _unwrap(timeout)));
  }

  int setTimeout(TimeoutHandler handler, int timeout) {
    return _wrap(_ptr.setTimeout(_unwrap(handler), _unwrap(timeout)));
  }

  void webkitRequestFileSystem(int type, int size, [FileSystemCallback successCallback = null, ErrorCallback errorCallback = null]) {
    if (successCallback === null) {
      if (errorCallback === null) {
        _ptr.webkitRequestFileSystem(_unwrap(type), _unwrap(size));
        return;
      }
    } else {
      if (errorCallback === null) {
        _ptr.webkitRequestFileSystem(_unwrap(type), _unwrap(size), _unwrap(successCallback));
        return;
      } else {
        _ptr.webkitRequestFileSystem(_unwrap(type), _unwrap(size), _unwrap(successCallback), _unwrap(errorCallback));
        return;
      }
    }
    throw "Incorrect number or type of arguments";
  }

  DOMFileSystemSync webkitRequestFileSystemSync(int type, int size) {
    return _wrap(_ptr.webkitRequestFileSystemSync(_unwrap(type), _unwrap(size)));
  }

  EntrySync webkitResolveLocalFileSystemSyncURL(String url) {
    return _wrap(_ptr.webkitResolveLocalFileSystemSyncURL(_unwrap(url)));
  }

  void webkitResolveLocalFileSystemURL(String url, [EntryCallback successCallback = null, ErrorCallback errorCallback = null]) {
    if (successCallback === null) {
      if (errorCallback === null) {
        _ptr.webkitResolveLocalFileSystemURL(_unwrap(url));
        return;
      }
    } else {
      if (errorCallback === null) {
        _ptr.webkitResolveLocalFileSystemURL(_unwrap(url), _unwrap(successCallback));
        return;
      } else {
        _ptr.webkitResolveLocalFileSystemURL(_unwrap(url), _unwrap(successCallback), _unwrap(errorCallback));
        return;
      }
    }
    throw "Incorrect number or type of arguments";
  }
}

class _WorkerLocationImpl extends _DOMTypeBase implements WorkerLocation {
  _WorkerLocationImpl._wrap(ptr) : super._wrap(ptr);

  String get hash() => _wrap(_ptr.hash);

  String get host() => _wrap(_ptr.host);

  String get hostname() => _wrap(_ptr.hostname);

  String get href() => _wrap(_ptr.href);

  String get pathname() => _wrap(_ptr.pathname);

  String get port() => _wrap(_ptr.port);

  String get protocol() => _wrap(_ptr.protocol);

  String get search() => _wrap(_ptr.search);

  String toString() {
    return _wrap(_ptr.toString());
  }
}

class _WorkerNavigatorImpl extends _DOMTypeBase implements WorkerNavigator {
  _WorkerNavigatorImpl._wrap(ptr) : super._wrap(ptr);

  String get appName() => _wrap(_ptr.appName);

  String get appVersion() => _wrap(_ptr.appVersion);

  bool get onLine() => _wrap(_ptr.onLine);

  String get platform() => _wrap(_ptr.platform);

  String get userAgent() => _wrap(_ptr.userAgent);
}

class _XMLHttpRequestImpl extends _EventTargetImpl implements XMLHttpRequest {
  _XMLHttpRequestImpl._wrap(ptr) : super._wrap(ptr);

  _XMLHttpRequestEventsImpl get on() {
    if (_on == null) _on = new _XMLHttpRequestEventsImpl(this);
    return _on;
  }

  bool get asBlob() => _wrap(_ptr.asBlob);

  void set asBlob(bool value) { _ptr.asBlob = _unwrap(value); }

  int get readyState() => _wrap(_ptr.readyState);

  Object get response() => _wrap(_ptr.response);

  Blob get responseBlob() => _wrap(_ptr.responseBlob);

  String get responseText() => _wrap(_ptr.responseText);

  String get responseType() => _wrap(_ptr.responseType);

  void set responseType(String value) { _ptr.responseType = _unwrap(value); }

  Document get responseXML() => _FixHtmlDocumentReference(_wrap(_ptr.responseXML));

  int get status() => _wrap(_ptr.status);

  String get statusText() => _wrap(_ptr.statusText);

  XMLHttpRequestUpload get upload() => _wrap(_ptr.upload);

  bool get withCredentials() => _wrap(_ptr.withCredentials);

  void set withCredentials(bool value) { _ptr.withCredentials = _unwrap(value); }

  void abort() {
    _ptr.abort();
    return;
  }

  void _addEventListener(String type, EventListener listener, [bool useCapture = null]) {
    if (useCapture === null) {
      _ptr.addEventListener(_unwrap(type), _unwrap(listener));
      return;
    } else {
      _ptr.addEventListener(_unwrap(type), _unwrap(listener), _unwrap(useCapture));
      return;
    }
  }

  bool _dispatchEvent(Event evt) {
    return _wrap(_ptr.dispatchEvent(_unwrap(evt)));
  }

  String getAllResponseHeaders() {
    return _wrap(_ptr.getAllResponseHeaders());
  }

  String getResponseHeader(String header) {
    return _wrap(_ptr.getResponseHeader(_unwrap(header)));
  }

  void open(String method, String url, [bool async = null, String user = null, String password = null]) {
    if (async === null) {
      if (user === null) {
        if (password === null) {
          _ptr.open(_unwrap(method), _unwrap(url));
          return;
        }
      }
    } else {
      if (user === null) {
        if (password === null) {
          _ptr.open(_unwrap(method), _unwrap(url), _unwrap(async));
          return;
        }
      } else {
        if (password === null) {
          _ptr.open(_unwrap(method), _unwrap(url), _unwrap(async), _unwrap(user));
          return;
        } else {
          _ptr.open(_unwrap(method), _unwrap(url), _unwrap(async), _unwrap(user), _unwrap(password));
          return;
        }
      }
    }
    throw "Incorrect number or type of arguments";
  }

  void overrideMimeType(String override) {
    _ptr.overrideMimeType(_unwrap(override));
    return;
  }

  void _removeEventListener(String type, EventListener listener, [bool useCapture = null]) {
    if (useCapture === null) {
      _ptr.removeEventListener(_unwrap(type), _unwrap(listener));
      return;
    } else {
      _ptr.removeEventListener(_unwrap(type), _unwrap(listener), _unwrap(useCapture));
      return;
    }
  }

  void send([var data = null]) {
    if (data === null) {
      _ptr.send();
      return;
    } else {
      if (data is ArrayBuffer) {
        _ptr.send(_unwrap(data));
        return;
      } else {
        if (data is Blob) {
          _ptr.send(_unwrap(data));
          return;
        } else {
          if (data is Document) {
            _ptr.send(_unwrap(data));
            return;
          } else {
            if (data is String) {
              _ptr.send(_unwrap(data));
              return;
            } else {
              if (data is DOMFormData) {
                _ptr.send(_unwrap(data));
                return;
              }
            }
          }
        }
      }
    }
    throw "Incorrect number or type of arguments";
  }

  void setRequestHeader(String header, String value) {
    _ptr.setRequestHeader(_unwrap(header), _unwrap(value));
    return;
  }
}

class _XMLHttpRequestEventsImpl extends _EventsImpl implements XMLHttpRequestEvents {
  _XMLHttpRequestEventsImpl(_ptr) : super(_ptr);

  EventListenerList get abort() => _get('abort');

  EventListenerList get error() => _get('error');

  EventListenerList get load() => _get('load');

  EventListenerList get loadEnd() => _get('loadend');

  EventListenerList get loadStart() => _get('loadstart');

  EventListenerList get progress() => _get('progress');

  EventListenerList get readyStateChange() => _get('readystatechange');
}

class _XMLHttpRequestExceptionImpl extends _DOMTypeBase implements XMLHttpRequestException {
  _XMLHttpRequestExceptionImpl._wrap(ptr) : super._wrap(ptr);

  int get code() => _wrap(_ptr.code);

  String get message() => _wrap(_ptr.message);

  String get name() => _wrap(_ptr.name);

  String toString() {
    return _wrap(_ptr.toString());
  }
}

class _XMLHttpRequestProgressEventImpl extends _ProgressEventImpl implements XMLHttpRequestProgressEvent {
  _XMLHttpRequestProgressEventImpl._wrap(ptr) : super._wrap(ptr);

  int get position() => _wrap(_ptr.position);

  int get totalSize() => _wrap(_ptr.totalSize);
}

class _XMLHttpRequestUploadImpl extends _EventTargetImpl implements XMLHttpRequestUpload {
  _XMLHttpRequestUploadImpl._wrap(ptr) : super._wrap(ptr);

  _XMLHttpRequestUploadEventsImpl get on() {
    if (_on == null) _on = new _XMLHttpRequestUploadEventsImpl(this);
    return _on;
  }

  void _addEventListener(String type, EventListener listener, [bool useCapture = null]) {
    if (useCapture === null) {
      _ptr.addEventListener(_unwrap(type), _unwrap(listener));
      return;
    } else {
      _ptr.addEventListener(_unwrap(type), _unwrap(listener), _unwrap(useCapture));
      return;
    }
  }

  bool _dispatchEvent(Event evt) {
    return _wrap(_ptr.dispatchEvent(_unwrap(evt)));
  }

  void _removeEventListener(String type, EventListener listener, [bool useCapture = null]) {
    if (useCapture === null) {
      _ptr.removeEventListener(_unwrap(type), _unwrap(listener));
      return;
    } else {
      _ptr.removeEventListener(_unwrap(type), _unwrap(listener), _unwrap(useCapture));
      return;
    }
  }
}

class _XMLHttpRequestUploadEventsImpl extends _EventsImpl implements XMLHttpRequestUploadEvents {
  _XMLHttpRequestUploadEventsImpl(_ptr) : super(_ptr);

  EventListenerList get abort() => _get('abort');

  EventListenerList get error() => _get('error');

  EventListenerList get load() => _get('load');

  EventListenerList get loadEnd() => _get('loadend');

  EventListenerList get loadStart() => _get('loadstart');

  EventListenerList get progress() => _get('progress');
}

class _XMLSerializerImpl extends _DOMTypeBase implements XMLSerializer {
  _XMLSerializerImpl._wrap(ptr) : super._wrap(ptr);

  String serializeToString(Node node) {
    return _wrap(_ptr.serializeToString(_unwrap(node)));
  }
}

class _XPathEvaluatorImpl extends _DOMTypeBase implements XPathEvaluator {
  _XPathEvaluatorImpl._wrap(ptr) : super._wrap(ptr);

  XPathExpression createExpression(String expression, XPathNSResolver resolver) {
    return _wrap(_ptr.createExpression(_unwrap(expression), _unwrap(resolver)));
  }

  XPathNSResolver createNSResolver(Node nodeResolver) {
    return _wrap(_ptr.createNSResolver(_unwrap(nodeResolver)));
  }

  XPathResult evaluate(String expression, Node contextNode, XPathNSResolver resolver, int type, XPathResult inResult) {
    return _wrap(_ptr.evaluate(_unwrap(expression), _unwrap(contextNode), _unwrap(resolver), _unwrap(type), _unwrap(inResult)));
  }
}

class _XPathExceptionImpl extends _DOMTypeBase implements XPathException {
  _XPathExceptionImpl._wrap(ptr) : super._wrap(ptr);

  int get code() => _wrap(_ptr.code);

  String get message() => _wrap(_ptr.message);

  String get name() => _wrap(_ptr.name);

  String toString() {
    return _wrap(_ptr.toString());
  }
}

class _XPathExpressionImpl extends _DOMTypeBase implements XPathExpression {
  _XPathExpressionImpl._wrap(ptr) : super._wrap(ptr);

  XPathResult evaluate(Node contextNode, int type, XPathResult inResult) {
    return _wrap(_ptr.evaluate(_unwrap(contextNode), _unwrap(type), _unwrap(inResult)));
  }
}

class _XPathNSResolverImpl extends _DOMTypeBase implements XPathNSResolver {
  _XPathNSResolverImpl._wrap(ptr) : super._wrap(ptr);

  String lookupNamespaceURI(String prefix) {
    return _wrap(_ptr.lookupNamespaceURI(_unwrap(prefix)));
  }
}

class _XPathResultImpl extends _DOMTypeBase implements XPathResult {
  _XPathResultImpl._wrap(ptr) : super._wrap(ptr);

  bool get booleanValue() => _wrap(_ptr.booleanValue);

  bool get invalidIteratorState() => _wrap(_ptr.invalidIteratorState);

  num get numberValue() => _wrap(_ptr.numberValue);

  int get resultType() => _wrap(_ptr.resultType);

  Node get singleNodeValue() => _wrap(_ptr.singleNodeValue);

  int get snapshotLength() => _wrap(_ptr.snapshotLength);

  String get stringValue() => _wrap(_ptr.stringValue);

  Node iterateNext() {
    return _wrap(_ptr.iterateNext());
  }

  Node snapshotItem(int index) {
    return _wrap(_ptr.snapshotItem(_unwrap(index)));
  }
}

class _XSLTProcessorImpl extends _DOMTypeBase implements XSLTProcessor {
  _XSLTProcessorImpl._wrap(ptr) : super._wrap(ptr);

  void clearParameters() {
    _ptr.clearParameters();
    return;
  }

  String getParameter(String namespaceURI, String localName) {
    return _wrap(_ptr.getParameter(_unwrap(namespaceURI), _unwrap(localName)));
  }

  void importStylesheet(Node stylesheet) {
    _ptr.importStylesheet(_unwrap(stylesheet));
    return;
  }

  void removeParameter(String namespaceURI, String localName) {
    _ptr.removeParameter(_unwrap(namespaceURI), _unwrap(localName));
    return;
  }

  void reset() {
    _ptr.reset();
    return;
  }

  void setParameter(String namespaceURI, String localName, String value) {
    _ptr.setParameter(_unwrap(namespaceURI), _unwrap(localName), _unwrap(value));
    return;
  }

  Document transformToDocument(Node source) {
    return _FixHtmlDocumentReference(_wrap(_ptr.transformToDocument(_unwrap(source))));
  }

  DocumentFragment transformToFragment(Node source, Document docVal) {
    return _wrap(_ptr.transformToFragment(_unwrap(source), _unwrap(docVal)));
  }
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

class _AudioElementFactoryProvider {
  factory AudioElement([String src = null]) =>
      _wrap(new dom.HTMLAudioElement(_unwrap(src)));
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

class _BlobBuilderFactoryProvider {
  factory BlobBuilder() =>
      _wrap(new dom.WebKitBlobBuilder());
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

class _CSSMatrixFactoryProvider {
  factory CSSMatrix([String cssValue = '']) =>
      _wrap(new dom.WebKitCSSMatrix(cssValue));
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

class _DOMParserFactoryProvider {
  factory DOMParser() =>
      _wrap(new dom.DOMParser());
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

class _DOMURLFactoryProvider {
  factory DOMURL() =>
      _wrap(new dom.DOMURL());
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

class _DeprecatedPeerConnectionFactoryProvider {
  factory DeprecatedPeerConnection(String serverConfiguration, SignalingCallback signalingCallback) =>
      _wrap(new dom.DeprecatedPeerConnection(_unwrap(serverConfiguration), _unwrap(signalingCallback)));
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

class _EventSourceFactoryProvider {
  factory EventSource(String scriptUrl) =>
      _wrap(new dom.EventSource(_unwrap(scriptUrl)));
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

class _FileReaderFactoryProvider {
  factory FileReader() =>
      _wrap(new dom.FileReader());
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

class _FileReaderSyncFactoryProvider {
  factory FileReaderSync() =>
      _wrap(new dom.FileReaderSync());
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

class _IceCandidateFactoryProvider {
  factory IceCandidate(String label, String candidateLine) =>
      _wrap(new dom.IceCandidate(_unwrap(label), _unwrap(candidateLine)));
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

class _MediaControllerFactoryProvider {
  factory MediaController() =>
      _wrap(new dom.MediaController());
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

class _MediaStreamFactoryProvider {
  factory MediaStream(MediaStreamTrackList audioTracks, MediaStreamTrackList videoTracks) =>
      _wrap(new dom.MediaStream(_unwrap(audioTracks), _unwrap(videoTracks)));
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

class _MessageChannelFactoryProvider {
  factory MessageChannel() =>
      _wrap(new dom.MessageChannel());
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

class _OptionElementFactoryProvider {
  factory OptionElement([String data = null, String value = null, bool defaultSelected = null, bool selected = null]) =>
      _wrap(new dom.HTMLOptionElement(_unwrap(data), _unwrap(value), _unwrap(defaultSelected), _unwrap(selected)));
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

class _SessionDescriptionFactoryProvider {
  factory SessionDescription(String sdp) =>
      _wrap(new dom.SessionDescription(_unwrap(sdp)));
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

class _ShadowRootFactoryProvider {
  factory ShadowRoot(Element host) =>
      _wrap(new dom.ShadowRoot(_unwrap(host)));
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

class _SharedWorkerFactoryProvider {
  factory SharedWorker(String scriptURL, [String name = null]) =>
      _wrap(new dom.SharedWorker(_unwrap(scriptURL), _unwrap(name)));
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

class _SpeechGrammarFactoryProvider {
  factory SpeechGrammar() =>
      _wrap(new dom.SpeechGrammar());
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

class _SpeechGrammarListFactoryProvider {
  factory SpeechGrammarList() =>
      _wrap(new dom.SpeechGrammarList());
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

class _SpeechRecognitionFactoryProvider {
  factory SpeechRecognition() =>
      _wrap(new dom.SpeechRecognition());
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

class _TextTrackCueFactoryProvider {
  factory TextTrackCue(String id, num startTime, num endTime, String text, [String settings = null, bool pauseOnExit = null]) =>
      _wrap(new dom.TextTrackCue(_unwrap(id), _unwrap(startTime), _unwrap(endTime), _unwrap(text), _unwrap(settings), _unwrap(pauseOnExit)));
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

class _WorkerFactoryProvider {
  factory Worker(String scriptUrl) =>
      _wrap(new dom.Worker(_unwrap(scriptUrl)));
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

class _XMLHttpRequestFactoryProvider {
  factory XMLHttpRequest() => _wrap(new dom.XMLHttpRequest());

  factory XMLHttpRequest.getTEMPNAME(String url,
                                     onSuccess(XMLHttpRequest request)) =>
      _XMLHttpRequestUtils.getTEMPNAME(url, onSuccess);
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

class _XMLSerializerFactoryProvider {
  factory XMLSerializer() =>
      _wrap(new dom.XMLSerializer());
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

class _XPathEvaluatorFactoryProvider {
  factory XPathEvaluator() =>
      _wrap(new dom.XPathEvaluator());
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

class _XSLTProcessorFactoryProvider {
  factory XSLTProcessor() =>
      _wrap(new dom.XSLTProcessor());
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

interface AbstractWorker extends EventTarget {

  AbstractWorkerEvents get on();
}

interface AbstractWorkerEvents extends Events {

  EventListenerList get error();
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

interface AnchorElement extends Element {

  String charset;

  String coords;

  String download;

  String hash;

  String host;

  String hostname;

  String href;

  String hreflang;

  String name;

  final String origin;

  String pathname;

  String ping;

  String port;

  String protocol;

  String rel;

  String rev;

  String search;

  String shape;

  String target;

  String type;

  String toString();
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

interface Animation {

  static final int DIRECTION_ALTERNATE = 1;

  static final int DIRECTION_NORMAL = 0;

  static final int FILL_BACKWARDS = 1;

  static final int FILL_BOTH = 3;

  static final int FILL_FORWARDS = 2;

  static final int FILL_NONE = 0;

  final num delay;

  final int direction;

  final num duration;

  num elapsedTime;

  final bool ended;

  final int fillMode;

  final int iterationCount;

  final String name;

  final bool paused;

  void pause();

  void play();
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

interface AnimationEvent extends Event {

  final String animationName;

  final num elapsedTime;
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

interface AnimationList {

  final int length;

  Animation item(int index);
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

interface AppletElement extends Element {

  String align;

  String alt;

  String archive;

  String code;

  String codeBase;

  String height;

  String hspace;

  String name;

  String object;

  String vspace;

  String width;
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

interface AreaElement extends Element {

  String alt;

  String coords;

  final String hash;

  final String host;

  final String hostname;

  String href;

  bool noHref;

  final String pathname;

  String ping;

  final String port;

  final String protocol;

  final String search;

  String shape;

  String target;
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

interface ArrayBuffer {

  final int byteLength;

  ArrayBuffer slice(int begin, [int end]);
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

interface ArrayBufferView {

  final ArrayBuffer buffer;

  final int byteLength;

  final int byteOffset;
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

interface Attr extends Node {

  final bool isId;

  final String name;

  final Element ownerElement;

  final bool specified;

  String value;
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

interface AudioBuffer {

  final num duration;

  num gain;

  final int length;

  final int numberOfChannels;

  final num sampleRate;

  Float32Array getChannelData(int channelIndex);
}
// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

typedef bool AudioBufferCallback(AudioBuffer audioBuffer);
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

interface AudioBufferSourceNode extends AudioSourceNode {

  static final int FINISHED_STATE = 3;

  static final int PLAYING_STATE = 2;

  static final int SCHEDULED_STATE = 1;

  static final int UNSCHEDULED_STATE = 0;

  AudioBuffer buffer;

  final AudioGain gain;

  bool loop;

  bool looping;

  final AudioParam playbackRate;

  final int playbackState;

  void noteGrainOn(num when, num grainOffset, num grainDuration);

  void noteOff(num when);

  void noteOn(num when);
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

interface AudioChannelMerger extends AudioNode {
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

interface AudioChannelSplitter extends AudioNode {
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

interface AudioContext {

  final int activeSourceCount;

  final num currentTime;

  final AudioDestinationNode destination;

  final AudioListener listener;

  EventListener oncomplete;

  final num sampleRate;

  RealtimeAnalyserNode createAnalyser();

  BiquadFilterNode createBiquadFilter();

  AudioBuffer createBuffer(var buffer_OR_numberOfChannels, var mixToMono_OR_numberOfFrames, [num sampleRate]);

  AudioBufferSourceNode createBufferSource();

  AudioChannelMerger createChannelMerger();

  AudioChannelSplitter createChannelSplitter();

  ConvolverNode createConvolver();

  DelayNode createDelayNode([num maxDelayTime]);

  DynamicsCompressorNode createDynamicsCompressor();

  AudioGainNode createGainNode();

  HighPass2FilterNode createHighPass2Filter();

  JavaScriptAudioNode createJavaScriptNode(int bufferSize);

  LowPass2FilterNode createLowPass2Filter();

  MediaElementAudioSourceNode createMediaElementSource(MediaElement mediaElement);

  AudioPannerNode createPanner();

  WaveShaperNode createWaveShaper();

  void decodeAudioData(ArrayBuffer audioData, AudioBufferCallback successCallback, [AudioBufferCallback errorCallback]);

  void startRendering();
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

interface AudioDestinationNode extends AudioNode {

  final int numberOfChannels;
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

interface AudioElement extends MediaElement default _AudioElementFactoryProvider {

  AudioElement([String src]);
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

interface AudioGain extends AudioParam {
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

interface AudioGainNode extends AudioNode {

  final AudioGain gain;
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

interface AudioListener {

  num dopplerFactor;

  num speedOfSound;

  void setOrientation(num x, num y, num z, num xUp, num yUp, num zUp);

  void setPosition(num x, num y, num z);

  void setVelocity(num x, num y, num z);
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

interface AudioNode {

  final AudioContext context;

  final int numberOfInputs;

  final int numberOfOutputs;

  void connect(AudioNode destination, int output, int input);

  void disconnect(int output);
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

interface AudioPannerNode extends AudioNode {

  static final int EQUALPOWER = 0;

  static final int EXPONENTIAL_DISTANCE = 2;

  static final int HRTF = 1;

  static final int INVERSE_DISTANCE = 1;

  static final int LINEAR_DISTANCE = 0;

  static final int SOUNDFIELD = 2;

  final AudioGain coneGain;

  num coneInnerAngle;

  num coneOuterAngle;

  num coneOuterGain;

  final AudioGain distanceGain;

  int distanceModel;

  num maxDistance;

  int panningModel;

  num refDistance;

  num rolloffFactor;

  void setOrientation(num x, num y, num z);

  void setPosition(num x, num y, num z);

  void setVelocity(num x, num y, num z);
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

interface AudioParam {

  final num defaultValue;

  final num maxValue;

  final num minValue;

  final String name;

  final int units;

  num value;

  void cancelScheduledValues(num startTime);

  void exponentialRampToValueAtTime(num value, num time);

  void linearRampToValueAtTime(num value, num time);

  void setTargetValueAtTime(num targetValue, num time, num timeConstant);

  void setValueAtTime(num value, num time);

  void setValueCurveAtTime(Float32Array values, num time, num duration);
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

interface AudioProcessingEvent extends Event {

  final AudioBuffer inputBuffer;

  final AudioBuffer outputBuffer;
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

interface AudioSourceNode extends AudioNode {
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

interface BRElement extends Element {

  String clear;
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

interface BarInfo {

  final bool visible;
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

interface BaseElement extends Element {

  String href;

  String target;
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

interface BaseFontElement extends Element {

  String color;

  String face;

  int size;
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

interface BeforeLoadEvent extends Event {

  final String url;
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

interface BiquadFilterNode extends AudioNode {

  static final int ALLPASS = 7;

  static final int BANDPASS = 2;

  static final int HIGHPASS = 1;

  static final int HIGHSHELF = 4;

  static final int LOWPASS = 0;

  static final int LOWSHELF = 3;

  static final int NOTCH = 6;

  static final int PEAKING = 5;

  final AudioParam Q;

  final AudioParam frequency;

  final AudioParam gain;

  int type;

  void getFrequencyResponse(Float32Array frequencyHz, Float32Array magResponse, Float32Array phaseResponse);
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

interface Blob {

  final int size;

  final String type;

  Blob webkitSlice([int start, int end, String contentType]);
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

interface BlobBuilder default _BlobBuilderFactoryProvider {

  BlobBuilder();

  void append(var arrayBuffer_OR_blob_OR_value, [String endings]);

  Blob getBlob([String contentType]);
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

interface BodyElement extends Element {

  BodyElementEvents get on();

  String aLink;

  String background;

  String bgColor;

  String link;

  String vLink;
}

interface BodyElementEvents extends ElementEvents {

  EventListenerList get beforeUnload();

  EventListenerList get blur();

  EventListenerList get error();

  EventListenerList get focus();

  EventListenerList get hashChange();

  EventListenerList get load();

  EventListenerList get message();

  EventListenerList get offline();

  EventListenerList get online();

  EventListenerList get popState();

  EventListenerList get resize();

  EventListenerList get storage();

  EventListenerList get unload();
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

interface ButtonElement extends Element {

  bool autofocus;

  bool disabled;

  final FormElement form;

  String formAction;

  String formEnctype;

  String formMethod;

  bool formNoValidate;

  String formTarget;

  final NodeList labels;

  String name;

  final String type;

  final String validationMessage;

  final ValidityState validity;

  String value;

  final bool willValidate;

  bool checkValidity();

  void setCustomValidity(String error);
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

interface CDATASection extends Text {
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

interface CSSCharsetRule extends CSSRule {

  String encoding;
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

interface CSSFontFaceRule extends CSSRule {

  final CSSStyleDeclaration style;
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

interface CSSImportRule extends CSSRule {

  final String href;

  final MediaList media;

  final CSSStyleSheet styleSheet;
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

interface CSSKeyframeRule extends CSSRule {

  String keyText;

  final CSSStyleDeclaration style;
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

interface CSSKeyframesRule extends CSSRule {

  final CSSRuleList cssRules;

  String name;

  void deleteRule(String key);

  CSSKeyframeRule findRule(String key);

  void insertRule(String rule);
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

interface CSSMatrix default _CSSMatrixFactoryProvider {

  CSSMatrix([String cssValue]);

  num a;

  num b;

  num c;

  num d;

  num e;

  num f;

  num m11;

  num m12;

  num m13;

  num m14;

  num m21;

  num m22;

  num m23;

  num m24;

  num m31;

  num m32;

  num m33;

  num m34;

  num m41;

  num m42;

  num m43;

  num m44;

  CSSMatrix inverse();

  CSSMatrix multiply(CSSMatrix secondMatrix);

  CSSMatrix rotate(num rotX, num rotY, num rotZ);

  CSSMatrix rotateAxisAngle(num x, num y, num z, num angle);

  CSSMatrix scale(num scaleX, num scaleY, num scaleZ);

  void setMatrixValue(String string);

  CSSMatrix skewX(num angle);

  CSSMatrix skewY(num angle);

  String toString();

  CSSMatrix translate(num x, num y, num z);
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

interface CSSMediaRule extends CSSRule {

  final CSSRuleList cssRules;

  final MediaList media;

  void deleteRule(int index);

  int insertRule(String rule, int index);
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

interface CSSPageRule extends CSSRule {

  String selectorText;

  final CSSStyleDeclaration style;
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

interface CSSPrimitiveValue extends CSSValue {

  static final int CSS_ATTR = 22;

  static final int CSS_CM = 6;

  static final int CSS_COUNTER = 23;

  static final int CSS_DEG = 11;

  static final int CSS_DIMENSION = 18;

  static final int CSS_EMS = 3;

  static final int CSS_EXS = 4;

  static final int CSS_GRAD = 13;

  static final int CSS_HZ = 16;

  static final int CSS_IDENT = 21;

  static final int CSS_IN = 8;

  static final int CSS_KHZ = 17;

  static final int CSS_MM = 7;

  static final int CSS_MS = 14;

  static final int CSS_NUMBER = 1;

  static final int CSS_PC = 10;

  static final int CSS_PERCENTAGE = 2;

  static final int CSS_PT = 9;

  static final int CSS_PX = 5;

  static final int CSS_RAD = 12;

  static final int CSS_RECT = 24;

  static final int CSS_RGBCOLOR = 25;

  static final int CSS_S = 15;

  static final int CSS_STRING = 19;

  static final int CSS_UNKNOWN = 0;

  static final int CSS_URI = 20;

  final int primitiveType;

  Counter getCounterValue();

  num getFloatValue(int unitType);

  RGBColor getRGBColorValue();

  Rect getRectValue();

  String getStringValue();

  void setFloatValue(int unitType, num floatValue);

  void setStringValue(int stringType, String stringValue);
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

interface CSSRule {

  static final int CHARSET_RULE = 2;

  static final int FONT_FACE_RULE = 5;

  static final int IMPORT_RULE = 3;

  static final int MEDIA_RULE = 4;

  static final int PAGE_RULE = 6;

  static final int STYLE_RULE = 1;

  static final int UNKNOWN_RULE = 0;

  static final int WEBKIT_KEYFRAMES_RULE = 7;

  static final int WEBKIT_KEYFRAME_RULE = 8;

  static final int WEBKIT_REGION_RULE = 10;

  String cssText;

  final CSSRule parentRule;

  final CSSStyleSheet parentStyleSheet;

  final int type;
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

interface CSSRuleList {

  final int length;

  CSSRule item(int index);
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

interface CSSStyleDeclaration default _CSSStyleDeclarationFactoryProvider {
  CSSStyleDeclaration();
  CSSStyleDeclaration.css(String css);


  String cssText;

  final int length;

  final CSSRule parentRule;

  CSSValue getPropertyCSSValue(String propertyName);

  String getPropertyPriority(String propertyName);

  String getPropertyShorthand(String propertyName);

  String getPropertyValue(String propertyName);

  bool isPropertyImplicit(String propertyName);

  String item(int index);

  String removeProperty(String propertyName);

  void setProperty(String propertyName, String value, [String priority]);


  /** Gets the value of "animation" */
  String get animation();

  /** Sets the value of "animation" */
  void set animation(var value);

  /** Gets the value of "animation-delay" */
  String get animationDelay();

  /** Sets the value of "animation-delay" */
  void set animationDelay(var value);

  /** Gets the value of "animation-direction" */
  String get animationDirection();

  /** Sets the value of "animation-direction" */
  void set animationDirection(var value);

  /** Gets the value of "animation-duration" */
  String get animationDuration();

  /** Sets the value of "animation-duration" */
  void set animationDuration(var value);

  /** Gets the value of "animation-fill-mode" */
  String get animationFillMode();

  /** Sets the value of "animation-fill-mode" */
  void set animationFillMode(var value);

  /** Gets the value of "animation-iteration-count" */
  String get animationIterationCount();

  /** Sets the value of "animation-iteration-count" */
  void set animationIterationCount(var value);

  /** Gets the value of "animation-name" */
  String get animationName();

  /** Sets the value of "animation-name" */
  void set animationName(var value);

  /** Gets the value of "animation-play-state" */
  String get animationPlayState();

  /** Sets the value of "animation-play-state" */
  void set animationPlayState(var value);

  /** Gets the value of "animation-timing-function" */
  String get animationTimingFunction();

  /** Sets the value of "animation-timing-function" */
  void set animationTimingFunction(var value);

  /** Gets the value of "appearance" */
  String get appearance();

  /** Sets the value of "appearance" */
  void set appearance(var value);

  /** Gets the value of "backface-visibility" */
  String get backfaceVisibility();

  /** Sets the value of "backface-visibility" */
  void set backfaceVisibility(var value);

  /** Gets the value of "background" */
  String get background();

  /** Sets the value of "background" */
  void set background(var value);

  /** Gets the value of "background-attachment" */
  String get backgroundAttachment();

  /** Sets the value of "background-attachment" */
  void set backgroundAttachment(var value);

  /** Gets the value of "background-clip" */
  String get backgroundClip();

  /** Sets the value of "background-clip" */
  void set backgroundClip(var value);

  /** Gets the value of "background-color" */
  String get backgroundColor();

  /** Sets the value of "background-color" */
  void set backgroundColor(var value);

  /** Gets the value of "background-composite" */
  String get backgroundComposite();

  /** Sets the value of "background-composite" */
  void set backgroundComposite(var value);

  /** Gets the value of "background-image" */
  String get backgroundImage();

  /** Sets the value of "background-image" */
  void set backgroundImage(var value);

  /** Gets the value of "background-origin" */
  String get backgroundOrigin();

  /** Sets the value of "background-origin" */
  void set backgroundOrigin(var value);

  /** Gets the value of "background-position" */
  String get backgroundPosition();

  /** Sets the value of "background-position" */
  void set backgroundPosition(var value);

  /** Gets the value of "background-position-x" */
  String get backgroundPositionX();

  /** Sets the value of "background-position-x" */
  void set backgroundPositionX(var value);

  /** Gets the value of "background-position-y" */
  String get backgroundPositionY();

  /** Sets the value of "background-position-y" */
  void set backgroundPositionY(var value);

  /** Gets the value of "background-repeat" */
  String get backgroundRepeat();

  /** Sets the value of "background-repeat" */
  void set backgroundRepeat(var value);

  /** Gets the value of "background-repeat-x" */
  String get backgroundRepeatX();

  /** Sets the value of "background-repeat-x" */
  void set backgroundRepeatX(var value);

  /** Gets the value of "background-repeat-y" */
  String get backgroundRepeatY();

  /** Sets the value of "background-repeat-y" */
  void set backgroundRepeatY(var value);

  /** Gets the value of "background-size" */
  String get backgroundSize();

  /** Sets the value of "background-size" */
  void set backgroundSize(var value);

  /** Gets the value of "border" */
  String get border();

  /** Sets the value of "border" */
  void set border(var value);

  /** Gets the value of "border-after" */
  String get borderAfter();

  /** Sets the value of "border-after" */
  void set borderAfter(var value);

  /** Gets the value of "border-after-color" */
  String get borderAfterColor();

  /** Sets the value of "border-after-color" */
  void set borderAfterColor(var value);

  /** Gets the value of "border-after-style" */
  String get borderAfterStyle();

  /** Sets the value of "border-after-style" */
  void set borderAfterStyle(var value);

  /** Gets the value of "border-after-width" */
  String get borderAfterWidth();

  /** Sets the value of "border-after-width" */
  void set borderAfterWidth(var value);

  /** Gets the value of "border-before" */
  String get borderBefore();

  /** Sets the value of "border-before" */
  void set borderBefore(var value);

  /** Gets the value of "border-before-color" */
  String get borderBeforeColor();

  /** Sets the value of "border-before-color" */
  void set borderBeforeColor(var value);

  /** Gets the value of "border-before-style" */
  String get borderBeforeStyle();

  /** Sets the value of "border-before-style" */
  void set borderBeforeStyle(var value);

  /** Gets the value of "border-before-width" */
  String get borderBeforeWidth();

  /** Sets the value of "border-before-width" */
  void set borderBeforeWidth(var value);

  /** Gets the value of "border-bottom" */
  String get borderBottom();

  /** Sets the value of "border-bottom" */
  void set borderBottom(var value);

  /** Gets the value of "border-bottom-color" */
  String get borderBottomColor();

  /** Sets the value of "border-bottom-color" */
  void set borderBottomColor(var value);

  /** Gets the value of "border-bottom-left-radius" */
  String get borderBottomLeftRadius();

  /** Sets the value of "border-bottom-left-radius" */
  void set borderBottomLeftRadius(var value);

  /** Gets the value of "border-bottom-right-radius" */
  String get borderBottomRightRadius();

  /** Sets the value of "border-bottom-right-radius" */
  void set borderBottomRightRadius(var value);

  /** Gets the value of "border-bottom-style" */
  String get borderBottomStyle();

  /** Sets the value of "border-bottom-style" */
  void set borderBottomStyle(var value);

  /** Gets the value of "border-bottom-width" */
  String get borderBottomWidth();

  /** Sets the value of "border-bottom-width" */
  void set borderBottomWidth(var value);

  /** Gets the value of "border-collapse" */
  String get borderCollapse();

  /** Sets the value of "border-collapse" */
  void set borderCollapse(var value);

  /** Gets the value of "border-color" */
  String get borderColor();

  /** Sets the value of "border-color" */
  void set borderColor(var value);

  /** Gets the value of "border-end" */
  String get borderEnd();

  /** Sets the value of "border-end" */
  void set borderEnd(var value);

  /** Gets the value of "border-end-color" */
  String get borderEndColor();

  /** Sets the value of "border-end-color" */
  void set borderEndColor(var value);

  /** Gets the value of "border-end-style" */
  String get borderEndStyle();

  /** Sets the value of "border-end-style" */
  void set borderEndStyle(var value);

  /** Gets the value of "border-end-width" */
  String get borderEndWidth();

  /** Sets the value of "border-end-width" */
  void set borderEndWidth(var value);

  /** Gets the value of "border-fit" */
  String get borderFit();

  /** Sets the value of "border-fit" */
  void set borderFit(var value);

  /** Gets the value of "border-horizontal-spacing" */
  String get borderHorizontalSpacing();

  /** Sets the value of "border-horizontal-spacing" */
  void set borderHorizontalSpacing(var value);

  /** Gets the value of "border-image" */
  String get borderImage();

  /** Sets the value of "border-image" */
  void set borderImage(var value);

  /** Gets the value of "border-image-outset" */
  String get borderImageOutset();

  /** Sets the value of "border-image-outset" */
  void set borderImageOutset(var value);

  /** Gets the value of "border-image-repeat" */
  String get borderImageRepeat();

  /** Sets the value of "border-image-repeat" */
  void set borderImageRepeat(var value);

  /** Gets the value of "border-image-slice" */
  String get borderImageSlice();

  /** Sets the value of "border-image-slice" */
  void set borderImageSlice(var value);

  /** Gets the value of "border-image-source" */
  String get borderImageSource();

  /** Sets the value of "border-image-source" */
  void set borderImageSource(var value);

  /** Gets the value of "border-image-width" */
  String get borderImageWidth();

  /** Sets the value of "border-image-width" */
  void set borderImageWidth(var value);

  /** Gets the value of "border-left" */
  String get borderLeft();

  /** Sets the value of "border-left" */
  void set borderLeft(var value);

  /** Gets the value of "border-left-color" */
  String get borderLeftColor();

  /** Sets the value of "border-left-color" */
  void set borderLeftColor(var value);

  /** Gets the value of "border-left-style" */
  String get borderLeftStyle();

  /** Sets the value of "border-left-style" */
  void set borderLeftStyle(var value);

  /** Gets the value of "border-left-width" */
  String get borderLeftWidth();

  /** Sets the value of "border-left-width" */
  void set borderLeftWidth(var value);

  /** Gets the value of "border-radius" */
  String get borderRadius();

  /** Sets the value of "border-radius" */
  void set borderRadius(var value);

  /** Gets the value of "border-right" */
  String get borderRight();

  /** Sets the value of "border-right" */
  void set borderRight(var value);

  /** Gets the value of "border-right-color" */
  String get borderRightColor();

  /** Sets the value of "border-right-color" */
  void set borderRightColor(var value);

  /** Gets the value of "border-right-style" */
  String get borderRightStyle();

  /** Sets the value of "border-right-style" */
  void set borderRightStyle(var value);

  /** Gets the value of "border-right-width" */
  String get borderRightWidth();

  /** Sets the value of "border-right-width" */
  void set borderRightWidth(var value);

  /** Gets the value of "border-spacing" */
  String get borderSpacing();

  /** Sets the value of "border-spacing" */
  void set borderSpacing(var value);

  /** Gets the value of "border-start" */
  String get borderStart();

  /** Sets the value of "border-start" */
  void set borderStart(var value);

  /** Gets the value of "border-start-color" */
  String get borderStartColor();

  /** Sets the value of "border-start-color" */
  void set borderStartColor(var value);

  /** Gets the value of "border-start-style" */
  String get borderStartStyle();

  /** Sets the value of "border-start-style" */
  void set borderStartStyle(var value);

  /** Gets the value of "border-start-width" */
  String get borderStartWidth();

  /** Sets the value of "border-start-width" */
  void set borderStartWidth(var value);

  /** Gets the value of "border-style" */
  String get borderStyle();

  /** Sets the value of "border-style" */
  void set borderStyle(var value);

  /** Gets the value of "border-top" */
  String get borderTop();

  /** Sets the value of "border-top" */
  void set borderTop(var value);

  /** Gets the value of "border-top-color" */
  String get borderTopColor();

  /** Sets the value of "border-top-color" */
  void set borderTopColor(var value);

  /** Gets the value of "border-top-left-radius" */
  String get borderTopLeftRadius();

  /** Sets the value of "border-top-left-radius" */
  void set borderTopLeftRadius(var value);

  /** Gets the value of "border-top-right-radius" */
  String get borderTopRightRadius();

  /** Sets the value of "border-top-right-radius" */
  void set borderTopRightRadius(var value);

  /** Gets the value of "border-top-style" */
  String get borderTopStyle();

  /** Sets the value of "border-top-style" */
  void set borderTopStyle(var value);

  /** Gets the value of "border-top-width" */
  String get borderTopWidth();

  /** Sets the value of "border-top-width" */
  void set borderTopWidth(var value);

  /** Gets the value of "border-vertical-spacing" */
  String get borderVerticalSpacing();

  /** Sets the value of "border-vertical-spacing" */
  void set borderVerticalSpacing(var value);

  /** Gets the value of "border-width" */
  String get borderWidth();

  /** Sets the value of "border-width" */
  void set borderWidth(var value);

  /** Gets the value of "bottom" */
  String get bottom();

  /** Sets the value of "bottom" */
  void set bottom(var value);

  /** Gets the value of "box-align" */
  String get boxAlign();

  /** Sets the value of "box-align" */
  void set boxAlign(var value);

  /** Gets the value of "box-direction" */
  String get boxDirection();

  /** Sets the value of "box-direction" */
  void set boxDirection(var value);

  /** Gets the value of "box-flex" */
  String get boxFlex();

  /** Sets the value of "box-flex" */
  void set boxFlex(var value);

  /** Gets the value of "box-flex-group" */
  String get boxFlexGroup();

  /** Sets the value of "box-flex-group" */
  void set boxFlexGroup(var value);

  /** Gets the value of "box-lines" */
  String get boxLines();

  /** Sets the value of "box-lines" */
  void set boxLines(var value);

  /** Gets the value of "box-ordinal-group" */
  String get boxOrdinalGroup();

  /** Sets the value of "box-ordinal-group" */
  void set boxOrdinalGroup(var value);

  /** Gets the value of "box-orient" */
  String get boxOrient();

  /** Sets the value of "box-orient" */
  void set boxOrient(var value);

  /** Gets the value of "box-pack" */
  String get boxPack();

  /** Sets the value of "box-pack" */
  void set boxPack(var value);

  /** Gets the value of "box-reflect" */
  String get boxReflect();

  /** Sets the value of "box-reflect" */
  void set boxReflect(var value);

  /** Gets the value of "box-shadow" */
  String get boxShadow();

  /** Sets the value of "box-shadow" */
  void set boxShadow(var value);

  /** Gets the value of "box-sizing" */
  String get boxSizing();

  /** Sets the value of "box-sizing" */
  void set boxSizing(var value);

  /** Gets the value of "caption-side" */
  String get captionSide();

  /** Sets the value of "caption-side" */
  void set captionSide(var value);

  /** Gets the value of "clear" */
  String get clear();

  /** Sets the value of "clear" */
  void set clear(var value);

  /** Gets the value of "clip" */
  String get clip();

  /** Sets the value of "clip" */
  void set clip(var value);

  /** Gets the value of "color" */
  String get color();

  /** Sets the value of "color" */
  void set color(var value);

  /** Gets the value of "color-correction" */
  String get colorCorrection();

  /** Sets the value of "color-correction" */
  void set colorCorrection(var value);

  /** Gets the value of "column-break-after" */
  String get columnBreakAfter();

  /** Sets the value of "column-break-after" */
  void set columnBreakAfter(var value);

  /** Gets the value of "column-break-before" */
  String get columnBreakBefore();

  /** Sets the value of "column-break-before" */
  void set columnBreakBefore(var value);

  /** Gets the value of "column-break-inside" */
  String get columnBreakInside();

  /** Sets the value of "column-break-inside" */
  void set columnBreakInside(var value);

  /** Gets the value of "column-count" */
  String get columnCount();

  /** Sets the value of "column-count" */
  void set columnCount(var value);

  /** Gets the value of "column-gap" */
  String get columnGap();

  /** Sets the value of "column-gap" */
  void set columnGap(var value);

  /** Gets the value of "column-rule" */
  String get columnRule();

  /** Sets the value of "column-rule" */
  void set columnRule(var value);

  /** Gets the value of "column-rule-color" */
  String get columnRuleColor();

  /** Sets the value of "column-rule-color" */
  void set columnRuleColor(var value);

  /** Gets the value of "column-rule-style" */
  String get columnRuleStyle();

  /** Sets the value of "column-rule-style" */
  void set columnRuleStyle(var value);

  /** Gets the value of "column-rule-width" */
  String get columnRuleWidth();

  /** Sets the value of "column-rule-width" */
  void set columnRuleWidth(var value);

  /** Gets the value of "column-span" */
  String get columnSpan();

  /** Sets the value of "column-span" */
  void set columnSpan(var value);

  /** Gets the value of "column-width" */
  String get columnWidth();

  /** Sets the value of "column-width" */
  void set columnWidth(var value);

  /** Gets the value of "columns" */
  String get columns();

  /** Sets the value of "columns" */
  void set columns(var value);

  /** Gets the value of "content" */
  String get content();

  /** Sets the value of "content" */
  void set content(var value);

  /** Gets the value of "counter-increment" */
  String get counterIncrement();

  /** Sets the value of "counter-increment" */
  void set counterIncrement(var value);

  /** Gets the value of "counter-reset" */
  String get counterReset();

  /** Sets the value of "counter-reset" */
  void set counterReset(var value);

  /** Gets the value of "cursor" */
  String get cursor();

  /** Sets the value of "cursor" */
  void set cursor(var value);

  /** Gets the value of "direction" */
  String get direction();

  /** Sets the value of "direction" */
  void set direction(var value);

  /** Gets the value of "display" */
  String get display();

  /** Sets the value of "display" */
  void set display(var value);

  /** Gets the value of "empty-cells" */
  String get emptyCells();

  /** Sets the value of "empty-cells" */
  void set emptyCells(var value);

  /** Gets the value of "filter" */
  String get filter();

  /** Sets the value of "filter" */
  void set filter(var value);

  /** Gets the value of "flex-align" */
  String get flexAlign();

  /** Sets the value of "flex-align" */
  void set flexAlign(var value);

  /** Gets the value of "flex-flow" */
  String get flexFlow();

  /** Sets the value of "flex-flow" */
  void set flexFlow(var value);

  /** Gets the value of "flex-order" */
  String get flexOrder();

  /** Sets the value of "flex-order" */
  void set flexOrder(var value);

  /** Gets the value of "flex-pack" */
  String get flexPack();

  /** Sets the value of "flex-pack" */
  void set flexPack(var value);

  /** Gets the value of "float" */
  String get float();

  /** Sets the value of "float" */
  void set float(var value);

  /** Gets the value of "flow-from" */
  String get flowFrom();

  /** Sets the value of "flow-from" */
  void set flowFrom(var value);

  /** Gets the value of "flow-into" */
  String get flowInto();

  /** Sets the value of "flow-into" */
  void set flowInto(var value);

  /** Gets the value of "font" */
  String get font();

  /** Sets the value of "font" */
  void set font(var value);

  /** Gets the value of "font-family" */
  String get fontFamily();

  /** Sets the value of "font-family" */
  void set fontFamily(var value);

  /** Gets the value of "font-feature-settings" */
  String get fontFeatureSettings();

  /** Sets the value of "font-feature-settings" */
  void set fontFeatureSettings(var value);

  /** Gets the value of "font-size" */
  String get fontSize();

  /** Sets the value of "font-size" */
  void set fontSize(var value);

  /** Gets the value of "font-size-delta" */
  String get fontSizeDelta();

  /** Sets the value of "font-size-delta" */
  void set fontSizeDelta(var value);

  /** Gets the value of "font-smoothing" */
  String get fontSmoothing();

  /** Sets the value of "font-smoothing" */
  void set fontSmoothing(var value);

  /** Gets the value of "font-stretch" */
  String get fontStretch();

  /** Sets the value of "font-stretch" */
  void set fontStretch(var value);

  /** Gets the value of "font-style" */
  String get fontStyle();

  /** Sets the value of "font-style" */
  void set fontStyle(var value);

  /** Gets the value of "font-variant" */
  String get fontVariant();

  /** Sets the value of "font-variant" */
  void set fontVariant(var value);

  /** Gets the value of "font-weight" */
  String get fontWeight();

  /** Sets the value of "font-weight" */
  void set fontWeight(var value);

  /** Gets the value of "height" */
  String get height();

  /** Sets the value of "height" */
  void set height(var value);

  /** Gets the value of "highlight" */
  String get highlight();

  /** Sets the value of "highlight" */
  void set highlight(var value);

  /** Gets the value of "hyphenate-character" */
  String get hyphenateCharacter();

  /** Sets the value of "hyphenate-character" */
  void set hyphenateCharacter(var value);

  /** Gets the value of "hyphenate-limit-after" */
  String get hyphenateLimitAfter();

  /** Sets the value of "hyphenate-limit-after" */
  void set hyphenateLimitAfter(var value);

  /** Gets the value of "hyphenate-limit-before" */
  String get hyphenateLimitBefore();

  /** Sets the value of "hyphenate-limit-before" */
  void set hyphenateLimitBefore(var value);

  /** Gets the value of "hyphenate-limit-lines" */
  String get hyphenateLimitLines();

  /** Sets the value of "hyphenate-limit-lines" */
  void set hyphenateLimitLines(var value);

  /** Gets the value of "hyphens" */
  String get hyphens();

  /** Sets the value of "hyphens" */
  void set hyphens(var value);

  /** Gets the value of "image-rendering" */
  String get imageRendering();

  /** Sets the value of "image-rendering" */
  void set imageRendering(var value);

  /** Gets the value of "left" */
  String get left();

  /** Sets the value of "left" */
  void set left(var value);

  /** Gets the value of "letter-spacing" */
  String get letterSpacing();

  /** Sets the value of "letter-spacing" */
  void set letterSpacing(var value);

  /** Gets the value of "line-box-contain" */
  String get lineBoxContain();

  /** Sets the value of "line-box-contain" */
  void set lineBoxContain(var value);

  /** Gets the value of "line-break" */
  String get lineBreak();

  /** Sets the value of "line-break" */
  void set lineBreak(var value);

  /** Gets the value of "line-clamp" */
  String get lineClamp();

  /** Sets the value of "line-clamp" */
  void set lineClamp(var value);

  /** Gets the value of "line-height" */
  String get lineHeight();

  /** Sets the value of "line-height" */
  void set lineHeight(var value);

  /** Gets the value of "list-style" */
  String get listStyle();

  /** Sets the value of "list-style" */
  void set listStyle(var value);

  /** Gets the value of "list-style-image" */
  String get listStyleImage();

  /** Sets the value of "list-style-image" */
  void set listStyleImage(var value);

  /** Gets the value of "list-style-position" */
  String get listStylePosition();

  /** Sets the value of "list-style-position" */
  void set listStylePosition(var value);

  /** Gets the value of "list-style-type" */
  String get listStyleType();

  /** Sets the value of "list-style-type" */
  void set listStyleType(var value);

  /** Gets the value of "locale" */
  String get locale();

  /** Sets the value of "locale" */
  void set locale(var value);

  /** Gets the value of "logical-height" */
  String get logicalHeight();

  /** Sets the value of "logical-height" */
  void set logicalHeight(var value);

  /** Gets the value of "logical-width" */
  String get logicalWidth();

  /** Sets the value of "logical-width" */
  void set logicalWidth(var value);

  /** Gets the value of "margin" */
  String get margin();

  /** Sets the value of "margin" */
  void set margin(var value);

  /** Gets the value of "margin-after" */
  String get marginAfter();

  /** Sets the value of "margin-after" */
  void set marginAfter(var value);

  /** Gets the value of "margin-after-collapse" */
  String get marginAfterCollapse();

  /** Sets the value of "margin-after-collapse" */
  void set marginAfterCollapse(var value);

  /** Gets the value of "margin-before" */
  String get marginBefore();

  /** Sets the value of "margin-before" */
  void set marginBefore(var value);

  /** Gets the value of "margin-before-collapse" */
  String get marginBeforeCollapse();

  /** Sets the value of "margin-before-collapse" */
  void set marginBeforeCollapse(var value);

  /** Gets the value of "margin-bottom" */
  String get marginBottom();

  /** Sets the value of "margin-bottom" */
  void set marginBottom(var value);

  /** Gets the value of "margin-bottom-collapse" */
  String get marginBottomCollapse();

  /** Sets the value of "margin-bottom-collapse" */
  void set marginBottomCollapse(var value);

  /** Gets the value of "margin-collapse" */
  String get marginCollapse();

  /** Sets the value of "margin-collapse" */
  void set marginCollapse(var value);

  /** Gets the value of "margin-end" */
  String get marginEnd();

  /** Sets the value of "margin-end" */
  void set marginEnd(var value);

  /** Gets the value of "margin-left" */
  String get marginLeft();

  /** Sets the value of "margin-left" */
  void set marginLeft(var value);

  /** Gets the value of "margin-right" */
  String get marginRight();

  /** Sets the value of "margin-right" */
  void set marginRight(var value);

  /** Gets the value of "margin-start" */
  String get marginStart();

  /** Sets the value of "margin-start" */
  void set marginStart(var value);

  /** Gets the value of "margin-top" */
  String get marginTop();

  /** Sets the value of "margin-top" */
  void set marginTop(var value);

  /** Gets the value of "margin-top-collapse" */
  String get marginTopCollapse();

  /** Sets the value of "margin-top-collapse" */
  void set marginTopCollapse(var value);

  /** Gets the value of "marquee" */
  String get marquee();

  /** Sets the value of "marquee" */
  void set marquee(var value);

  /** Gets the value of "marquee-direction" */
  String get marqueeDirection();

  /** Sets the value of "marquee-direction" */
  void set marqueeDirection(var value);

  /** Gets the value of "marquee-increment" */
  String get marqueeIncrement();

  /** Sets the value of "marquee-increment" */
  void set marqueeIncrement(var value);

  /** Gets the value of "marquee-repetition" */
  String get marqueeRepetition();

  /** Sets the value of "marquee-repetition" */
  void set marqueeRepetition(var value);

  /** Gets the value of "marquee-speed" */
  String get marqueeSpeed();

  /** Sets the value of "marquee-speed" */
  void set marqueeSpeed(var value);

  /** Gets the value of "marquee-style" */
  String get marqueeStyle();

  /** Sets the value of "marquee-style" */
  void set marqueeStyle(var value);

  /** Gets the value of "mask" */
  String get mask();

  /** Sets the value of "mask" */
  void set mask(var value);

  /** Gets the value of "mask-attachment" */
  String get maskAttachment();

  /** Sets the value of "mask-attachment" */
  void set maskAttachment(var value);

  /** Gets the value of "mask-box-image" */
  String get maskBoxImage();

  /** Sets the value of "mask-box-image" */
  void set maskBoxImage(var value);

  /** Gets the value of "mask-box-image-outset" */
  String get maskBoxImageOutset();

  /** Sets the value of "mask-box-image-outset" */
  void set maskBoxImageOutset(var value);

  /** Gets the value of "mask-box-image-repeat" */
  String get maskBoxImageRepeat();

  /** Sets the value of "mask-box-image-repeat" */
  void set maskBoxImageRepeat(var value);

  /** Gets the value of "mask-box-image-slice" */
  String get maskBoxImageSlice();

  /** Sets the value of "mask-box-image-slice" */
  void set maskBoxImageSlice(var value);

  /** Gets the value of "mask-box-image-source" */
  String get maskBoxImageSource();

  /** Sets the value of "mask-box-image-source" */
  void set maskBoxImageSource(var value);

  /** Gets the value of "mask-box-image-width" */
  String get maskBoxImageWidth();

  /** Sets the value of "mask-box-image-width" */
  void set maskBoxImageWidth(var value);

  /** Gets the value of "mask-clip" */
  String get maskClip();

  /** Sets the value of "mask-clip" */
  void set maskClip(var value);

  /** Gets the value of "mask-composite" */
  String get maskComposite();

  /** Sets the value of "mask-composite" */
  void set maskComposite(var value);

  /** Gets the value of "mask-image" */
  String get maskImage();

  /** Sets the value of "mask-image" */
  void set maskImage(var value);

  /** Gets the value of "mask-origin" */
  String get maskOrigin();

  /** Sets the value of "mask-origin" */
  void set maskOrigin(var value);

  /** Gets the value of "mask-position" */
  String get maskPosition();

  /** Sets the value of "mask-position" */
  void set maskPosition(var value);

  /** Gets the value of "mask-position-x" */
  String get maskPositionX();

  /** Sets the value of "mask-position-x" */
  void set maskPositionX(var value);

  /** Gets the value of "mask-position-y" */
  String get maskPositionY();

  /** Sets the value of "mask-position-y" */
  void set maskPositionY(var value);

  /** Gets the value of "mask-repeat" */
  String get maskRepeat();

  /** Sets the value of "mask-repeat" */
  void set maskRepeat(var value);

  /** Gets the value of "mask-repeat-x" */
  String get maskRepeatX();

  /** Sets the value of "mask-repeat-x" */
  void set maskRepeatX(var value);

  /** Gets the value of "mask-repeat-y" */
  String get maskRepeatY();

  /** Sets the value of "mask-repeat-y" */
  void set maskRepeatY(var value);

  /** Gets the value of "mask-size" */
  String get maskSize();

  /** Sets the value of "mask-size" */
  void set maskSize(var value);

  /** Gets the value of "match-nearest-mail-blockquote-color" */
  String get matchNearestMailBlockquoteColor();

  /** Sets the value of "match-nearest-mail-blockquote-color" */
  void set matchNearestMailBlockquoteColor(var value);

  /** Gets the value of "max-height" */
  String get maxHeight();

  /** Sets the value of "max-height" */
  void set maxHeight(var value);

  /** Gets the value of "max-logical-height" */
  String get maxLogicalHeight();

  /** Sets the value of "max-logical-height" */
  void set maxLogicalHeight(var value);

  /** Gets the value of "max-logical-width" */
  String get maxLogicalWidth();

  /** Sets the value of "max-logical-width" */
  void set maxLogicalWidth(var value);

  /** Gets the value of "max-width" */
  String get maxWidth();

  /** Sets the value of "max-width" */
  void set maxWidth(var value);

  /** Gets the value of "min-height" */
  String get minHeight();

  /** Sets the value of "min-height" */
  void set minHeight(var value);

  /** Gets the value of "min-logical-height" */
  String get minLogicalHeight();

  /** Sets the value of "min-logical-height" */
  void set minLogicalHeight(var value);

  /** Gets the value of "min-logical-width" */
  String get minLogicalWidth();

  /** Sets the value of "min-logical-width" */
  void set minLogicalWidth(var value);

  /** Gets the value of "min-width" */
  String get minWidth();

  /** Sets the value of "min-width" */
  void set minWidth(var value);

  /** Gets the value of "nbsp-mode" */
  String get nbspMode();

  /** Sets the value of "nbsp-mode" */
  void set nbspMode(var value);

  /** Gets the value of "opacity" */
  String get opacity();

  /** Sets the value of "opacity" */
  void set opacity(var value);

  /** Gets the value of "orphans" */
  String get orphans();

  /** Sets the value of "orphans" */
  void set orphans(var value);

  /** Gets the value of "outline" */
  String get outline();

  /** Sets the value of "outline" */
  void set outline(var value);

  /** Gets the value of "outline-color" */
  String get outlineColor();

  /** Sets the value of "outline-color" */
  void set outlineColor(var value);

  /** Gets the value of "outline-offset" */
  String get outlineOffset();

  /** Sets the value of "outline-offset" */
  void set outlineOffset(var value);

  /** Gets the value of "outline-style" */
  String get outlineStyle();

  /** Sets the value of "outline-style" */
  void set outlineStyle(var value);

  /** Gets the value of "outline-width" */
  String get outlineWidth();

  /** Sets the value of "outline-width" */
  void set outlineWidth(var value);

  /** Gets the value of "overflow" */
  String get overflow();

  /** Sets the value of "overflow" */
  void set overflow(var value);

  /** Gets the value of "overflow-x" */
  String get overflowX();

  /** Sets the value of "overflow-x" */
  void set overflowX(var value);

  /** Gets the value of "overflow-y" */
  String get overflowY();

  /** Sets the value of "overflow-y" */
  void set overflowY(var value);

  /** Gets the value of "padding" */
  String get padding();

  /** Sets the value of "padding" */
  void set padding(var value);

  /** Gets the value of "padding-after" */
  String get paddingAfter();

  /** Sets the value of "padding-after" */
  void set paddingAfter(var value);

  /** Gets the value of "padding-before" */
  String get paddingBefore();

  /** Sets the value of "padding-before" */
  void set paddingBefore(var value);

  /** Gets the value of "padding-bottom" */
  String get paddingBottom();

  /** Sets the value of "padding-bottom" */
  void set paddingBottom(var value);

  /** Gets the value of "padding-end" */
  String get paddingEnd();

  /** Sets the value of "padding-end" */
  void set paddingEnd(var value);

  /** Gets the value of "padding-left" */
  String get paddingLeft();

  /** Sets the value of "padding-left" */
  void set paddingLeft(var value);

  /** Gets the value of "padding-right" */
  String get paddingRight();

  /** Sets the value of "padding-right" */
  void set paddingRight(var value);

  /** Gets the value of "padding-start" */
  String get paddingStart();

  /** Sets the value of "padding-start" */
  void set paddingStart(var value);

  /** Gets the value of "padding-top" */
  String get paddingTop();

  /** Sets the value of "padding-top" */
  void set paddingTop(var value);

  /** Gets the value of "page" */
  String get page();

  /** Sets the value of "page" */
  void set page(var value);

  /** Gets the value of "page-break-after" */
  String get pageBreakAfter();

  /** Sets the value of "page-break-after" */
  void set pageBreakAfter(var value);

  /** Gets the value of "page-break-before" */
  String get pageBreakBefore();

  /** Sets the value of "page-break-before" */
  void set pageBreakBefore(var value);

  /** Gets the value of "page-break-inside" */
  String get pageBreakInside();

  /** Sets the value of "page-break-inside" */
  void set pageBreakInside(var value);

  /** Gets the value of "perspective" */
  String get perspective();

  /** Sets the value of "perspective" */
  void set perspective(var value);

  /** Gets the value of "perspective-origin" */
  String get perspectiveOrigin();

  /** Sets the value of "perspective-origin" */
  void set perspectiveOrigin(var value);

  /** Gets the value of "perspective-origin-x" */
  String get perspectiveOriginX();

  /** Sets the value of "perspective-origin-x" */
  void set perspectiveOriginX(var value);

  /** Gets the value of "perspective-origin-y" */
  String get perspectiveOriginY();

  /** Sets the value of "perspective-origin-y" */
  void set perspectiveOriginY(var value);

  /** Gets the value of "pointer-events" */
  String get pointerEvents();

  /** Sets the value of "pointer-events" */
  void set pointerEvents(var value);

  /** Gets the value of "position" */
  String get position();

  /** Sets the value of "position" */
  void set position(var value);

  /** Gets the value of "quotes" */
  String get quotes();

  /** Sets the value of "quotes" */
  void set quotes(var value);

  /** Gets the value of "region-break-after" */
  String get regionBreakAfter();

  /** Sets the value of "region-break-after" */
  void set regionBreakAfter(var value);

  /** Gets the value of "region-break-before" */
  String get regionBreakBefore();

  /** Sets the value of "region-break-before" */
  void set regionBreakBefore(var value);

  /** Gets the value of "region-break-inside" */
  String get regionBreakInside();

  /** Sets the value of "region-break-inside" */
  void set regionBreakInside(var value);

  /** Gets the value of "region-overflow" */
  String get regionOverflow();

  /** Sets the value of "region-overflow" */
  void set regionOverflow(var value);

  /** Gets the value of "resize" */
  String get resize();

  /** Sets the value of "resize" */
  void set resize(var value);

  /** Gets the value of "right" */
  String get right();

  /** Sets the value of "right" */
  void set right(var value);

  /** Gets the value of "rtl-ordering" */
  String get rtlOrdering();

  /** Sets the value of "rtl-ordering" */
  void set rtlOrdering(var value);

  /** Gets the value of "size" */
  String get size();

  /** Sets the value of "size" */
  void set size(var value);

  /** Gets the value of "speak" */
  String get speak();

  /** Sets the value of "speak" */
  void set speak(var value);

  /** Gets the value of "src" */
  String get src();

  /** Sets the value of "src" */
  void set src(var value);

  /** Gets the value of "table-layout" */
  String get tableLayout();

  /** Sets the value of "table-layout" */
  void set tableLayout(var value);

  /** Gets the value of "tap-highlight-color" */
  String get tapHighlightColor();

  /** Sets the value of "tap-highlight-color" */
  void set tapHighlightColor(var value);

  /** Gets the value of "text-align" */
  String get textAlign();

  /** Sets the value of "text-align" */
  void set textAlign(var value);

  /** Gets the value of "text-combine" */
  String get textCombine();

  /** Sets the value of "text-combine" */
  void set textCombine(var value);

  /** Gets the value of "text-decoration" */
  String get textDecoration();

  /** Sets the value of "text-decoration" */
  void set textDecoration(var value);

  /** Gets the value of "text-decorations-in-effect" */
  String get textDecorationsInEffect();

  /** Sets the value of "text-decorations-in-effect" */
  void set textDecorationsInEffect(var value);

  /** Gets the value of "text-emphasis" */
  String get textEmphasis();

  /** Sets the value of "text-emphasis" */
  void set textEmphasis(var value);

  /** Gets the value of "text-emphasis-color" */
  String get textEmphasisColor();

  /** Sets the value of "text-emphasis-color" */
  void set textEmphasisColor(var value);

  /** Gets the value of "text-emphasis-position" */
  String get textEmphasisPosition();

  /** Sets the value of "text-emphasis-position" */
  void set textEmphasisPosition(var value);

  /** Gets the value of "text-emphasis-style" */
  String get textEmphasisStyle();

  /** Sets the value of "text-emphasis-style" */
  void set textEmphasisStyle(var value);

  /** Gets the value of "text-fill-color" */
  String get textFillColor();

  /** Sets the value of "text-fill-color" */
  void set textFillColor(var value);

  /** Gets the value of "text-indent" */
  String get textIndent();

  /** Sets the value of "text-indent" */
  void set textIndent(var value);

  /** Gets the value of "text-line-through" */
  String get textLineThrough();

  /** Sets the value of "text-line-through" */
  void set textLineThrough(var value);

  /** Gets the value of "text-line-through-color" */
  String get textLineThroughColor();

  /** Sets the value of "text-line-through-color" */
  void set textLineThroughColor(var value);

  /** Gets the value of "text-line-through-mode" */
  String get textLineThroughMode();

  /** Sets the value of "text-line-through-mode" */
  void set textLineThroughMode(var value);

  /** Gets the value of "text-line-through-style" */
  String get textLineThroughStyle();

  /** Sets the value of "text-line-through-style" */
  void set textLineThroughStyle(var value);

  /** Gets the value of "text-line-through-width" */
  String get textLineThroughWidth();

  /** Sets the value of "text-line-through-width" */
  void set textLineThroughWidth(var value);

  /** Gets the value of "text-orientation" */
  String get textOrientation();

  /** Sets the value of "text-orientation" */
  void set textOrientation(var value);

  /** Gets the value of "text-overflow" */
  String get textOverflow();

  /** Sets the value of "text-overflow" */
  void set textOverflow(var value);

  /** Gets the value of "text-overline" */
  String get textOverline();

  /** Sets the value of "text-overline" */
  void set textOverline(var value);

  /** Gets the value of "text-overline-color" */
  String get textOverlineColor();

  /** Sets the value of "text-overline-color" */
  void set textOverlineColor(var value);

  /** Gets the value of "text-overline-mode" */
  String get textOverlineMode();

  /** Sets the value of "text-overline-mode" */
  void set textOverlineMode(var value);

  /** Gets the value of "text-overline-style" */
  String get textOverlineStyle();

  /** Sets the value of "text-overline-style" */
  void set textOverlineStyle(var value);

  /** Gets the value of "text-overline-width" */
  String get textOverlineWidth();

  /** Sets the value of "text-overline-width" */
  void set textOverlineWidth(var value);

  /** Gets the value of "text-rendering" */
  String get textRendering();

  /** Sets the value of "text-rendering" */
  void set textRendering(var value);

  /** Gets the value of "text-security" */
  String get textSecurity();

  /** Sets the value of "text-security" */
  void set textSecurity(var value);

  /** Gets the value of "text-shadow" */
  String get textShadow();

  /** Sets the value of "text-shadow" */
  void set textShadow(var value);

  /** Gets the value of "text-size-adjust" */
  String get textSizeAdjust();

  /** Sets the value of "text-size-adjust" */
  void set textSizeAdjust(var value);

  /** Gets the value of "text-stroke" */
  String get textStroke();

  /** Sets the value of "text-stroke" */
  void set textStroke(var value);

  /** Gets the value of "text-stroke-color" */
  String get textStrokeColor();

  /** Sets the value of "text-stroke-color" */
  void set textStrokeColor(var value);

  /** Gets the value of "text-stroke-width" */
  String get textStrokeWidth();

  /** Sets the value of "text-stroke-width" */
  void set textStrokeWidth(var value);

  /** Gets the value of "text-transform" */
  String get textTransform();

  /** Sets the value of "text-transform" */
  void set textTransform(var value);

  /** Gets the value of "text-underline" */
  String get textUnderline();

  /** Sets the value of "text-underline" */
  void set textUnderline(var value);

  /** Gets the value of "text-underline-color" */
  String get textUnderlineColor();

  /** Sets the value of "text-underline-color" */
  void set textUnderlineColor(var value);

  /** Gets the value of "text-underline-mode" */
  String get textUnderlineMode();

  /** Sets the value of "text-underline-mode" */
  void set textUnderlineMode(var value);

  /** Gets the value of "text-underline-style" */
  String get textUnderlineStyle();

  /** Sets the value of "text-underline-style" */
  void set textUnderlineStyle(var value);

  /** Gets the value of "text-underline-width" */
  String get textUnderlineWidth();

  /** Sets the value of "text-underline-width" */
  void set textUnderlineWidth(var value);

  /** Gets the value of "top" */
  String get top();

  /** Sets the value of "top" */
  void set top(var value);

  /** Gets the value of "transform" */
  String get transform();

  /** Sets the value of "transform" */
  void set transform(var value);

  /** Gets the value of "transform-origin" */
  String get transformOrigin();

  /** Sets the value of "transform-origin" */
  void set transformOrigin(var value);

  /** Gets the value of "transform-origin-x" */
  String get transformOriginX();

  /** Sets the value of "transform-origin-x" */
  void set transformOriginX(var value);

  /** Gets the value of "transform-origin-y" */
  String get transformOriginY();

  /** Sets the value of "transform-origin-y" */
  void set transformOriginY(var value);

  /** Gets the value of "transform-origin-z" */
  String get transformOriginZ();

  /** Sets the value of "transform-origin-z" */
  void set transformOriginZ(var value);

  /** Gets the value of "transform-style" */
  String get transformStyle();

  /** Sets the value of "transform-style" */
  void set transformStyle(var value);

  /** Gets the value of "transition" */
  String get transition();

  /** Sets the value of "transition" */
  void set transition(var value);

  /** Gets the value of "transition-delay" */
  String get transitionDelay();

  /** Sets the value of "transition-delay" */
  void set transitionDelay(var value);

  /** Gets the value of "transition-duration" */
  String get transitionDuration();

  /** Sets the value of "transition-duration" */
  void set transitionDuration(var value);

  /** Gets the value of "transition-property" */
  String get transitionProperty();

  /** Sets the value of "transition-property" */
  void set transitionProperty(var value);

  /** Gets the value of "transition-timing-function" */
  String get transitionTimingFunction();

  /** Sets the value of "transition-timing-function" */
  void set transitionTimingFunction(var value);

  /** Gets the value of "unicode-bidi" */
  String get unicodeBidi();

  /** Sets the value of "unicode-bidi" */
  void set unicodeBidi(var value);

  /** Gets the value of "unicode-range" */
  String get unicodeRange();

  /** Sets the value of "unicode-range" */
  void set unicodeRange(var value);

  /** Gets the value of "user-drag" */
  String get userDrag();

  /** Sets the value of "user-drag" */
  void set userDrag(var value);

  /** Gets the value of "user-modify" */
  String get userModify();

  /** Sets the value of "user-modify" */
  void set userModify(var value);

  /** Gets the value of "user-select" */
  String get userSelect();

  /** Sets the value of "user-select" */
  void set userSelect(var value);

  /** Gets the value of "vertical-align" */
  String get verticalAlign();

  /** Sets the value of "vertical-align" */
  void set verticalAlign(var value);

  /** Gets the value of "visibility" */
  String get visibility();

  /** Sets the value of "visibility" */
  void set visibility(var value);

  /** Gets the value of "white-space" */
  String get whiteSpace();

  /** Sets the value of "white-space" */
  void set whiteSpace(var value);

  /** Gets the value of "widows" */
  String get widows();

  /** Sets the value of "widows" */
  void set widows(var value);

  /** Gets the value of "width" */
  String get width();

  /** Sets the value of "width" */
  void set width(var value);

  /** Gets the value of "word-break" */
  String get wordBreak();

  /** Sets the value of "word-break" */
  void set wordBreak(var value);

  /** Gets the value of "word-spacing" */
  String get wordSpacing();

  /** Sets the value of "word-spacing" */
  void set wordSpacing(var value);

  /** Gets the value of "word-wrap" */
  String get wordWrap();

  /** Sets the value of "word-wrap" */
  void set wordWrap(var value);

  /** Gets the value of "wrap-shape" */
  String get wrapShape();

  /** Sets the value of "wrap-shape" */
  void set wrapShape(var value);

  /** Gets the value of "writing-mode" */
  String get writingMode();

  /** Sets the value of "writing-mode" */
  void set writingMode(var value);

  /** Gets the value of "z-index" */
  String get zIndex();

  /** Sets the value of "z-index" */
  void set zIndex(var value);

  /** Gets the value of "zoom" */
  String get zoom();

  /** Sets the value of "zoom" */
  void set zoom(var value);
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

interface CSSStyleRule extends CSSRule {

  String selectorText;

  final CSSStyleDeclaration style;
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

interface CSSStyleSheet extends StyleSheet {

  final CSSRuleList cssRules;

  final CSSRule ownerRule;

  final CSSRuleList rules;

  int addRule(String selector, String style, [int index]);

  void deleteRule(int index);

  int insertRule(String rule, int index);

  void removeRule(int index);
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

interface CSSTransformValue extends CSSValueList {

  static final int CSS_MATRIX = 11;

  static final int CSS_MATRIX3D = 21;

  static final int CSS_PERSPECTIVE = 20;

  static final int CSS_ROTATE = 4;

  static final int CSS_ROTATE3D = 17;

  static final int CSS_ROTATEX = 14;

  static final int CSS_ROTATEY = 15;

  static final int CSS_ROTATEZ = 16;

  static final int CSS_SCALE = 5;

  static final int CSS_SCALE3D = 19;

  static final int CSS_SCALEX = 6;

  static final int CSS_SCALEY = 7;

  static final int CSS_SCALEZ = 18;

  static final int CSS_SKEW = 8;

  static final int CSS_SKEWX = 9;

  static final int CSS_SKEWY = 10;

  static final int CSS_TRANSLATE = 1;

  static final int CSS_TRANSLATE3D = 13;

  static final int CSS_TRANSLATEX = 2;

  static final int CSS_TRANSLATEY = 3;

  static final int CSS_TRANSLATEZ = 12;

  final int operationType;
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

interface CSSUnknownRule extends CSSRule {
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

interface CSSValue {

  static final int CSS_CUSTOM = 3;

  static final int CSS_INHERIT = 0;

  static final int CSS_PRIMITIVE_VALUE = 1;

  static final int CSS_VALUE_LIST = 2;

  String cssText;

  final int cssValueType;
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

interface CSSValueList extends CSSValue {

  final int length;

  CSSValue item(int index);
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

interface CanvasElement extends Element {

  int height;

  int width;

  Object getContext(String contextId);

  String toDataURL(String type);
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

interface CanvasGradient {

  void addColorStop(num offset, String color);
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

interface CanvasPattern {
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

interface CanvasPixelArray extends List<int> {

  final int length;
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

interface CanvasRenderingContext {

  final CanvasElement canvas;
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

interface CanvasRenderingContext2D extends CanvasRenderingContext {

  Dynamic fillStyle;

  String font;

  num globalAlpha;

  String globalCompositeOperation;

  String lineCap;

  String lineJoin;

  num lineWidth;

  num miterLimit;

  num shadowBlur;

  String shadowColor;

  num shadowOffsetX;

  num shadowOffsetY;

  Dynamic strokeStyle;

  String textAlign;

  String textBaseline;

  List webkitLineDash;

  num webkitLineDashOffset;

  void arc(num x, num y, num radius, num startAngle, num endAngle, bool anticlockwise);

  void arcTo(num x1, num y1, num x2, num y2, num radius);

  void beginPath();

  void bezierCurveTo(num cp1x, num cp1y, num cp2x, num cp2y, num x, num y);

  void clearRect(num x, num y, num width, num height);

  void clearShadow();

  void clip();

  void closePath();

  ImageData createImageData(var imagedata_OR_sw, [num sh]);

  CanvasGradient createLinearGradient(num x0, num y0, num x1, num y1);

  CanvasPattern createPattern(var canvas_OR_image, String repetitionType);

  CanvasGradient createRadialGradient(num x0, num y0, num r0, num x1, num y1, num r1);

  void drawImage(var canvas_OR_image_OR_video, num sx_OR_x, num sy_OR_y, [num sw_OR_width, num height_OR_sh, num dx, num dy, num dw, num dh]);

  void drawImageFromRect(ImageElement image, [num sx, num sy, num sw, num sh, num dx, num dy, num dw, num dh, String compositeOperation]);

  void fill();

  void fillRect(num x, num y, num width, num height);

  void fillText(String text, num x, num y, [num maxWidth]);

  ImageData getImageData(num sx, num sy, num sw, num sh);

  bool isPointInPath(num x, num y);

  void lineTo(num x, num y);

  TextMetrics measureText(String text);

  void moveTo(num x, num y);

  void putImageData(ImageData imagedata, num dx, num dy, [num dirtyX, num dirtyY, num dirtyWidth, num dirtyHeight]);

  void quadraticCurveTo(num cpx, num cpy, num x, num y);

  void rect(num x, num y, num width, num height);

  void restore();

  void rotate(num angle);

  void save();

  void scale(num sx, num sy);

  void setAlpha(num alpha);

  void setCompositeOperation(String compositeOperation);

  void setFillColor(var c_OR_color_OR_grayLevel_OR_r, [num alpha_OR_g_OR_m, num b_OR_y, num a_OR_k, num a]);

  void setLineCap(String cap);

  void setLineJoin(String join);

  void setLineWidth(num width);

  void setMiterLimit(num limit);

  void setShadow(num width, num height, num blur, [var c_OR_color_OR_grayLevel_OR_r, num alpha_OR_g_OR_m, num b_OR_y, num a_OR_k, num a]);

  void setStrokeColor(var c_OR_color_OR_grayLevel_OR_r, [num alpha_OR_g_OR_m, num b_OR_y, num a_OR_k, num a]);

  void setTransform(num m11, num m12, num m21, num m22, num dx, num dy);

  void stroke();

  void strokeRect(num x, num y, num width, num height, [num lineWidth]);

  void strokeText(String text, num x, num y, [num maxWidth]);

  void transform(num m11, num m12, num m21, num m22, num dx, num dy);

  void translate(num tx, num ty);
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

interface CharacterData extends Node {

  String data;

  final int length;

  void appendData(String data);

  void deleteData(int offset, int length);

  void insertData(int offset, String data);

  void replaceData(int offset, int length, String data);

  String substringData(int offset, int length);
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

interface ClientRect {

  final num bottom;

  final num height;

  final num left;

  final num right;

  final num top;

  final num width;
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

interface ClientRectList {

  final int length;

  ClientRect item(int index);
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

interface Clipboard {

  String dropEffect;

  String effectAllowed;

  final FileList files;

  final DataTransferItemList items;

  final List types;

  void clearData([String type]);

  String getData(String type);

  bool setData(String type, String data);

  void setDragImage(ImageElement image, int x, int y);
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

interface CloseEvent extends Event {

  final int code;

  final String reason;

  final bool wasClean;
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

interface Comment extends CharacterData {
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

interface CompositionEvent extends UIEvent {

  final String data;

  void initCompositionEvent(String typeArg, bool canBubbleArg, bool cancelableArg, Window viewArg, String dataArg);
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

interface Console {

  final MemoryInfo memory;

  void assertCondition(bool condition, Object arg);

  void count();

  void debug(Object arg);

  void dir();

  void dirxml();

  void error(Object arg);

  void group(Object arg);

  void groupCollapsed(Object arg);

  void groupEnd();

  void info(Object arg);

  void log(Object arg);

  void markTimeline();

  void profile(String title);

  void profileEnd(String title);

  void time(String title);

  void timeEnd(String title, Object arg);

  void timeStamp(Object arg);

  void trace(Object arg);

  void warn(Object arg);
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

interface ContentElement extends Element {

  String select;
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

interface ConvolverNode extends AudioNode {

  AudioBuffer buffer;

  bool normalize;
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

interface Coordinates {

  final num accuracy;

  final num altitude;

  final num altitudeAccuracy;

  final num heading;

  final num latitude;

  final num longitude;

  final num speed;
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

interface Counter {

  final String identifier;

  final String listStyle;

  final String separator;
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

interface Crypto {

  void getRandomValues(ArrayBufferView array);
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

interface CustomEvent extends Event {

  final Object detail;

  void initCustomEvent(String typeArg, bool canBubbleArg, bool cancelableArg, Object detailArg);
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

interface DListElement extends Element {

  bool compact;
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

interface DOMApplicationCache extends EventTarget {

  DOMApplicationCacheEvents get on();

  static final int CHECKING = 2;

  static final int DOWNLOADING = 3;

  static final int IDLE = 1;

  static final int OBSOLETE = 5;

  static final int UNCACHED = 0;

  static final int UPDATEREADY = 4;

  final int status;

  void abort();

  void swapCache();

  void update();
}

interface DOMApplicationCacheEvents extends Events {

  EventListenerList get cached();

  EventListenerList get checking();

  EventListenerList get downloading();

  EventListenerList get error();

  EventListenerList get noUpdate();

  EventListenerList get obsolete();

  EventListenerList get progress();

  EventListenerList get updateReady();
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

interface DOMException {

  static final int ABORT_ERR = 20;

  static final int DATA_CLONE_ERR = 25;

  static final int DOMSTRING_SIZE_ERR = 2;

  static final int HIERARCHY_REQUEST_ERR = 3;

  static final int INDEX_SIZE_ERR = 1;

  static final int INUSE_ATTRIBUTE_ERR = 10;

  static final int INVALID_ACCESS_ERR = 15;

  static final int INVALID_CHARACTER_ERR = 5;

  static final int INVALID_MODIFICATION_ERR = 13;

  static final int INVALID_NODE_TYPE_ERR = 24;

  static final int INVALID_STATE_ERR = 11;

  static final int NAMESPACE_ERR = 14;

  static final int NETWORK_ERR = 19;

  static final int NOT_FOUND_ERR = 8;

  static final int NOT_SUPPORTED_ERR = 9;

  static final int NO_DATA_ALLOWED_ERR = 6;

  static final int NO_MODIFICATION_ALLOWED_ERR = 7;

  static final int QUOTA_EXCEEDED_ERR = 22;

  static final int SECURITY_ERR = 18;

  static final int SYNTAX_ERR = 12;

  static final int TIMEOUT_ERR = 23;

  static final int TYPE_MISMATCH_ERR = 17;

  static final int URL_MISMATCH_ERR = 21;

  static final int VALIDATION_ERR = 16;

  static final int WRONG_DOCUMENT_ERR = 4;

  final int code;

  final String message;

  final String name;

  String toString();
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

interface DOMFileSystem {

  final String name;

  final DirectoryEntry root;
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

interface DOMFileSystemSync {

  final String name;

  final DirectoryEntrySync root;
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

interface DOMFormData {

  void append(String name, String value, String filename);
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

interface DOMImplementation {

  CSSStyleSheet createCSSStyleSheet(String title, String media);

  Document createDocument(String namespaceURI, String qualifiedName, DocumentType doctype);

  DocumentType createDocumentType(String qualifiedName, String publicId, String systemId);

  Document createHTMLDocument(String title);

  bool hasFeature(String feature, String version);
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

interface DOMMimeType {

  final String description;

  final DOMPlugin enabledPlugin;

  final String suffixes;

  final String type;
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

interface DOMMimeTypeArray {

  final int length;

  DOMMimeType item(int index);

  DOMMimeType namedItem(String name);
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

interface DOMParser default _DOMParserFactoryProvider {

  DOMParser();

  Document parseFromString(String str, String contentType);
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

interface DOMPlugin {

  final String description;

  final String filename;

  final int length;

  final String name;

  DOMMimeType item(int index);

  DOMMimeType namedItem(String name);
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

interface DOMPluginArray {

  final int length;

  DOMPlugin item(int index);

  DOMPlugin namedItem(String name);

  void refresh(bool reload);
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

interface DOMSelection {

  final Node anchorNode;

  final int anchorOffset;

  final Node baseNode;

  final int baseOffset;

  final Node extentNode;

  final int extentOffset;

  final Node focusNode;

  final int focusOffset;

  final bool isCollapsed;

  final int rangeCount;

  final String type;

  void addRange(Range range);

  void collapse(Node node, int index);

  void collapseToEnd();

  void collapseToStart();

  bool containsNode(Node node, bool allowPartial);

  void deleteFromDocument();

  void empty();

  void extend(Node node, int offset);

  Range getRangeAt(int index);

  void modify(String alter, String direction, String granularity);

  void removeAllRanges();

  void selectAllChildren(Node node);

  void setBaseAndExtent(Node baseNode, int baseOffset, Node extentNode, int extentOffset);

  void setPosition(Node node, int offset);

  String toString();
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

interface DOMSettableTokenList extends DOMTokenList {

  String value;
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

interface DOMTokenList {

  final int length;

  void add(String token);

  bool contains(String token);

  String item(int index);

  void remove(String token);

  String toString();

  bool toggle(String token);
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

interface DOMURL default _DOMURLFactoryProvider {

  DOMURL();

  String createObjectURL(var blob_OR_stream);

  void revokeObjectURL(String url);
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

interface DataTransferItem {

  final String kind;

  final String type;

  Blob getAsFile();

  void getAsString([StringCallback callback]);
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

interface DataTransferItemList {

  final int length;

  void add(var data_OR_file, [String type]);

  void clear();

  DataTransferItem item(int index);
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

interface DataView extends ArrayBufferView {

  num getFloat32(int byteOffset, [bool littleEndian]);

  num getFloat64(int byteOffset, [bool littleEndian]);

  int getInt16(int byteOffset, [bool littleEndian]);

  int getInt32(int byteOffset, [bool littleEndian]);

  Object getInt8();

  int getUint16(int byteOffset, [bool littleEndian]);

  int getUint32(int byteOffset, [bool littleEndian]);

  Object getUint8();

  void setFloat32(int byteOffset, num value, [bool littleEndian]);

  void setFloat64(int byteOffset, num value, [bool littleEndian]);

  void setInt16(int byteOffset, int value, [bool littleEndian]);

  void setInt32(int byteOffset, int value, [bool littleEndian]);

  void setInt8();

  void setUint16(int byteOffset, int value, [bool littleEndian]);

  void setUint32(int byteOffset, int value, [bool littleEndian]);

  void setUint8();
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

interface Database {

  final String version;

  void changeVersion(String oldVersion, String newVersion, [SQLTransactionCallback callback, SQLTransactionErrorCallback errorCallback, VoidCallback successCallback]);

  void readTransaction(SQLTransactionCallback callback, [SQLTransactionErrorCallback errorCallback, VoidCallback successCallback]);

  void transaction(SQLTransactionCallback callback, [SQLTransactionErrorCallback errorCallback, VoidCallback successCallback]);
}
// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

typedef bool DatabaseCallback(var database);
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

interface DatabaseSync {

  final String lastErrorMessage;

  final String version;

  void changeVersion(String oldVersion, String newVersion, [SQLTransactionSyncCallback callback]);

  void readTransaction(SQLTransactionSyncCallback callback);

  void transaction(SQLTransactionSyncCallback callback);
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

interface DedicatedWorkerContext extends WorkerContext {

  EventListener onmessage;

  void postMessage(Object message, [List messagePorts]);

  void webkitPostMessage(Object message, [List transferList]);
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

interface DelayNode extends AudioNode {

  final AudioParam delayTime;
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

interface DeprecatedPeerConnection default _DeprecatedPeerConnectionFactoryProvider {

  DeprecatedPeerConnection(String serverConfiguration, SignalingCallback signalingCallback);

  static final int ACTIVE = 2;

  static final int CLOSED = 3;

  static final int NEGOTIATING = 1;

  static final int NEW = 0;

  final MediaStreamList localStreams;

  EventListener onaddstream;

  EventListener onconnecting;

  EventListener onmessage;

  EventListener onopen;

  EventListener onremovestream;

  EventListener onstatechange;

  final int readyState;

  final MediaStreamList remoteStreams;

  void addEventListener(String type, EventListener listener, [bool useCapture]);

  void addStream(MediaStream stream);

  void close();

  bool dispatchEvent(Event event);

  void processSignalingMessage(String message);

  void removeEventListener(String type, EventListener listener, [bool useCapture]);

  void removeStream(MediaStream stream);

  void send(String text);
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

interface DetailsElement extends Element {

  bool open;
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

interface DeviceMotionEvent extends Event {

  final num interval;
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

interface DeviceOrientationEvent extends Event {

  final bool absolute;

  final num alpha;

  final num beta;

  final num gamma;

  void initDeviceOrientationEvent(String type, bool bubbles, bool cancelable, num alpha, num beta, num gamma, bool absolute);
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

interface DirectoryElement extends Element {

  bool compact;
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

interface DirectoryEntry extends Entry {

  DirectoryReader createReader();

  void getDirectory(String path, [Object flags, EntryCallback successCallback, ErrorCallback errorCallback]);

  void getFile(String path, [Object flags, EntryCallback successCallback, ErrorCallback errorCallback]);

  void removeRecursively(VoidCallback successCallback, [ErrorCallback errorCallback]);
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

interface DirectoryEntrySync extends EntrySync {

  DirectoryReaderSync createReader();

  DirectoryEntrySync getDirectory(String path, Object flags);

  FileEntrySync getFile(String path, Object flags);

  void removeRecursively();
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

interface DirectoryReader {

  void readEntries(EntriesCallback successCallback, [ErrorCallback errorCallback]);
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

interface DirectoryReaderSync {

  EntryArraySync readEntries();
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

interface DivElement extends Element {

  String align;
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

interface Document extends HtmlElement {


  DocumentEvents get on();

  final Element activeElement;

  Element body;

  String charset;

  String cookie;

  final Window window;

  final String domain;

  final HeadElement head;

  final String lastModified;

  final String preferredStylesheetSet;

  final String readyState;

  final String referrer;

  String selectedStylesheetSet;

  final StyleSheetList styleSheets;

  String title;

  final Element webkitCurrentFullScreenElement;

  final bool webkitFullScreenKeyboardInputAllowed;

  final Element webkitFullscreenElement;

  final bool webkitFullscreenEnabled;

  final bool webkitHidden;

  final bool webkitIsFullScreen;

  final String webkitVisibilityState;

  Range caretRangeFromPoint(int x, int y);

  CDATASection createCDATASection(String data);

  DocumentFragment createDocumentFragment();

  Range createRange();

  Touch createTouch(Window window, EventTarget target, int identifier, int pageX, int pageY, int screenX, int screenY, int webkitRadiusX, int webkitRadiusY, num webkitRotationAngle, num webkitForce);

  Element elementFromPoint(int x, int y);

  bool execCommand(String command, bool userInterface, String value);

  CanvasRenderingContext getCSSCanvasContext(String contextId, String name, int width, int height);

  bool queryCommandEnabled(String command);

  bool queryCommandIndeterm(String command);

  bool queryCommandState(String command);

  bool queryCommandSupported(String command);

  String queryCommandValue(String command);

  void webkitCancelFullScreen();

  void webkitExitFullscreen();

  WebKitNamedFlow webkitGetFlowByName(String name);

}

interface DocumentEvents extends ElementEvents {

  EventListenerList get abort();

  EventListenerList get beforeCopy();

  EventListenerList get beforeCut();

  EventListenerList get beforePaste();

  EventListenerList get blur();

  EventListenerList get change();

  EventListenerList get click();

  EventListenerList get contextMenu();

  EventListenerList get copy();

  EventListenerList get cut();

  EventListenerList get doubleClick();

  EventListenerList get drag();

  EventListenerList get dragEnd();

  EventListenerList get dragEnter();

  EventListenerList get dragLeave();

  EventListenerList get dragOver();

  EventListenerList get dragStart();

  EventListenerList get drop();

  EventListenerList get error();

  EventListenerList get focus();

  EventListenerList get fullscreenChange();

  EventListenerList get fullscreenError();

  EventListenerList get input();

  EventListenerList get invalid();

  EventListenerList get keyDown();

  EventListenerList get keyPress();

  EventListenerList get keyUp();

  EventListenerList get load();

  EventListenerList get mouseDown();

  EventListenerList get mouseMove();

  EventListenerList get mouseOut();

  EventListenerList get mouseOver();

  EventListenerList get mouseUp();

  EventListenerList get mouseWheel();

  EventListenerList get paste();

  EventListenerList get readyStateChange();

  EventListenerList get reset();

  EventListenerList get scroll();

  EventListenerList get search();

  EventListenerList get select();

  EventListenerList get selectStart();

  EventListenerList get selectionChange();

  EventListenerList get submit();

  EventListenerList get touchCancel();

  EventListenerList get touchEnd();

  EventListenerList get touchMove();

  EventListenerList get touchStart();
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

interface DocumentFragment extends Element default _DocumentFragmentFactoryProvider {

  DocumentFragment();

  DocumentFragment.html(String html);

  // TODO(nweiz): enable this when XML is ported
  // /** WARNING: Currently this doesn't work on Dartium (issue 649). */
  // DocumentFragment.xml(String xml);

  DocumentFragment.svg(String svg);

  DocumentFragment clone(bool deep);


  ElementEvents get on();

  Element query(String selectors);

}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

interface DocumentType extends Node {

  final NamedNodeMap entities;

  final String internalSubset;

  final String name;

  final NamedNodeMap notations;

  final String publicId;

  final String systemId;
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

interface DynamicsCompressorNode extends AudioNode {

  final AudioParam knee;

  final AudioParam ratio;

  final AudioParam reduction;

  final AudioParam threshold;
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

interface EXTTextureFilterAnisotropic {

  static final int MAX_TEXTURE_MAX_ANISOTROPY_EXT = 0x84FF;

  static final int TEXTURE_MAX_ANISOTROPY_EXT = 0x84FE;
}
// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/**
 * Provides a Map abstraction on top of data-* attributes, similar to the
 * dataSet in the old DOM.
 */
class _DataAttributeMap implements Map<String, String> {

  final Map<String, String> _attributes;

  _DataAttributeMap(this._attributes);

  // interface Map

  // TODO: Use lazy iterator when it is available on Map.
  bool containsValue(String value) => getValues().some((v) => v == value);

  bool containsKey(String key) => _attributes.containsKey(_attr(key));

  String operator [](String key) => _attributes[_attr(key)];

  void operator []=(String key, String value) {
    _attributes[_attr(key)] = value;
  }

  String putIfAbsent(String key, String ifAbsent()) {
    if (!containsKey(key)) {
      return this[key] = ifAbsent();
    }
    return this[key];
  }

  String remove(String key) => _attributes.remove(_attr(key));

  void clear() {
    // Needs to operate on a snapshot since we are mutatiting the collection.
    for (String key in getKeys()) {
      remove(key);
    }
  }

  void forEach(void f(String key, String value)) {
    _attributes.forEach((String key, String value) {
      if (_matches(key)) {
        f(_strip(key), value);
      }
    });
  }

  Collection<String> getKeys() {
    final keys = new List<String>();
    _attributes.forEach((String key, String value) {
      if (_matches(key)) {
        keys.add(_strip(key));
      }
    });
    return keys;
  }

  Collection<String> getValues() {
    final values = new List<String>();
    _attributes.forEach((String key, String value) {
      if (_matches(key)) {
        values.add(value);
      }
    });
    return values;
  }

  int get length() => getKeys().length;

  // TODO: Use lazy iterator when it is available on Map.
  bool isEmpty() => length == 0;

  // Helpers.
  String _attr(String key) => 'data-$key';
  bool _matches(String key) => key.startsWith('data-');
  String _strip(String key) => key.substring(5);
}

class _CssClassSet implements Set<String> {

  final _ElementImpl _element;

  _CssClassSet(this._element);

  String toString() {
    return _formatSet(_read());
  }

  // interface Iterable - BEGIN
  Iterator<String> iterator() {
    return _read().iterator();
  }
  // interface Iterable - END

  // interface Collection - BEGIN
  void forEach(void f(String element)) {
    _read().forEach(f);
  }

  Collection map(f(String element)) {
    return _read().map(f);
  }

  Collection<String> filter(bool f(String element)) {
    return _read().filter(f);
  }

  bool every(bool f(String element)) {
    return _read().every(f);
  }

  bool some(bool f(String element)) {
    return _read().some(f);
  }

  bool isEmpty() {
    return _read().isEmpty();
  }

  int get length() {
    return _read().length;
  }
  // interface Collection - END

  // interface Set - BEGIN
  bool contains(String value) {
    return _read().contains(value);
  }

  void add(String value) {
    // TODO - figure out if we need to do any validation here
    // or if the browser natively does enough
    _modify((s) => s.add(value));
  }

  bool remove(String value) {
    Set<String> s = _read();
    bool result = s.remove(value);
    _write(s);
    return result;
  }

  void addAll(Collection<String> collection) {
    // TODO - see comment above about validation
    _modify((s) => s.addAll(collection));
  }

  void removeAll(Collection<String> collection) {
    _modify((s) => s.removeAll(collection));
  }

  bool isSubsetOf(Collection<String> collection) {
    return _read().isSubsetOf(collection);
  }

  bool containsAll(Collection<String> collection) {
    return _read().containsAll(collection);
  }

  Set<String> intersection(Collection<String> other) {
    return _read().intersection(other);
  }

  void clear() {
    _modify((s) => s.clear());
  }
  // interface Set - END

  /**
   * Helper method used to modify the set of css classes on this element.
   *
   *   f - callback with:
   *      s - a Set of all the css class name currently on this element.
   *
   *   After f returns, the modified set is written to the
   *       className property of this element.
   */
  void _modify( f(Set<String> s)) {
    Set<String> s = _read();
    f(s);
    _write(s);
  }

  /**
   * Read the class names from the Element class property,
   * and put them into a set (duplicates are discarded).
   */
  Set<String> _read() {
    // TODO(mattsh) simplify this once split can take regex.
    Set<String> s = new Set<String>();
    for (String name in _className().split(' ')) {
      String trimmed = name.trim();
      if (!trimmed.isEmpty()) {
        s.add(trimmed);
      }
    }
    return s;
  }

  /**
   * Read the class names as a space-separated string. This is meant to be
   * overridden by subclasses.
   */
  String _className() => _element._className;

  /**
   * Join all the elements of a set into one string and write
   * back to the element.
   */
  void _write(Set s) {
    _element._className = _formatSet(s);
  }

  String _formatSet(Set<String> s) {
    // TODO(mattsh) should be able to pass Set to String.joins http:/b/5398605
    List list = new List.from(s);
    return Strings.join(list, ' ');
  }
}

interface ElementList extends List<Element> {
  // TODO(jacobr): add element batch manipulation methods.
  ElementList filter(bool f(Element element));

  ElementList getRange(int start, int length);

  Element get first();
  // TODO(jacobr): add insertAt
}

/**
 * All your element measurement needs in one place
 */
interface ElementRect {
  // Relative to offsetParent
  ClientRect get client();
  ClientRect get offset();
  ClientRect get scroll();
  // In global coords
  ClientRect get bounding();
  // In global coords
  List<ClientRect> get clientRects();
}

interface Element extends Node, NodeSelector default _ElementFactoryProvider {
// TODO(jacobr): switch back to:
// interface Element extends Node, NodeSelector, ElementTraversal default _ElementImpl {
  Element.html(String html);
  Element.tag(String tag);

  Map<String, String> get attributes();
  void set attributes(Map<String, String> value);

  /**
   * @domName querySelectorAll, getElementsByClassName, getElementsByTagName,
   *   getElementsByTagNameNS
   */
  ElementList queryAll(String selectors);

  /**
   * @domName childElementCount, firstElementChild, lastElementChild,
   *   children, Node.nodes.add
   */
  ElementList get elements();

  void set elements(Collection<Element> value);

  /** @domName className, classList */
  Set<String> get classes();

  void set classes(Collection<String> value);

  Map<String, String> get dataAttributes();
  void set dataAttributes(Map<String, String> value);

  /**
   * @domName getClientRects, getBoundingClientRect, clientHeight, clientWidth,
   * clientTop, clientLeft, offsetHeight, offsetWidth, offsetTop, offsetLeft,
   * scrollHeight, scrollWidth, scrollTop, scrollLeft
   */
  Future<ElementRect> get rect();

  /** @domName Window.getComputedStyle */
  Future<CSSStyleDeclaration> get computedStyle();

  /** @domName Window.getComputedStyle */
  Future<CSSStyleDeclaration> getComputedStyle(String pseudoElement);

  Element clone(bool deep);

  Element get parent();


  ElementEvents get on();

  static final int ALLOW_KEYBOARD_INPUT = 1;

  String contentEditable;

  String dir;

  bool draggable;

  bool hidden;

  String id;

  String innerHTML;

  final bool isContentEditable;

  String lang;

  final Element lastElementChild;

  final Element nextElementSibling;

  final Element offsetParent;

  final String outerHTML;

  final Element previousElementSibling;

  bool spellcheck;

  final CSSStyleDeclaration style;

  int tabIndex;

  final String tagName;

  String title;

  bool translate;

  final String webkitRegionOverflow;

  String webkitdropzone;

  void blur();

  void click();

  void focus();

  Element insertAdjacentElement(String where, Element element);

  void insertAdjacentHTML(String where, String html);

  void insertAdjacentText(String where, String text);

  Element query(String selectors);

  void scrollByLines(int lines);

  void scrollByPages(int pages);

  void scrollIntoView([bool centerIfNeeded]);

  bool matchesSelector(String selectors);

  void webkitRequestFullScreen(int flags);

  void webkitRequestFullscreen();

}

interface ElementEvents extends Events {

  EventListenerList get abort();

  EventListenerList get beforeCopy();

  EventListenerList get beforeCut();

  EventListenerList get beforePaste();

  EventListenerList get blur();

  EventListenerList get change();

  EventListenerList get click();

  EventListenerList get contextMenu();

  EventListenerList get copy();

  EventListenerList get cut();

  EventListenerList get doubleClick();

  EventListenerList get drag();

  EventListenerList get dragEnd();

  EventListenerList get dragEnter();

  EventListenerList get dragLeave();

  EventListenerList get dragOver();

  EventListenerList get dragStart();

  EventListenerList get drop();

  EventListenerList get error();

  EventListenerList get focus();

  EventListenerList get fullscreenChange();

  EventListenerList get fullscreenError();

  EventListenerList get input();

  EventListenerList get invalid();

  EventListenerList get keyDown();

  EventListenerList get keyPress();

  EventListenerList get keyUp();

  EventListenerList get load();

  EventListenerList get mouseDown();

  EventListenerList get mouseMove();

  EventListenerList get mouseOut();

  EventListenerList get mouseOver();

  EventListenerList get mouseUp();

  EventListenerList get mouseWheel();

  EventListenerList get paste();

  EventListenerList get reset();

  EventListenerList get scroll();

  EventListenerList get search();

  EventListenerList get select();

  EventListenerList get selectStart();

  EventListenerList get submit();

  EventListenerList get touchCancel();

  EventListenerList get touchEnd();

  EventListenerList get touchLeave();

  EventListenerList get touchMove();

  EventListenerList get touchStart();

  EventListenerList get transitionEnd();
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

interface ElementTimeControl {

  void beginElement();

  void beginElementAt(num offset);

  void endElement();

  void endElementAt(num offset);
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

interface ElementTraversal {

  final int childElementCount;

  final Element firstElementChild;

  final Element lastElementChild;

  final Element nextElementSibling;

  final Element previousElementSibling;
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

interface EmbedElement extends Element {

  String align;

  String height;

  String name;

  String src;

  String type;

  String width;
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

interface Entity extends Node {

  final String notationName;

  final String publicId;

  final String systemId;
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

interface EntityReference extends Node {
}
// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

typedef bool EntriesCallback(EntryArray entries);
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

interface Entry {

  final DOMFileSystem filesystem;

  final String fullPath;

  final bool isDirectory;

  final bool isFile;

  final String name;

  void copyTo(DirectoryEntry parent, [String name, EntryCallback successCallback, ErrorCallback errorCallback]);

  void getMetadata(MetadataCallback successCallback, [ErrorCallback errorCallback]);

  void getParent([EntryCallback successCallback, ErrorCallback errorCallback]);

  void moveTo(DirectoryEntry parent, [String name, EntryCallback successCallback, ErrorCallback errorCallback]);

  void remove(VoidCallback successCallback, [ErrorCallback errorCallback]);

  String toURL();
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

interface EntryArray {

  final int length;

  Entry item(int index);
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

interface EntryArraySync {

  final int length;

  EntrySync item(int index);
}
// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

typedef bool EntryCallback(Entry entry);
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

interface EntrySync {

  final DOMFileSystemSync filesystem;

  final String fullPath;

  final bool isDirectory;

  final bool isFile;

  final String name;

  EntrySync copyTo(DirectoryEntrySync parent, String name);

  Metadata getMetadata();

  DirectoryEntrySync getParent();

  EntrySync moveTo(DirectoryEntrySync parent, String name);

  void remove();

  String toURL();
}
// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

typedef bool ErrorCallback(FileError error);
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

interface ErrorEvent extends Event {

  final String filename;

  final int lineno;

  final String message;
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

interface Event default _EventFactoryProvider {

  // In JS, canBubble and cancelable are technically required parameters to
  // init*Event. In practice, though, if they aren't provided they simply
  // default to false (since that's Boolean(undefined)).
  //
  // Contrary to JS, we default canBubble and cancelable to true, since that's
  // what people want most of the time anyway.
  Event(String type, [bool canBubble, bool cancelable]);

  static final int AT_TARGET = 2;

  static final int BLUR = 8192;

  static final int BUBBLING_PHASE = 3;

  static final int CAPTURING_PHASE = 1;

  static final int CHANGE = 32768;

  static final int CLICK = 64;

  static final int DBLCLICK = 128;

  static final int DRAGDROP = 2048;

  static final int FOCUS = 4096;

  static final int KEYDOWN = 256;

  static final int KEYPRESS = 1024;

  static final int KEYUP = 512;

  static final int MOUSEDOWN = 1;

  static final int MOUSEDRAG = 32;

  static final int MOUSEMOVE = 16;

  static final int MOUSEOUT = 8;

  static final int MOUSEOVER = 4;

  static final int MOUSEUP = 2;

  static final int SELECT = 16384;

  final bool bubbles;

  bool cancelBubble;

  final bool cancelable;

  final Clipboard clipboardData;

  final EventTarget currentTarget;

  final bool defaultPrevented;

  final int eventPhase;

  bool returnValue;

  final EventTarget srcElement;

  final EventTarget target;

  final int timeStamp;

  final String type;

  void preventDefault();

  void stopImmediatePropagation();

  void stopPropagation();
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

interface EventException {

  static final int DISPATCH_REQUEST_ERR = 1;

  static final int UNSPECIFIED_EVENT_TYPE_ERR = 0;

  final int code;

  final String message;

  final String name;

  String toString();
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

interface EventSource extends EventTarget default _EventSourceFactoryProvider {

  EventSource(String scriptUrl);

  EventSourceEvents get on();

  static final int CLOSED = 2;

  static final int CONNECTING = 0;

  static final int OPEN = 1;

  final String URL;

  final int readyState;

  final String url;

  void close();
}

interface EventSourceEvents extends Events {

  EventListenerList get error();

  EventListenerList get message();

  EventListenerList get open();
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

interface EventListenerList {
  EventListenerList add(EventListener handler, [bool useCapture]);

  EventListenerList remove(EventListener handler, [bool useCapture]);

  bool dispatch(Event evt);
}

interface Events {
  EventListenerList operator [](String type);
}

interface EventTarget {

  final Events on;

}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

interface FieldSetElement extends Element {

  final FormElement form;

  String name;

  final String type;

  final String validationMessage;

  final ValidityState validity;

  final bool willValidate;

  bool checkValidity();

  void setCustomValidity(String error);
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

interface File extends Blob {

  final Date lastModifiedDate;

  final String name;

  final String webkitRelativePath;
}
// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

typedef bool FileCallback(File file);
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

interface FileEntry extends Entry {

  void createWriter(FileWriterCallback successCallback, [ErrorCallback errorCallback]);

  void file(FileCallback successCallback, [ErrorCallback errorCallback]);
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

interface FileEntrySync extends EntrySync {

  FileWriterSync createWriter();

  File file();
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

interface FileError {

  static final int ABORT_ERR = 3;

  static final int ENCODING_ERR = 5;

  static final int INVALID_MODIFICATION_ERR = 9;

  static final int INVALID_STATE_ERR = 7;

  static final int NOT_FOUND_ERR = 1;

  static final int NOT_READABLE_ERR = 4;

  static final int NO_MODIFICATION_ALLOWED_ERR = 6;

  static final int PATH_EXISTS_ERR = 12;

  static final int QUOTA_EXCEEDED_ERR = 10;

  static final int SECURITY_ERR = 2;

  static final int SYNTAX_ERR = 8;

  static final int TYPE_MISMATCH_ERR = 11;

  final int code;
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

interface FileException {

  static final int ABORT_ERR = 3;

  static final int ENCODING_ERR = 5;

  static final int INVALID_MODIFICATION_ERR = 9;

  static final int INVALID_STATE_ERR = 7;

  static final int NOT_FOUND_ERR = 1;

  static final int NOT_READABLE_ERR = 4;

  static final int NO_MODIFICATION_ALLOWED_ERR = 6;

  static final int PATH_EXISTS_ERR = 12;

  static final int QUOTA_EXCEEDED_ERR = 10;

  static final int SECURITY_ERR = 2;

  static final int SYNTAX_ERR = 8;

  static final int TYPE_MISMATCH_ERR = 11;

  final int code;

  final String message;

  final String name;

  String toString();
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

interface FileList {

  final int length;

  File item(int index);
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

interface FileReader default _FileReaderFactoryProvider {

  FileReader();

  static final int DONE = 2;

  static final int EMPTY = 0;

  static final int LOADING = 1;

  final FileError error;

  EventListener onabort;

  EventListener onerror;

  EventListener onload;

  EventListener onloadend;

  EventListener onloadstart;

  EventListener onprogress;

  final int readyState;

  final Object result;

  void abort();

  void addEventListener(String type, EventListener listener, [bool useCapture]);

  bool dispatchEvent(Event evt);

  void readAsArrayBuffer(Blob blob);

  void readAsBinaryString(Blob blob);

  void readAsDataURL(Blob blob);

  void readAsText(Blob blob, [String encoding]);

  void removeEventListener(String type, EventListener listener, [bool useCapture]);
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

interface FileReaderSync default _FileReaderSyncFactoryProvider {

  FileReaderSync();

  ArrayBuffer readAsArrayBuffer(Blob blob);

  String readAsBinaryString(Blob blob);

  String readAsDataURL(Blob blob);

  String readAsText(Blob blob, [String encoding]);
}
// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

typedef bool FileSystemCallback(DOMFileSystem fileSystem);
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

interface FileWriter {

  static final int DONE = 2;

  static final int INIT = 0;

  static final int WRITING = 1;

  final FileError error;

  final int length;

  EventListener onabort;

  EventListener onerror;

  EventListener onprogress;

  EventListener onwrite;

  EventListener onwriteend;

  EventListener onwritestart;

  final int position;

  final int readyState;

  void abort();

  void seek(int position);

  void truncate(int size);

  void write(Blob data);
}
// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

typedef bool FileWriterCallback(FileWriter fileWriter);
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

interface FileWriterSync {

  final int length;

  final int position;

  void seek(int position);

  void truncate(int size);

  void write(Blob data);
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

interface Float32Array extends ArrayBufferView, List<num> default _TypedArrayFactoryProvider {

  Float32Array(int length);

  Float32Array.fromList(List<num> list);

  Float32Array.fromBuffer(ArrayBuffer buffer);

  static final int BYTES_PER_ELEMENT = 4;

  final int length;

  void setElements(Object array, [int offset]);

  Float32Array subarray(int start, [int end]);
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

interface Float64Array extends ArrayBufferView, List<num> default _TypedArrayFactoryProvider {

  Float64Array(int length);

  Float64Array.fromList(List<num> list);

  Float64Array.fromBuffer(ArrayBuffer buffer);

  static final int BYTES_PER_ELEMENT = 8;

  final int length;

  void setElements(Object array, [int offset]);

  Float64Array subarray(int start, [int end]);
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

interface FontElement extends Element {

  String color;

  String face;

  String size;
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

interface FormElement extends Element {

  String acceptCharset;

  String action;

  String autocomplete;

  String encoding;

  String enctype;

  final int length;

  String method;

  String name;

  bool noValidate;

  String target;

  bool checkValidity();

  void reset();

  void submit();
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

interface FrameElement extends Element {

  final Document contentDocument;

  final Window contentWindow;

  String frameBorder;

  final int height;

  String location;

  String longDesc;

  String marginHeight;

  String marginWidth;

  String name;

  bool noResize;

  String scrolling;

  String src;

  final int width;

  SVGDocument getSVGDocument();
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

interface FrameSetElement extends Element {

  FrameSetElementEvents get on();

  String cols;

  String rows;
}

interface FrameSetElementEvents extends ElementEvents {

  EventListenerList get beforeUnload();

  EventListenerList get blur();

  EventListenerList get error();

  EventListenerList get focus();

  EventListenerList get hashChange();

  EventListenerList get load();

  EventListenerList get message();

  EventListenerList get offline();

  EventListenerList get online();

  EventListenerList get popState();

  EventListenerList get resize();

  EventListenerList get storage();

  EventListenerList get unload();
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

interface Geolocation {

  void clearWatch(int watchId);

  void getCurrentPosition(PositionCallback successCallback, [PositionErrorCallback errorCallback]);

  int watchPosition(PositionCallback successCallback, [PositionErrorCallback errorCallback]);
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

interface Geoposition {

  final Coordinates coords;

  final int timestamp;
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

interface HRElement extends Element {

  String align;

  bool noShade;

  String size;

  String width;
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

interface HTMLAllCollection {

  final int length;

  Node item(int index);

  Node namedItem(String name);

  NodeList tags(String name);
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

interface HTMLCollection extends List<Node> {

  final int length;

  Node item(int index);

  Node namedItem(String name);
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

interface HTMLOptionsCollection extends HTMLCollection {

  int length;

  int selectedIndex;

  void remove(int index);
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

interface HashChangeEvent extends Event {

  final String newURL;

  final String oldURL;

  void initHashChangeEvent(String type, bool canBubble, bool cancelable, String oldURL, String newURL);
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

interface HeadElement extends Element {

  String profile;
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

interface HeadingElement extends Element {

  String align;
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

interface HighPass2FilterNode extends AudioNode {

  final AudioParam cutoff;

  final AudioParam resonance;
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

interface History {

  final int length;

  final Dynamic state;

  void back();

  void forward();

  void go(int distance);

  void pushState(Object data, String title, [String url]);

  void replaceState(Object data, String title, [String url]);
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

interface HtmlElement extends Element {
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

interface IDBAny {
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

interface IDBCursor {

  static final int NEXT = 0;

  static final int NEXT_NO_DUPLICATE = 1;

  static final int PREV = 2;

  static final int PREV_NO_DUPLICATE = 3;

  final int direction;

  final IDBKey key;

  final IDBKey primaryKey;

  final IDBAny source;

  void continueFunction([IDBKey key]);

  IDBRequest delete();

  IDBRequest update(Dynamic value);
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

interface IDBCursorWithValue extends IDBCursor {

  final IDBAny value;
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

interface IDBDatabase {

  final String name;

  final List<String> objectStoreNames;

  EventListener onabort;

  EventListener onerror;

  EventListener onversionchange;

  final String version;

  void addEventListener(String type, EventListener listener, [bool useCapture]);

  void close();

  IDBObjectStore createObjectStore(String name);

  void deleteObjectStore(String name);

  bool dispatchEvent(Event evt);

  void removeEventListener(String type, EventListener listener, [bool useCapture]);

  IDBVersionChangeRequest setVersion(String version);

  IDBTransaction transaction(var storeName_OR_storeNames, [int mode]);
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

interface IDBDatabaseError {

  int code;

  String message;
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

interface IDBDatabaseException {

  static final int ABORT_ERR = 8;

  static final int CONSTRAINT_ERR = 4;

  static final int DATA_ERR = 5;

  static final int NON_TRANSIENT_ERR = 2;

  static final int NOT_ALLOWED_ERR = 6;

  static final int NOT_FOUND_ERR = 3;

  static final int NO_ERR = 0;

  static final int QUOTA_ERR = 11;

  static final int READ_ONLY_ERR = 9;

  static final int TIMEOUT_ERR = 10;

  static final int TRANSACTION_INACTIVE_ERR = 7;

  static final int UNKNOWN_ERR = 1;

  static final int VER_ERR = 12;

  final int code;

  final String message;

  final String name;

  String toString();
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

interface IDBFactory {

  int cmp(IDBKey first, IDBKey second);

  IDBVersionChangeRequest deleteDatabase(String name);

  IDBRequest getDatabaseNames();

  IDBRequest open(String name);
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

interface IDBIndex {

  final String keyPath;

  final bool multiEntry;

  final String name;

  final IDBObjectStore objectStore;

  final bool unique;

  IDBRequest count([var key_OR_range]);

  IDBRequest getObject(IDBKey key);

  IDBRequest getKey(IDBKey key);

  IDBRequest openCursor([IDBKeyRange range, int direction]);

  IDBRequest openKeyCursor([IDBKeyRange range, int direction]);
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

interface IDBKey {
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

interface IDBKeyRange {

  final IDBKey lower;

  final bool lowerOpen;

  final IDBKey upper;

  final bool upperOpen;

  IDBKeyRange bound(IDBKey lower, IDBKey upper, [bool lowerOpen, bool upperOpen]);

  IDBKeyRange lowerBound(IDBKey bound, [bool open]);

  IDBKeyRange only(IDBKey value);

  IDBKeyRange upperBound(IDBKey bound, [bool open]);
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

interface IDBObjectStore {

  final List<String> indexNames;

  final String keyPath;

  final String name;

  final IDBTransaction transaction;

  IDBRequest add(Dynamic value, [IDBKey key]);

  IDBRequest clear();

  IDBRequest count([var key_OR_range]);

  IDBIndex createIndex(String name, String keyPath);

  IDBRequest delete(var key_OR_keyRange);

  void deleteIndex(String name);

  IDBRequest getObject(IDBKey key);

  IDBIndex index(String name);

  IDBRequest openCursor([IDBKeyRange range, int direction]);

  IDBRequest put(Dynamic value, [IDBKey key]);
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

interface IDBRequest {

  static final int DONE = 2;

  static final int LOADING = 1;

  final int errorCode;

  EventListener onerror;

  EventListener onsuccess;

  final int readyState;

  final IDBAny result;

  final IDBAny source;

  final IDBTransaction transaction;

  final String webkitErrorMessage;

  void addEventListener(String type, EventListener listener, [bool useCapture]);

  bool dispatchEvent(Event evt);

  void removeEventListener(String type, EventListener listener, [bool useCapture]);
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

interface IDBTransaction {

  static final int READ_ONLY = 0;

  static final int READ_WRITE = 1;

  static final int VERSION_CHANGE = 2;

  final IDBDatabase db;

  final int mode;

  EventListener onabort;

  EventListener oncomplete;

  EventListener onerror;

  void abort();

  void addEventListener(String type, EventListener listener, [bool useCapture]);

  bool dispatchEvent(Event evt);

  IDBObjectStore objectStore(String name);

  void removeEventListener(String type, EventListener listener, [bool useCapture]);
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

interface IDBVersionChangeEvent extends Event {

  final String version;
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

interface IDBVersionChangeRequest extends IDBRequest {

  EventListener onblocked;
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

interface IFrameElement extends Element {

  String align;

  final Document contentDocument;

  final Window contentWindow;

  String frameBorder;

  String height;

  String longDesc;

  String marginHeight;

  String marginWidth;

  String name;

  String sandbox;

  String scrolling;

  String src;

  String width;

  SVGDocument getSVGDocument();
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

interface IceCandidate default _IceCandidateFactoryProvider {

  IceCandidate(String label, String candidateLine);

  final String label;

  String toSdp();
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

interface ImageData {

  final CanvasPixelArray data;

  final int height;

  final int width;
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

interface ImageElement extends Element {

  String align;

  String alt;

  String border;

  final bool complete;

  String crossOrigin;

  int height;

  int hspace;

  bool isMap;

  String longDesc;

  String lowsrc;

  String name;

  final int naturalHeight;

  final int naturalWidth;

  String src;

  String useMap;

  int vspace;

  int width;

  final int x;

  final int y;
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

interface InputElement extends Element {

  InputElementEvents get on();

  String accept;

  String align;

  String alt;

  String autocomplete;

  bool autofocus;

  bool checked;

  bool defaultChecked;

  String defaultValue;

  bool disabled;

  final FileList files;

  final FormElement form;

  String formAction;

  String formEnctype;

  String formMethod;

  bool formNoValidate;

  String formTarget;

  bool incremental;

  bool indeterminate;

  final NodeList labels;

  String max;

  int maxLength;

  String min;

  bool multiple;

  String name;

  String pattern;

  String placeholder;

  bool readOnly;

  bool required;

  String selectionDirection;

  int selectionEnd;

  int selectionStart;

  int size;

  String src;

  String step;

  String type;

  String useMap;

  final String validationMessage;

  final ValidityState validity;

  String value;

  Date valueAsDate;

  num valueAsNumber;

  bool webkitGrammar;

  bool webkitSpeech;

  bool webkitdirectory;

  final bool willValidate;

  bool checkValidity();

  void select();

  void setCustomValidity(String error);

  void setSelectionRange(int start, int end, [String direction]);

  void stepDown([int n]);

  void stepUp([int n]);
}

interface InputElementEvents extends ElementEvents {

  EventListenerList get speechChange();
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

interface Int16Array extends ArrayBufferView, List<int> default _TypedArrayFactoryProvider {

  Int16Array(int length);

  Int16Array.fromList(List<int> list);

  Int16Array.fromBuffer(ArrayBuffer buffer);

  static final int BYTES_PER_ELEMENT = 2;

  final int length;

  void setElements(Object array, [int offset]);

  Int16Array subarray(int start, [int end]);
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

interface Int32Array extends ArrayBufferView, List<int> default _TypedArrayFactoryProvider {

  Int32Array(int length);

  Int32Array.fromList(List<int> list);

  Int32Array.fromBuffer(ArrayBuffer buffer);

  static final int BYTES_PER_ELEMENT = 4;

  final int length;

  void setElements(Object array, [int offset]);

  Int32Array subarray(int start, [int end]);
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

interface Int8Array extends ArrayBufferView, List<int> default _TypedArrayFactoryProvider {

  Int8Array(int length);

  Int8Array.fromList(List<int> list);

  Int8Array.fromBuffer(ArrayBuffer buffer);

  static final int BYTES_PER_ELEMENT = 1;

  final int length;

  void setElements(Object array, [int offset]);

  Int8Array subarray(int start, [int end]);
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

interface JavaScriptAudioNode extends AudioNode {

  final int bufferSize;

  EventListener onaudioprocess;
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

interface JavaScriptCallFrame {

  static final int CATCH_SCOPE = 4;

  static final int CLOSURE_SCOPE = 3;

  static final int GLOBAL_SCOPE = 0;

  static final int LOCAL_SCOPE = 1;

  static final int WITH_SCOPE = 2;

  final JavaScriptCallFrame caller;

  final int column;

  final String functionName;

  final int line;

  final List scopeChain;

  final int sourceID;

  final Object thisObject;

  final String type;

  void evaluate(String script);

  int scopeType(int scopeIndex);
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

interface KeyboardEvent extends UIEvent {

  final bool altGraphKey;

  final bool altKey;

  final bool ctrlKey;

  final String keyIdentifier;

  final int keyLocation;

  final bool metaKey;

  final bool shiftKey;

  void initKeyboardEvent(String type, bool canBubble, bool cancelable, Window view, String keyIdentifier, int keyLocation, bool ctrlKey, bool altKey, bool shiftKey, bool metaKey, bool altGraphKey);
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

interface KeygenElement extends Element {

  bool autofocus;

  String challenge;

  bool disabled;

  final FormElement form;

  String keytype;

  final NodeList labels;

  String name;

  final String type;

  final String validationMessage;

  final ValidityState validity;

  final bool willValidate;

  bool checkValidity();

  void setCustomValidity(String error);
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

interface LIElement extends Element {

  String type;

  int value;
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

interface LabelElement extends Element {

  final Element control;

  final FormElement form;

  String htmlFor;
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

interface LegendElement extends Element {

  String align;

  final FormElement form;
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

interface LinkElement extends Element {

  String charset;

  bool disabled;

  String href;

  String hreflang;

  String media;

  String rel;

  String rev;

  final StyleSheet sheet;

  DOMSettableTokenList sizes;

  String target;

  String type;
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

interface LocalMediaStream extends MediaStream {

  void stop();
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

interface Location {

  String hash;

  String host;

  String hostname;

  String href;

  final String origin;

  String pathname;

  String port;

  String protocol;

  String search;

  void assign(String url);

  void reload();

  void replace(String url);

  String toString();
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

interface LowPass2FilterNode extends AudioNode {

  final AudioParam cutoff;

  final AudioParam resonance;
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

interface MapElement extends Element {

  final HTMLCollection areas;

  String name;
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

interface MarqueeElement extends Element {

  String behavior;

  String bgColor;

  String direction;

  String height;

  int hspace;

  int loop;

  int scrollAmount;

  int scrollDelay;

  bool trueSpeed;

  int vspace;

  String width;

  void start();

  void stop();
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

interface MediaController default _MediaControllerFactoryProvider {

  MediaController();

  final TimeRanges buffered;

  num currentTime;

  num defaultPlaybackRate;

  final num duration;

  bool muted;

  final bool paused;

  num playbackRate;

  final TimeRanges played;

  final TimeRanges seekable;

  num volume;

  void addEventListener(String type, EventListener listener, [bool useCapture]);

  bool dispatchEvent(Event evt);

  void pause();

  void play();

  void removeEventListener(String type, EventListener listener, [bool useCapture]);
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

interface MediaElement extends Element {

  static final int EOS_DECODE_ERR = 2;

  static final int EOS_NETWORK_ERR = 1;

  static final int EOS_NO_ERROR = 0;

  static final int HAVE_CURRENT_DATA = 2;

  static final int HAVE_ENOUGH_DATA = 4;

  static final int HAVE_FUTURE_DATA = 3;

  static final int HAVE_METADATA = 1;

  static final int HAVE_NOTHING = 0;

  static final int NETWORK_EMPTY = 0;

  static final int NETWORK_IDLE = 1;

  static final int NETWORK_LOADING = 2;

  static final int NETWORK_NO_SOURCE = 3;

  static final int SOURCE_CLOSED = 0;

  static final int SOURCE_ENDED = 2;

  static final int SOURCE_OPEN = 1;

  bool autoplay;

  final TimeRanges buffered;

  MediaController controller;

  bool controls;

  final String currentSrc;

  num currentTime;

  bool defaultMuted;

  num defaultPlaybackRate;

  final num duration;

  final bool ended;

  final MediaError error;

  final num initialTime;

  bool loop;

  String mediaGroup;

  bool muted;

  final int networkState;

  final bool paused;

  num playbackRate;

  final TimeRanges played;

  String preload;

  final int readyState;

  final TimeRanges seekable;

  final bool seeking;

  String src;

  final num startTime;

  final TextTrackList textTracks;

  num volume;

  final int webkitAudioDecodedByteCount;

  bool webkitClosedCaptionsVisible;

  final bool webkitHasClosedCaptions;

  final String webkitMediaSourceURL;

  bool webkitPreservesPitch;

  final int webkitSourceState;

  final int webkitVideoDecodedByteCount;

  TextTrack addTextTrack(String kind, [String label, String language]);

  String canPlayType(String type);

  void load();

  void pause();

  void play();

  void webkitSourceAppend(Uint8Array data);

  void webkitSourceEndOfStream(int status);
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

interface MediaElementAudioSourceNode extends AudioSourceNode {

  final MediaElement mediaElement;
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

interface MediaError {

  static final int MEDIA_ERR_ABORTED = 1;

  static final int MEDIA_ERR_DECODE = 3;

  static final int MEDIA_ERR_NETWORK = 2;

  static final int MEDIA_ERR_SRC_NOT_SUPPORTED = 4;

  final int code;
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

interface MediaList extends List<String> {

  final int length;

  String mediaText;

  void appendMedium(String newMedium);

  void deleteMedium(String oldMedium);

  String item(int index);
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

interface MediaQueryList {

  final bool matches;

  final String media;

  void addListener(MediaQueryListListener listener);

  void removeListener(MediaQueryListListener listener);
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

interface MediaQueryListListener {

  void queryChanged(MediaQueryList list);
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

interface MediaStream default _MediaStreamFactoryProvider {

  MediaStream(MediaStreamTrackList audioTracks, MediaStreamTrackList videoTracks);

  static final int ENDED = 2;

  static final int LIVE = 1;

  final MediaStreamTrackList audioTracks;

  final String label;

  EventListener onended;

  final int readyState;

  final MediaStreamTrackList videoTracks;

  void addEventListener(String type, EventListener listener, [bool useCapture]);

  bool dispatchEvent(Event event);

  void removeEventListener(String type, EventListener listener, [bool useCapture]);
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

interface MediaStreamEvent extends Event {

  final MediaStream stream;
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

interface MediaStreamList {

  final int length;

  MediaStream item(int index);
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

interface MediaStreamTrack {

  bool enabled;

  final String kind;

  final String label;
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

interface MediaStreamTrackList {

  final int length;

  MediaStreamTrack item(int index);
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

interface MemoryInfo {

  final int jsHeapSizeLimit;

  final int totalJSHeapSize;

  final int usedJSHeapSize;
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

interface MenuElement extends Element {

  bool compact;
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

interface MessageChannel default _MessageChannelFactoryProvider {

  MessageChannel();

  final MessagePort port1;

  final MessagePort port2;
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

interface MessageEvent extends Event {

  final Object data;

  final String lastEventId;

  final String origin;

  final List ports;

  final Window source;

  void initMessageEvent(String typeArg, bool canBubbleArg, bool cancelableArg, Object dataArg, String originArg, String lastEventIdArg, Window sourceArg, List messagePorts);

  void webkitInitMessageEvent(String typeArg, bool canBubbleArg, bool cancelableArg, Object dataArg, String originArg, String lastEventIdArg, Window sourceArg, List transferables);
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

interface MessagePort extends EventTarget {

  MessagePortEvents get on();

  void close();

  void postMessage(String message, [List messagePorts]);

  void start();

  void webkitPostMessage(String message, [List transfer]);
}

interface MessagePortEvents extends Events {

  EventListenerList get message();
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

interface MetaElement extends Element {

  String content;

  String httpEquiv;

  String name;

  String scheme;
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

interface Metadata {

  final Date modificationTime;

  final int size;
}
// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

typedef bool MetadataCallback(Metadata metadata);
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

interface MeterElement extends Element {

  num high;

  final NodeList labels;

  num low;

  num max;

  num min;

  num optimum;

  num value;
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

interface ModElement extends Element {

  String cite;

  String dateTime;
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

interface MouseEvent extends UIEvent default _MouseEventFactoryProvider {

  MouseEvent(String type, Window view, int detail, int screenX, int screenY,
      int clientX, int clientY, int button, [bool canBubble, bool cancelable,
      bool ctrlKey, bool altKey, bool shiftKey, bool metaKey,
      EventTarget relatedTarget]);


  final bool altKey;

  final int button;

  final int clientX;

  final int clientY;

  final bool ctrlKey;

  final Clipboard dataTransfer;

  final Node fromElement;

  final bool metaKey;

  final int offsetX;

  final int offsetY;

  final EventTarget relatedTarget;

  final int screenX;

  final int screenY;

  final bool shiftKey;

  final Node toElement;

  final int x;

  final int y;
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

interface MutationEvent extends Event {

  static final int ADDITION = 2;

  static final int MODIFICATION = 1;

  static final int REMOVAL = 3;

  final int attrChange;

  final String attrName;

  final String newValue;

  final String prevValue;

  final Node relatedNode;

  void initMutationEvent(String type, bool canBubble, bool cancelable, Node relatedNode, String prevValue, String newValue, String attrName, int attrChange);
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

interface NamedNodeMap extends List<Node> {

  final int length;

  Node getNamedItem(String name);

  Node getNamedItemNS(String namespaceURI, String localName);

  Node item(int index);

  Node removeNamedItem(String name);

  Node removeNamedItemNS(String namespaceURI, String localName);

  Node setNamedItem(Node node);

  Node setNamedItemNS(Node node);
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

interface Navigator {

  final String appCodeName;

  final String appName;

  final String appVersion;

  final bool cookieEnabled;

  final Geolocation geolocation;

  final String language;

  final DOMMimeTypeArray mimeTypes;

  final bool onLine;

  final String platform;

  final DOMPluginArray plugins;

  final String product;

  final String productSub;

  final String userAgent;

  final String vendor;

  final String vendorSub;

  void getStorageUpdates();

  bool javaEnabled();

  void registerProtocolHandler(String scheme, String url, String title);

  void webkitGetUserMedia(String options, NavigatorUserMediaSuccessCallback successCallback, [NavigatorUserMediaErrorCallback errorCallback]);
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

interface NavigatorUserMediaError {

  static final int PERMISSION_DENIED = 1;

  final int code;
}
// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

typedef bool NavigatorUserMediaErrorCallback(NavigatorUserMediaError error);
// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

typedef bool NavigatorUserMediaSuccessCallback(LocalMediaStream stream);
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

interface Node extends EventTarget {
  NodeList get nodes();

  void set nodes(Collection<Node> value);

  Node replaceWith(Node otherNode);

  Node remove();


  static final int ATTRIBUTE_NODE = 2;

  static final int CDATA_SECTION_NODE = 4;

  static final int COMMENT_NODE = 8;

  static final int DOCUMENT_FRAGMENT_NODE = 11;

  static final int DOCUMENT_NODE = 9;

  static final int DOCUMENT_POSITION_CONTAINED_BY = 0x10;

  static final int DOCUMENT_POSITION_CONTAINS = 0x08;

  static final int DOCUMENT_POSITION_DISCONNECTED = 0x01;

  static final int DOCUMENT_POSITION_FOLLOWING = 0x04;

  static final int DOCUMENT_POSITION_IMPLEMENTATION_SPECIFIC = 0x20;

  static final int DOCUMENT_POSITION_PRECEDING = 0x02;

  static final int DOCUMENT_TYPE_NODE = 10;

  static final int ELEMENT_NODE = 1;

  static final int ENTITY_NODE = 6;

  static final int ENTITY_REFERENCE_NODE = 5;

  static final int NOTATION_NODE = 12;

  static final int PROCESSING_INSTRUCTION_NODE = 7;

  static final int TEXT_NODE = 3;

  final Node nextNode;

  final Document document;

  final Node parent;

  final Node previousNode;

  String text;

  Node clone(bool deep);

  bool contains(Node other);

  bool hasChildNodes();

  Node insertBefore(Node newChild, Node refChild);

}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

interface NodeFilter {

  static final int FILTER_ACCEPT = 1;

  static final int FILTER_REJECT = 2;

  static final int FILTER_SKIP = 3;

  static final int SHOW_ALL = 0xFFFFFFFF;

  static final int SHOW_ATTRIBUTE = 0x00000002;

  static final int SHOW_CDATA_SECTION = 0x00000008;

  static final int SHOW_COMMENT = 0x00000080;

  static final int SHOW_DOCUMENT = 0x00000100;

  static final int SHOW_DOCUMENT_FRAGMENT = 0x00000400;

  static final int SHOW_DOCUMENT_TYPE = 0x00000200;

  static final int SHOW_ELEMENT = 0x00000001;

  static final int SHOW_ENTITY = 0x00000020;

  static final int SHOW_ENTITY_REFERENCE = 0x00000010;

  static final int SHOW_NOTATION = 0x00000800;

  static final int SHOW_PROCESSING_INSTRUCTION = 0x00000040;

  static final int SHOW_TEXT = 0x00000004;

  int acceptNode(Node n);
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

interface NodeIterator {

  final bool expandEntityReferences;

  final NodeFilter filter;

  final bool pointerBeforeReferenceNode;

  final Node referenceNode;

  final Node root;

  final int whatToShow;

  void detach();

  Node nextNode();

  Node previousNode();
}
// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

interface NodeList extends List<Node> {

  NodeList filter(bool f(Node element));

  NodeList getRange(int start, int length);

  Node get first();


  final int length;

}
// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

interface NodeSelector {

  // TODO(nweiz): add this back once DocumentFragment is ported.
  // ElementList queryAll(String selectors);


  Element query(String selectors);

}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

interface Notation extends Node {

  final String publicId;

  final String systemId;
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

interface Notification extends EventTarget {

  NotificationEvents get on();

  String dir;

  String replaceId;

  void cancel();

  void show();
}

interface NotificationEvents extends Events {

  EventListenerList get click();

  EventListenerList get close();

  EventListenerList get error();

  EventListenerList get show();
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

interface NotificationCenter {

  int checkPermission();

  Notification createHTMLNotification(String url);

  Notification createNotification(String iconUrl, String title, String body);

  void requestPermission(VoidCallback callback);
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

interface OESStandardDerivatives {

  static final int FRAGMENT_SHADER_DERIVATIVE_HINT_OES = 0x8B8B;
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

interface OESTextureFloat {
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

interface OESVertexArrayObject {

  static final int VERTEX_ARRAY_BINDING_OES = 0x85B5;

  void bindVertexArrayOES(WebGLVertexArrayObjectOES arrayObject);

  WebGLVertexArrayObjectOES createVertexArrayOES();

  void deleteVertexArrayOES(WebGLVertexArrayObjectOES arrayObject);

  bool isVertexArrayOES(WebGLVertexArrayObjectOES arrayObject);
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

interface OListElement extends Element {

  bool compact;

  bool reversed;

  int start;

  String type;
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

interface ObjectElement extends Element {

  String align;

  String archive;

  String border;

  String code;

  String codeBase;

  String codeType;

  final Document contentDocument;

  String data;

  bool declare;

  final FormElement form;

  String height;

  int hspace;

  String name;

  String standby;

  String type;

  String useMap;

  final String validationMessage;

  final ValidityState validity;

  int vspace;

  String width;

  final bool willValidate;

  bool checkValidity();

  void setCustomValidity(String error);
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

interface OfflineAudioCompletionEvent extends Event {

  final AudioBuffer renderedBuffer;
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

interface OperationNotAllowedException {

  static final int NOT_ALLOWED_ERR = 1;

  final int code;

  final String message;

  final String name;

  String toString();
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

interface OptGroupElement extends Element {

  bool disabled;

  String label;
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

interface OptionElement extends Element default _OptionElementFactoryProvider {

  OptionElement([String data, String value, bool defaultSelected, bool selected]);

  bool defaultSelected;

  bool disabled;

  final FormElement form;

  final int index;

  String label;

  bool selected;

  String value;
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

interface OutputElement extends Element {

  String defaultValue;

  final FormElement form;

  DOMSettableTokenList htmlFor;

  final NodeList labels;

  String name;

  final String type;

  final String validationMessage;

  final ValidityState validity;

  String value;

  final bool willValidate;

  bool checkValidity();

  void setCustomValidity(String error);
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

interface OverflowEvent extends Event {

  static final int BOTH = 2;

  static final int HORIZONTAL = 0;

  static final int VERTICAL = 1;

  final bool horizontalOverflow;

  final int orient;

  final bool verticalOverflow;
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

interface PageTransitionEvent extends Event {

  final bool persisted;
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

interface ParagraphElement extends Element {

  String align;
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

interface ParamElement extends Element {

  String name;

  String type;

  String value;

  String valueType;
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

interface Performance {

  final MemoryInfo memory;

  final PerformanceNavigation navigation;

  final PerformanceTiming timing;
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

interface PerformanceNavigation {

  static final int TYPE_BACK_FORWARD = 2;

  static final int TYPE_NAVIGATE = 0;

  static final int TYPE_RELOAD = 1;

  static final int TYPE_RESERVED = 255;

  final int redirectCount;

  final int type;
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

interface PerformanceTiming {

  final int connectEnd;

  final int connectStart;

  final int domComplete;

  final int domContentLoadedEventEnd;

  final int domContentLoadedEventStart;

  final int domInteractive;

  final int domLoading;

  final int domainLookupEnd;

  final int domainLookupStart;

  final int fetchStart;

  final int loadEventEnd;

  final int loadEventStart;

  final int navigationStart;

  final int redirectEnd;

  final int redirectStart;

  final int requestStart;

  final int responseEnd;

  final int responseStart;

  final int secureConnectionStart;

  final int unloadEventEnd;

  final int unloadEventStart;
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

interface Point default _PointFactoryProvider {

  Point(num x, num y);

  num x;

  num y;
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

interface PopStateEvent extends Event {

  final Object state;
}
// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

typedef bool PositionCallback(Geoposition position);
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

interface PositionError {

  static final int PERMISSION_DENIED = 1;

  static final int POSITION_UNAVAILABLE = 2;

  static final int TIMEOUT = 3;

  final int code;

  final String message;
}
// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

typedef bool PositionErrorCallback(PositionError error);
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

interface PreElement extends Element {

  int width;

  bool wrap;
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

interface ProcessingInstruction extends Node {

  String data;

  final StyleSheet sheet;

  final String target;
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

interface ProgressElement extends Element {

  final NodeList labels;

  num max;

  final num position;

  num value;
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

interface ProgressEvent extends Event {

  final bool lengthComputable;

  final int loaded;

  final int total;
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

interface QuoteElement extends Element {

  String cite;
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

interface RGBColor {

  final CSSPrimitiveValue blue;

  final CSSPrimitiveValue green;

  final CSSPrimitiveValue red;
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

interface Range {

  static final int END_TO_END = 2;

  static final int END_TO_START = 3;

  static final int NODE_AFTER = 1;

  static final int NODE_BEFORE = 0;

  static final int NODE_BEFORE_AND_AFTER = 2;

  static final int NODE_INSIDE = 3;

  static final int START_TO_END = 1;

  static final int START_TO_START = 0;

  final bool collapsed;

  final Node commonAncestorContainer;

  final Node endContainer;

  final int endOffset;

  final Node startContainer;

  final int startOffset;

  DocumentFragment cloneContents();

  Range cloneRange();

  void collapse(bool toStart);

  int compareNode(Node refNode);

  int comparePoint(Node refNode, int offset);

  DocumentFragment createContextualFragment(String html);

  void deleteContents();

  void detach();

  void expand(String unit);

  DocumentFragment extractContents();

  ClientRect getBoundingClientRect();

  ClientRectList getClientRects();

  void insertNode(Node newNode);

  bool intersectsNode(Node refNode);

  bool isPointInRange(Node refNode, int offset);

  void selectNode(Node refNode);

  void selectNodeContents(Node refNode);

  void setEnd(Node refNode, int offset);

  void setEndAfter(Node refNode);

  void setEndBefore(Node refNode);

  void setStart(Node refNode, int offset);

  void setStartAfter(Node refNode);

  void setStartBefore(Node refNode);

  void surroundContents(Node newParent);

  String toString();
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

interface RangeException {

  static final int BAD_BOUNDARYPOINTS_ERR = 1;

  static final int INVALID_NODE_TYPE_ERR = 2;

  final int code;

  final String message;

  final String name;

  String toString();
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

interface RealtimeAnalyserNode extends AudioNode {

  int fftSize;

  final int frequencyBinCount;

  num maxDecibels;

  num minDecibels;

  num smoothingTimeConstant;

  void getByteFrequencyData(Uint8Array array);

  void getByteTimeDomainData(Uint8Array array);

  void getFloatFrequencyData(Float32Array array);
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

interface Rect {

  final CSSPrimitiveValue bottom;

  final CSSPrimitiveValue left;

  final CSSPrimitiveValue right;

  final CSSPrimitiveValue top;
}
// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

typedef bool RequestAnimationFrameCallback(int time);
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

interface SQLError {

  static final int CONSTRAINT_ERR = 6;

  static final int DATABASE_ERR = 1;

  static final int QUOTA_ERR = 4;

  static final int SYNTAX_ERR = 5;

  static final int TIMEOUT_ERR = 7;

  static final int TOO_LARGE_ERR = 3;

  static final int UNKNOWN_ERR = 0;

  static final int VERSION_ERR = 2;

  final int code;

  final String message;
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

interface SQLException {

  static final int CONSTRAINT_ERR = 6;

  static final int DATABASE_ERR = 1;

  static final int QUOTA_ERR = 4;

  static final int SYNTAX_ERR = 5;

  static final int TIMEOUT_ERR = 7;

  static final int TOO_LARGE_ERR = 3;

  static final int UNKNOWN_ERR = 0;

  static final int VERSION_ERR = 2;

  final int code;

  final String message;
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

interface SQLResultSet {

  final int insertId;

  final SQLResultSetRowList rows;

  final int rowsAffected;
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

interface SQLResultSetRowList {

  final int length;

  Object item(int index);
}
// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

typedef bool SQLStatementCallback(SQLTransaction transaction, SQLResultSet resultSet);
// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

typedef bool SQLStatementErrorCallback(SQLTransaction transaction, SQLError error);
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

interface SQLTransaction {
}
// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

typedef bool SQLTransactionCallback(SQLTransaction transaction);
// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

typedef bool SQLTransactionErrorCallback(SQLError error);
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

interface SQLTransactionSync {
}
// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

typedef bool SQLTransactionSyncCallback(SQLTransactionSync transaction);
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

interface SVGAElement extends SVGElement, SVGURIReference, SVGTests, SVGLangSpace, SVGExternalResourcesRequired, SVGStylable, SVGTransformable {

  final SVGAnimatedString target;
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

interface SVGAltGlyphDefElement extends SVGElement {
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

interface SVGAltGlyphElement extends SVGTextPositioningElement, SVGURIReference {

  String format;

  String glyphRef;
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

interface SVGAltGlyphItemElement extends SVGElement {
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

interface SVGAngle {

  static final int SVG_ANGLETYPE_DEG = 2;

  static final int SVG_ANGLETYPE_GRAD = 4;

  static final int SVG_ANGLETYPE_RAD = 3;

  static final int SVG_ANGLETYPE_UNKNOWN = 0;

  static final int SVG_ANGLETYPE_UNSPECIFIED = 1;

  final int unitType;

  num value;

  String valueAsString;

  num valueInSpecifiedUnits;

  void convertToSpecifiedUnits(int unitType);

  void newValueSpecifiedUnits(int unitType, num valueInSpecifiedUnits);
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

interface SVGAnimateColorElement extends SVGAnimationElement {
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

interface SVGAnimateElement extends SVGAnimationElement {
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

interface SVGAnimateMotionElement extends SVGAnimationElement {
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

interface SVGAnimateTransformElement extends SVGAnimationElement {
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

interface SVGAnimatedAngle {

  final SVGAngle animVal;

  final SVGAngle baseVal;
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

interface SVGAnimatedBoolean {

  final bool animVal;

  bool baseVal;
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

interface SVGAnimatedEnumeration {

  final int animVal;

  int baseVal;
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

interface SVGAnimatedInteger {

  final int animVal;

  int baseVal;
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

interface SVGAnimatedLength {

  final SVGLength animVal;

  final SVGLength baseVal;
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

interface SVGAnimatedLengthList {

  final SVGLengthList animVal;

  final SVGLengthList baseVal;
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

interface SVGAnimatedNumber {

  final num animVal;

  num baseVal;
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

interface SVGAnimatedNumberList {

  final SVGNumberList animVal;

  final SVGNumberList baseVal;
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

interface SVGAnimatedPreserveAspectRatio {

  final SVGPreserveAspectRatio animVal;

  final SVGPreserveAspectRatio baseVal;
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

interface SVGAnimatedRect {

  final SVGRect animVal;

  final SVGRect baseVal;
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

interface SVGAnimatedString {

  final String animVal;

  String baseVal;
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

interface SVGAnimatedTransformList {

  final SVGTransformList animVal;

  final SVGTransformList baseVal;
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

interface SVGAnimationElement extends SVGElement, SVGTests, SVGExternalResourcesRequired, ElementTimeControl {

  final SVGElement targetElement;

  num getCurrentTime();

  num getSimpleDuration();

  num getStartTime();
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

interface SVGCircleElement extends SVGElement, SVGTests, SVGLangSpace, SVGExternalResourcesRequired, SVGStylable, SVGTransformable {

  final SVGAnimatedLength cx;

  final SVGAnimatedLength cy;

  final SVGAnimatedLength r;
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

interface SVGClipPathElement extends SVGElement, SVGTests, SVGLangSpace, SVGExternalResourcesRequired, SVGStylable, SVGTransformable {

  final SVGAnimatedEnumeration clipPathUnits;
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

interface SVGColor extends CSSValue {

  static final int SVG_COLORTYPE_CURRENTCOLOR = 3;

  static final int SVG_COLORTYPE_RGBCOLOR = 1;

  static final int SVG_COLORTYPE_RGBCOLOR_ICCCOLOR = 2;

  static final int SVG_COLORTYPE_UNKNOWN = 0;

  final int colorType;

  final RGBColor rgbColor;

  void setColor(int colorType, String rgbColor, String iccColor);

  void setRGBColor(String rgbColor);

  void setRGBColorICCColor(String rgbColor, String iccColor);
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

interface SVGComponentTransferFunctionElement extends SVGElement {

  static final int SVG_FECOMPONENTTRANSFER_TYPE_DISCRETE = 3;

  static final int SVG_FECOMPONENTTRANSFER_TYPE_GAMMA = 5;

  static final int SVG_FECOMPONENTTRANSFER_TYPE_IDENTITY = 1;

  static final int SVG_FECOMPONENTTRANSFER_TYPE_LINEAR = 4;

  static final int SVG_FECOMPONENTTRANSFER_TYPE_TABLE = 2;

  static final int SVG_FECOMPONENTTRANSFER_TYPE_UNKNOWN = 0;

  final SVGAnimatedNumber amplitude;

  final SVGAnimatedNumber exponent;

  final SVGAnimatedNumber intercept;

  final SVGAnimatedNumber offset;

  final SVGAnimatedNumber slope;

  final SVGAnimatedNumberList tableValues;

  final SVGAnimatedEnumeration type;
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

interface SVGCursorElement extends SVGElement, SVGURIReference, SVGTests, SVGExternalResourcesRequired {

  final SVGAnimatedLength x;

  final SVGAnimatedLength y;
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

interface SVGDefsElement extends SVGElement, SVGTests, SVGLangSpace, SVGExternalResourcesRequired, SVGStylable, SVGTransformable {
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

interface SVGDescElement extends SVGElement, SVGLangSpace, SVGStylable {
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

interface SVGDocument extends Document {

  final SVGSVGElement rootElement;
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

interface SVGElement extends Element default _SVGElementFactoryProvider {

  SVGElement.tag(String tag);
  SVGElement.svg(String svg);

  SVGElement clone(bool deep);


  String id;

  final SVGSVGElement ownerSVGElement;

  final SVGElement viewportElement;

  String xmlbase;

}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

interface SVGElementInstance extends EventTarget {

  SVGElementInstanceEvents get on();

  final SVGElementInstanceList childNodes;

  final SVGElement correspondingElement;

  final SVGUseElement correspondingUseElement;

  final SVGElementInstance firstChild;

  final SVGElementInstance lastChild;

  final SVGElementInstance nextSibling;

  final SVGElementInstance parentNode;

  final SVGElementInstance previousSibling;
}

interface SVGElementInstanceEvents extends Events {

  EventListenerList get abort();

  EventListenerList get beforeCopy();

  EventListenerList get beforeCut();

  EventListenerList get beforePaste();

  EventListenerList get blur();

  EventListenerList get change();

  EventListenerList get click();

  EventListenerList get contextMenu();

  EventListenerList get copy();

  EventListenerList get cut();

  EventListenerList get doubleClick();

  EventListenerList get drag();

  EventListenerList get dragEnd();

  EventListenerList get dragEnter();

  EventListenerList get dragLeave();

  EventListenerList get dragOver();

  EventListenerList get dragStart();

  EventListenerList get drop();

  EventListenerList get error();

  EventListenerList get focus();

  EventListenerList get input();

  EventListenerList get keyDown();

  EventListenerList get keyPress();

  EventListenerList get keyUp();

  EventListenerList get load();

  EventListenerList get mouseDown();

  EventListenerList get mouseMove();

  EventListenerList get mouseOut();

  EventListenerList get mouseOver();

  EventListenerList get mouseUp();

  EventListenerList get mouseWheel();

  EventListenerList get paste();

  EventListenerList get reset();

  EventListenerList get resize();

  EventListenerList get scroll();

  EventListenerList get search();

  EventListenerList get select();

  EventListenerList get selectStart();

  EventListenerList get submit();

  EventListenerList get unload();
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

interface SVGElementInstanceList {

  final int length;

  SVGElementInstance item(int index);
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

interface SVGEllipseElement extends SVGElement, SVGTests, SVGLangSpace, SVGExternalResourcesRequired, SVGStylable, SVGTransformable {

  final SVGAnimatedLength cx;

  final SVGAnimatedLength cy;

  final SVGAnimatedLength rx;

  final SVGAnimatedLength ry;
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

interface SVGException {

  static final int SVG_INVALID_VALUE_ERR = 1;

  static final int SVG_MATRIX_NOT_INVERTABLE = 2;

  static final int SVG_WRONG_TYPE_ERR = 0;

  final int code;

  final String message;

  final String name;

  String toString();
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

interface SVGExternalResourcesRequired {

  final SVGAnimatedBoolean externalResourcesRequired;
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

interface SVGFEBlendElement extends SVGElement, SVGFilterPrimitiveStandardAttributes {

  static final int SVG_FEBLEND_MODE_DARKEN = 4;

  static final int SVG_FEBLEND_MODE_LIGHTEN = 5;

  static final int SVG_FEBLEND_MODE_MULTIPLY = 2;

  static final int SVG_FEBLEND_MODE_NORMAL = 1;

  static final int SVG_FEBLEND_MODE_SCREEN = 3;

  static final int SVG_FEBLEND_MODE_UNKNOWN = 0;

  final SVGAnimatedString in1;

  final SVGAnimatedString in2;

  final SVGAnimatedEnumeration mode;
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

interface SVGFEColorMatrixElement extends SVGElement, SVGFilterPrimitiveStandardAttributes {

  static final int SVG_FECOLORMATRIX_TYPE_HUEROTATE = 3;

  static final int SVG_FECOLORMATRIX_TYPE_LUMINANCETOALPHA = 4;

  static final int SVG_FECOLORMATRIX_TYPE_MATRIX = 1;

  static final int SVG_FECOLORMATRIX_TYPE_SATURATE = 2;

  static final int SVG_FECOLORMATRIX_TYPE_UNKNOWN = 0;

  final SVGAnimatedString in1;

  final SVGAnimatedEnumeration type;

  final SVGAnimatedNumberList values;
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

interface SVGFEComponentTransferElement extends SVGElement, SVGFilterPrimitiveStandardAttributes {

  final SVGAnimatedString in1;
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

interface SVGFECompositeElement extends SVGElement, SVGFilterPrimitiveStandardAttributes {

  static final int SVG_FECOMPOSITE_OPERATOR_ARITHMETIC = 6;

  static final int SVG_FECOMPOSITE_OPERATOR_ATOP = 4;

  static final int SVG_FECOMPOSITE_OPERATOR_IN = 2;

  static final int SVG_FECOMPOSITE_OPERATOR_OUT = 3;

  static final int SVG_FECOMPOSITE_OPERATOR_OVER = 1;

  static final int SVG_FECOMPOSITE_OPERATOR_UNKNOWN = 0;

  static final int SVG_FECOMPOSITE_OPERATOR_XOR = 5;

  final SVGAnimatedString in1;

  final SVGAnimatedString in2;

  final SVGAnimatedNumber k1;

  final SVGAnimatedNumber k2;

  final SVGAnimatedNumber k3;

  final SVGAnimatedNumber k4;

  final SVGAnimatedEnumeration operator;
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

interface SVGFEConvolveMatrixElement extends SVGElement, SVGFilterPrimitiveStandardAttributes {

  static final int SVG_EDGEMODE_DUPLICATE = 1;

  static final int SVG_EDGEMODE_NONE = 3;

  static final int SVG_EDGEMODE_UNKNOWN = 0;

  static final int SVG_EDGEMODE_WRAP = 2;

  final SVGAnimatedNumber bias;

  final SVGAnimatedNumber divisor;

  final SVGAnimatedEnumeration edgeMode;

  final SVGAnimatedString in1;

  final SVGAnimatedNumberList kernelMatrix;

  final SVGAnimatedNumber kernelUnitLengthX;

  final SVGAnimatedNumber kernelUnitLengthY;

  final SVGAnimatedInteger orderX;

  final SVGAnimatedInteger orderY;

  final SVGAnimatedBoolean preserveAlpha;

  final SVGAnimatedInteger targetX;

  final SVGAnimatedInteger targetY;
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

interface SVGFEDiffuseLightingElement extends SVGElement, SVGFilterPrimitiveStandardAttributes {

  final SVGAnimatedNumber diffuseConstant;

  final SVGAnimatedString in1;

  final SVGAnimatedNumber kernelUnitLengthX;

  final SVGAnimatedNumber kernelUnitLengthY;

  final SVGAnimatedNumber surfaceScale;
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

interface SVGFEDisplacementMapElement extends SVGElement, SVGFilterPrimitiveStandardAttributes {

  static final int SVG_CHANNEL_A = 4;

  static final int SVG_CHANNEL_B = 3;

  static final int SVG_CHANNEL_G = 2;

  static final int SVG_CHANNEL_R = 1;

  static final int SVG_CHANNEL_UNKNOWN = 0;

  final SVGAnimatedString in1;

  final SVGAnimatedString in2;

  final SVGAnimatedNumber scale;

  final SVGAnimatedEnumeration xChannelSelector;

  final SVGAnimatedEnumeration yChannelSelector;
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

interface SVGFEDistantLightElement extends SVGElement {

  final SVGAnimatedNumber azimuth;

  final SVGAnimatedNumber elevation;
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

interface SVGFEDropShadowElement extends SVGElement, SVGFilterPrimitiveStandardAttributes {

  final SVGAnimatedNumber dx;

  final SVGAnimatedNumber dy;

  final SVGAnimatedString in1;

  final SVGAnimatedNumber stdDeviationX;

  final SVGAnimatedNumber stdDeviationY;

  void setStdDeviation(num stdDeviationX, num stdDeviationY);
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

interface SVGFEFloodElement extends SVGElement, SVGFilterPrimitiveStandardAttributes {
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

interface SVGFEFuncAElement extends SVGComponentTransferFunctionElement {
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

interface SVGFEFuncBElement extends SVGComponentTransferFunctionElement {
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

interface SVGFEFuncGElement extends SVGComponentTransferFunctionElement {
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

interface SVGFEFuncRElement extends SVGComponentTransferFunctionElement {
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

interface SVGFEGaussianBlurElement extends SVGElement, SVGFilterPrimitiveStandardAttributes {

  final SVGAnimatedString in1;

  final SVGAnimatedNumber stdDeviationX;

  final SVGAnimatedNumber stdDeviationY;

  void setStdDeviation(num stdDeviationX, num stdDeviationY);
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

interface SVGFEImageElement extends SVGElement, SVGURIReference, SVGLangSpace, SVGExternalResourcesRequired, SVGFilterPrimitiveStandardAttributes {

  final SVGAnimatedPreserveAspectRatio preserveAspectRatio;
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

interface SVGFEMergeElement extends SVGElement, SVGFilterPrimitiveStandardAttributes {
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

interface SVGFEMergeNodeElement extends SVGElement {

  final SVGAnimatedString in1;
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

interface SVGFEMorphologyElement extends SVGElement, SVGFilterPrimitiveStandardAttributes {

  static final int SVG_MORPHOLOGY_OPERATOR_DILATE = 2;

  static final int SVG_MORPHOLOGY_OPERATOR_ERODE = 1;

  static final int SVG_MORPHOLOGY_OPERATOR_UNKNOWN = 0;

  final SVGAnimatedString in1;

  final SVGAnimatedEnumeration operator;

  final SVGAnimatedNumber radiusX;

  final SVGAnimatedNumber radiusY;

  void setRadius(num radiusX, num radiusY);
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

interface SVGFEOffsetElement extends SVGElement, SVGFilterPrimitiveStandardAttributes {

  final SVGAnimatedNumber dx;

  final SVGAnimatedNumber dy;

  final SVGAnimatedString in1;
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

interface SVGFEPointLightElement extends SVGElement {

  final SVGAnimatedNumber x;

  final SVGAnimatedNumber y;

  final SVGAnimatedNumber z;
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

interface SVGFESpecularLightingElement extends SVGElement, SVGFilterPrimitiveStandardAttributes {

  final SVGAnimatedString in1;

  final SVGAnimatedNumber specularConstant;

  final SVGAnimatedNumber specularExponent;

  final SVGAnimatedNumber surfaceScale;
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

interface SVGFESpotLightElement extends SVGElement {

  final SVGAnimatedNumber limitingConeAngle;

  final SVGAnimatedNumber pointsAtX;

  final SVGAnimatedNumber pointsAtY;

  final SVGAnimatedNumber pointsAtZ;

  final SVGAnimatedNumber specularExponent;

  final SVGAnimatedNumber x;

  final SVGAnimatedNumber y;

  final SVGAnimatedNumber z;
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

interface SVGFETileElement extends SVGElement, SVGFilterPrimitiveStandardAttributes {

  final SVGAnimatedString in1;
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

interface SVGFETurbulenceElement extends SVGElement, SVGFilterPrimitiveStandardAttributes {

  static final int SVG_STITCHTYPE_NOSTITCH = 2;

  static final int SVG_STITCHTYPE_STITCH = 1;

  static final int SVG_STITCHTYPE_UNKNOWN = 0;

  static final int SVG_TURBULENCE_TYPE_FRACTALNOISE = 1;

  static final int SVG_TURBULENCE_TYPE_TURBULENCE = 2;

  static final int SVG_TURBULENCE_TYPE_UNKNOWN = 0;

  final SVGAnimatedNumber baseFrequencyX;

  final SVGAnimatedNumber baseFrequencyY;

  final SVGAnimatedInteger numOctaves;

  final SVGAnimatedNumber seed;

  final SVGAnimatedEnumeration stitchTiles;

  final SVGAnimatedEnumeration type;
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

interface SVGFilterElement extends SVGElement, SVGURIReference, SVGLangSpace, SVGExternalResourcesRequired, SVGStylable {

  final SVGAnimatedInteger filterResX;

  final SVGAnimatedInteger filterResY;

  final SVGAnimatedEnumeration filterUnits;

  final SVGAnimatedLength height;

  final SVGAnimatedEnumeration primitiveUnits;

  final SVGAnimatedLength width;

  final SVGAnimatedLength x;

  final SVGAnimatedLength y;

  void setFilterRes(int filterResX, int filterResY);
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

interface SVGFilterPrimitiveStandardAttributes extends SVGStylable {

  final SVGAnimatedLength height;

  final SVGAnimatedString result;

  final SVGAnimatedLength width;

  final SVGAnimatedLength x;

  final SVGAnimatedLength y;
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

interface SVGFitToViewBox {

  final SVGAnimatedPreserveAspectRatio preserveAspectRatio;

  final SVGAnimatedRect viewBox;
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

interface SVGFontElement extends SVGElement {
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

interface SVGFontFaceElement extends SVGElement {
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

interface SVGFontFaceFormatElement extends SVGElement {
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

interface SVGFontFaceNameElement extends SVGElement {
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

interface SVGFontFaceSrcElement extends SVGElement {
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

interface SVGFontFaceUriElement extends SVGElement {
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

interface SVGForeignObjectElement extends SVGElement, SVGTests, SVGLangSpace, SVGExternalResourcesRequired, SVGStylable, SVGTransformable {

  final SVGAnimatedLength height;

  final SVGAnimatedLength width;

  final SVGAnimatedLength x;

  final SVGAnimatedLength y;
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

interface SVGGElement extends SVGElement, SVGTests, SVGLangSpace, SVGExternalResourcesRequired, SVGStylable, SVGTransformable {
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

interface SVGGlyphElement extends SVGElement {
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

interface SVGGlyphRefElement extends SVGElement, SVGURIReference, SVGStylable {

  num dx;

  num dy;

  String format;

  String glyphRef;

  num x;

  num y;
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

interface SVGGradientElement extends SVGElement, SVGURIReference, SVGExternalResourcesRequired, SVGStylable {

  static final int SVG_SPREADMETHOD_PAD = 1;

  static final int SVG_SPREADMETHOD_REFLECT = 2;

  static final int SVG_SPREADMETHOD_REPEAT = 3;

  static final int SVG_SPREADMETHOD_UNKNOWN = 0;

  final SVGAnimatedTransformList gradientTransform;

  final SVGAnimatedEnumeration gradientUnits;

  final SVGAnimatedEnumeration spreadMethod;
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

interface SVGHKernElement extends SVGElement {
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

interface SVGImageElement extends SVGElement, SVGURIReference, SVGTests, SVGLangSpace, SVGExternalResourcesRequired, SVGStylable, SVGTransformable {

  final SVGAnimatedLength height;

  final SVGAnimatedPreserveAspectRatio preserveAspectRatio;

  final SVGAnimatedLength width;

  final SVGAnimatedLength x;

  final SVGAnimatedLength y;
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

interface SVGLangSpace {

  String xmllang;

  String xmlspace;
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

interface SVGLength {

  static final int SVG_LENGTHTYPE_CM = 6;

  static final int SVG_LENGTHTYPE_EMS = 3;

  static final int SVG_LENGTHTYPE_EXS = 4;

  static final int SVG_LENGTHTYPE_IN = 8;

  static final int SVG_LENGTHTYPE_MM = 7;

  static final int SVG_LENGTHTYPE_NUMBER = 1;

  static final int SVG_LENGTHTYPE_PC = 10;

  static final int SVG_LENGTHTYPE_PERCENTAGE = 2;

  static final int SVG_LENGTHTYPE_PT = 9;

  static final int SVG_LENGTHTYPE_PX = 5;

  static final int SVG_LENGTHTYPE_UNKNOWN = 0;

  final int unitType;

  num value;

  String valueAsString;

  num valueInSpecifiedUnits;

  void convertToSpecifiedUnits(int unitType);

  void newValueSpecifiedUnits(int unitType, num valueInSpecifiedUnits);
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

interface SVGLengthList {

  final int numberOfItems;

  SVGLength appendItem(SVGLength item);

  void clear();

  SVGLength getItem(int index);

  SVGLength initialize(SVGLength item);

  SVGLength insertItemBefore(SVGLength item, int index);

  SVGLength removeItem(int index);

  SVGLength replaceItem(SVGLength item, int index);
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

interface SVGLineElement extends SVGElement, SVGTests, SVGLangSpace, SVGExternalResourcesRequired, SVGStylable, SVGTransformable {

  final SVGAnimatedLength x1;

  final SVGAnimatedLength x2;

  final SVGAnimatedLength y1;

  final SVGAnimatedLength y2;
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

interface SVGLinearGradientElement extends SVGGradientElement {

  final SVGAnimatedLength x1;

  final SVGAnimatedLength x2;

  final SVGAnimatedLength y1;

  final SVGAnimatedLength y2;
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

interface SVGLocatable {

  final SVGElement farthestViewportElement;

  final SVGElement nearestViewportElement;

  SVGRect getBBox();

  SVGMatrix getCTM();

  SVGMatrix getScreenCTM();

  SVGMatrix getTransformToElement(SVGElement element);
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

interface SVGMPathElement extends SVGElement, SVGURIReference, SVGExternalResourcesRequired {
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

interface SVGMarkerElement extends SVGElement, SVGLangSpace, SVGExternalResourcesRequired, SVGStylable, SVGFitToViewBox {

  static final int SVG_MARKERUNITS_STROKEWIDTH = 2;

  static final int SVG_MARKERUNITS_UNKNOWN = 0;

  static final int SVG_MARKERUNITS_USERSPACEONUSE = 1;

  static final int SVG_MARKER_ORIENT_ANGLE = 2;

  static final int SVG_MARKER_ORIENT_AUTO = 1;

  static final int SVG_MARKER_ORIENT_UNKNOWN = 0;

  final SVGAnimatedLength markerHeight;

  final SVGAnimatedEnumeration markerUnits;

  final SVGAnimatedLength markerWidth;

  final SVGAnimatedAngle orientAngle;

  final SVGAnimatedEnumeration orientType;

  final SVGAnimatedLength refX;

  final SVGAnimatedLength refY;

  void setOrientToAngle(SVGAngle angle);

  void setOrientToAuto();
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

interface SVGMaskElement extends SVGElement, SVGTests, SVGLangSpace, SVGExternalResourcesRequired, SVGStylable {

  final SVGAnimatedLength height;

  final SVGAnimatedEnumeration maskContentUnits;

  final SVGAnimatedEnumeration maskUnits;

  final SVGAnimatedLength width;

  final SVGAnimatedLength x;

  final SVGAnimatedLength y;
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

interface SVGMatrix {

  num a;

  num b;

  num c;

  num d;

  num e;

  num f;

  SVGMatrix flipX();

  SVGMatrix flipY();

  SVGMatrix inverse();

  SVGMatrix multiply(SVGMatrix secondMatrix);

  SVGMatrix rotate(num angle);

  SVGMatrix rotateFromVector(num x, num y);

  SVGMatrix scale(num scaleFactor);

  SVGMatrix scaleNonUniform(num scaleFactorX, num scaleFactorY);

  SVGMatrix skewX(num angle);

  SVGMatrix skewY(num angle);

  SVGMatrix translate(num x, num y);
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

interface SVGMetadataElement extends SVGElement {
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

interface SVGMissingGlyphElement extends SVGElement {
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

interface SVGNumber {

  num value;
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

interface SVGNumberList {

  final int numberOfItems;

  SVGNumber appendItem(SVGNumber item);

  void clear();

  SVGNumber getItem(int index);

  SVGNumber initialize(SVGNumber item);

  SVGNumber insertItemBefore(SVGNumber item, int index);

  SVGNumber removeItem(int index);

  SVGNumber replaceItem(SVGNumber item, int index);
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

interface SVGPaint extends SVGColor {

  static final int SVG_PAINTTYPE_CURRENTCOLOR = 102;

  static final int SVG_PAINTTYPE_NONE = 101;

  static final int SVG_PAINTTYPE_RGBCOLOR = 1;

  static final int SVG_PAINTTYPE_RGBCOLOR_ICCCOLOR = 2;

  static final int SVG_PAINTTYPE_UNKNOWN = 0;

  static final int SVG_PAINTTYPE_URI = 107;

  static final int SVG_PAINTTYPE_URI_CURRENTCOLOR = 104;

  static final int SVG_PAINTTYPE_URI_NONE = 103;

  static final int SVG_PAINTTYPE_URI_RGBCOLOR = 105;

  static final int SVG_PAINTTYPE_URI_RGBCOLOR_ICCCOLOR = 106;

  final int paintType;

  final String uri;

  void setPaint(int paintType, String uri, String rgbColor, String iccColor);

  void setUri(String uri);
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

interface SVGPathElement extends SVGElement, SVGTests, SVGLangSpace, SVGExternalResourcesRequired, SVGStylable, SVGTransformable {

  final SVGPathSegList animatedNormalizedPathSegList;

  final SVGPathSegList animatedPathSegList;

  final SVGPathSegList normalizedPathSegList;

  final SVGAnimatedNumber pathLength;

  final SVGPathSegList pathSegList;

  SVGPathSegArcAbs createSVGPathSegArcAbs(num x, num y, num r1, num r2, num angle, bool largeArcFlag, bool sweepFlag);

  SVGPathSegArcRel createSVGPathSegArcRel(num x, num y, num r1, num r2, num angle, bool largeArcFlag, bool sweepFlag);

  SVGPathSegClosePath createSVGPathSegClosePath();

  SVGPathSegCurvetoCubicAbs createSVGPathSegCurvetoCubicAbs(num x, num y, num x1, num y1, num x2, num y2);

  SVGPathSegCurvetoCubicRel createSVGPathSegCurvetoCubicRel(num x, num y, num x1, num y1, num x2, num y2);

  SVGPathSegCurvetoCubicSmoothAbs createSVGPathSegCurvetoCubicSmoothAbs(num x, num y, num x2, num y2);

  SVGPathSegCurvetoCubicSmoothRel createSVGPathSegCurvetoCubicSmoothRel(num x, num y, num x2, num y2);

  SVGPathSegCurvetoQuadraticAbs createSVGPathSegCurvetoQuadraticAbs(num x, num y, num x1, num y1);

  SVGPathSegCurvetoQuadraticRel createSVGPathSegCurvetoQuadraticRel(num x, num y, num x1, num y1);

  SVGPathSegCurvetoQuadraticSmoothAbs createSVGPathSegCurvetoQuadraticSmoothAbs(num x, num y);

  SVGPathSegCurvetoQuadraticSmoothRel createSVGPathSegCurvetoQuadraticSmoothRel(num x, num y);

  SVGPathSegLinetoAbs createSVGPathSegLinetoAbs(num x, num y);

  SVGPathSegLinetoHorizontalAbs createSVGPathSegLinetoHorizontalAbs(num x);

  SVGPathSegLinetoHorizontalRel createSVGPathSegLinetoHorizontalRel(num x);

  SVGPathSegLinetoRel createSVGPathSegLinetoRel(num x, num y);

  SVGPathSegLinetoVerticalAbs createSVGPathSegLinetoVerticalAbs(num y);

  SVGPathSegLinetoVerticalRel createSVGPathSegLinetoVerticalRel(num y);

  SVGPathSegMovetoAbs createSVGPathSegMovetoAbs(num x, num y);

  SVGPathSegMovetoRel createSVGPathSegMovetoRel(num x, num y);

  int getPathSegAtLength(num distance);

  SVGPoint getPointAtLength(num distance);

  num getTotalLength();
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

interface SVGPathSeg {

  static final int PATHSEG_ARC_ABS = 10;

  static final int PATHSEG_ARC_REL = 11;

  static final int PATHSEG_CLOSEPATH = 1;

  static final int PATHSEG_CURVETO_CUBIC_ABS = 6;

  static final int PATHSEG_CURVETO_CUBIC_REL = 7;

  static final int PATHSEG_CURVETO_CUBIC_SMOOTH_ABS = 16;

  static final int PATHSEG_CURVETO_CUBIC_SMOOTH_REL = 17;

  static final int PATHSEG_CURVETO_QUADRATIC_ABS = 8;

  static final int PATHSEG_CURVETO_QUADRATIC_REL = 9;

  static final int PATHSEG_CURVETO_QUADRATIC_SMOOTH_ABS = 18;

  static final int PATHSEG_CURVETO_QUADRATIC_SMOOTH_REL = 19;

  static final int PATHSEG_LINETO_ABS = 4;

  static final int PATHSEG_LINETO_HORIZONTAL_ABS = 12;

  static final int PATHSEG_LINETO_HORIZONTAL_REL = 13;

  static final int PATHSEG_LINETO_REL = 5;

  static final int PATHSEG_LINETO_VERTICAL_ABS = 14;

  static final int PATHSEG_LINETO_VERTICAL_REL = 15;

  static final int PATHSEG_MOVETO_ABS = 2;

  static final int PATHSEG_MOVETO_REL = 3;

  static final int PATHSEG_UNKNOWN = 0;

  final int pathSegType;

  final String pathSegTypeAsLetter;
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

interface SVGPathSegArcAbs extends SVGPathSeg {

  num angle;

  bool largeArcFlag;

  num r1;

  num r2;

  bool sweepFlag;

  num x;

  num y;
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

interface SVGPathSegArcRel extends SVGPathSeg {

  num angle;

  bool largeArcFlag;

  num r1;

  num r2;

  bool sweepFlag;

  num x;

  num y;
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

interface SVGPathSegClosePath extends SVGPathSeg {
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

interface SVGPathSegCurvetoCubicAbs extends SVGPathSeg {

  num x;

  num x1;

  num x2;

  num y;

  num y1;

  num y2;
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

interface SVGPathSegCurvetoCubicRel extends SVGPathSeg {

  num x;

  num x1;

  num x2;

  num y;

  num y1;

  num y2;
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

interface SVGPathSegCurvetoCubicSmoothAbs extends SVGPathSeg {

  num x;

  num x2;

  num y;

  num y2;
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

interface SVGPathSegCurvetoCubicSmoothRel extends SVGPathSeg {

  num x;

  num x2;

  num y;

  num y2;
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

interface SVGPathSegCurvetoQuadraticAbs extends SVGPathSeg {

  num x;

  num x1;

  num y;

  num y1;
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

interface SVGPathSegCurvetoQuadraticRel extends SVGPathSeg {

  num x;

  num x1;

  num y;

  num y1;
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

interface SVGPathSegCurvetoQuadraticSmoothAbs extends SVGPathSeg {

  num x;

  num y;
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

interface SVGPathSegCurvetoQuadraticSmoothRel extends SVGPathSeg {

  num x;

  num y;
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

interface SVGPathSegLinetoAbs extends SVGPathSeg {

  num x;

  num y;
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

interface SVGPathSegLinetoHorizontalAbs extends SVGPathSeg {

  num x;
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

interface SVGPathSegLinetoHorizontalRel extends SVGPathSeg {

  num x;
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

interface SVGPathSegLinetoRel extends SVGPathSeg {

  num x;

  num y;
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

interface SVGPathSegLinetoVerticalAbs extends SVGPathSeg {

  num y;
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

interface SVGPathSegLinetoVerticalRel extends SVGPathSeg {

  num y;
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

interface SVGPathSegList {

  final int numberOfItems;

  SVGPathSeg appendItem(SVGPathSeg newItem);

  void clear();

  SVGPathSeg getItem(int index);

  SVGPathSeg initialize(SVGPathSeg newItem);

  SVGPathSeg insertItemBefore(SVGPathSeg newItem, int index);

  SVGPathSeg removeItem(int index);

  SVGPathSeg replaceItem(SVGPathSeg newItem, int index);
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

interface SVGPathSegMovetoAbs extends SVGPathSeg {

  num x;

  num y;
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

interface SVGPathSegMovetoRel extends SVGPathSeg {

  num x;

  num y;
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

interface SVGPatternElement extends SVGElement, SVGURIReference, SVGTests, SVGLangSpace, SVGExternalResourcesRequired, SVGStylable, SVGFitToViewBox {

  final SVGAnimatedLength height;

  final SVGAnimatedEnumeration patternContentUnits;

  final SVGAnimatedTransformList patternTransform;

  final SVGAnimatedEnumeration patternUnits;

  final SVGAnimatedLength width;

  final SVGAnimatedLength x;

  final SVGAnimatedLength y;
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

interface SVGPoint {

  num x;

  num y;

  SVGPoint matrixTransform(SVGMatrix matrix);
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

interface SVGPointList {

  final int numberOfItems;

  SVGPoint appendItem(SVGPoint item);

  void clear();

  SVGPoint getItem(int index);

  SVGPoint initialize(SVGPoint item);

  SVGPoint insertItemBefore(SVGPoint item, int index);

  SVGPoint removeItem(int index);

  SVGPoint replaceItem(SVGPoint item, int index);
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

interface SVGPolygonElement extends SVGElement, SVGTests, SVGLangSpace, SVGExternalResourcesRequired, SVGStylable, SVGTransformable {

  final SVGPointList animatedPoints;

  final SVGPointList points;
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

interface SVGPolylineElement extends SVGElement, SVGTests, SVGLangSpace, SVGExternalResourcesRequired, SVGStylable, SVGTransformable {

  final SVGPointList animatedPoints;

  final SVGPointList points;
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

interface SVGPreserveAspectRatio {

  static final int SVG_MEETORSLICE_MEET = 1;

  static final int SVG_MEETORSLICE_SLICE = 2;

  static final int SVG_MEETORSLICE_UNKNOWN = 0;

  static final int SVG_PRESERVEASPECTRATIO_NONE = 1;

  static final int SVG_PRESERVEASPECTRATIO_UNKNOWN = 0;

  static final int SVG_PRESERVEASPECTRATIO_XMAXYMAX = 10;

  static final int SVG_PRESERVEASPECTRATIO_XMAXYMID = 7;

  static final int SVG_PRESERVEASPECTRATIO_XMAXYMIN = 4;

  static final int SVG_PRESERVEASPECTRATIO_XMIDYMAX = 9;

  static final int SVG_PRESERVEASPECTRATIO_XMIDYMID = 6;

  static final int SVG_PRESERVEASPECTRATIO_XMIDYMIN = 3;

  static final int SVG_PRESERVEASPECTRATIO_XMINYMAX = 8;

  static final int SVG_PRESERVEASPECTRATIO_XMINYMID = 5;

  static final int SVG_PRESERVEASPECTRATIO_XMINYMIN = 2;

  int align;

  int meetOrSlice;
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

interface SVGRadialGradientElement extends SVGGradientElement {

  final SVGAnimatedLength cx;

  final SVGAnimatedLength cy;

  final SVGAnimatedLength fx;

  final SVGAnimatedLength fy;

  final SVGAnimatedLength r;
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

interface SVGRect {

  num height;

  num width;

  num x;

  num y;
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

interface SVGRectElement extends SVGElement, SVGTests, SVGLangSpace, SVGExternalResourcesRequired, SVGStylable, SVGTransformable {

  final SVGAnimatedLength height;

  final SVGAnimatedLength rx;

  final SVGAnimatedLength ry;

  final SVGAnimatedLength width;

  final SVGAnimatedLength x;

  final SVGAnimatedLength y;
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

interface SVGRenderingIntent {

  static final int RENDERING_INTENT_ABSOLUTE_COLORIMETRIC = 5;

  static final int RENDERING_INTENT_AUTO = 1;

  static final int RENDERING_INTENT_PERCEPTUAL = 2;

  static final int RENDERING_INTENT_RELATIVE_COLORIMETRIC = 3;

  static final int RENDERING_INTENT_SATURATION = 4;

  static final int RENDERING_INTENT_UNKNOWN = 0;
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

interface SVGSVGElement extends SVGElement, SVGTests, SVGLangSpace, SVGExternalResourcesRequired, SVGStylable, SVGLocatable, SVGFitToViewBox, SVGZoomAndPan
    default _SVGSVGElementFactoryProvider {
  SVGSVGElement();


  String contentScriptType;

  String contentStyleType;

  num currentScale;

  final SVGPoint currentTranslate;

  final SVGAnimatedLength height;

  final num pixelUnitToMillimeterX;

  final num pixelUnitToMillimeterY;

  final num screenPixelToMillimeterX;

  final num screenPixelToMillimeterY;

  bool useCurrentView;

  final SVGRect viewport;

  final SVGAnimatedLength width;

  final SVGAnimatedLength x;

  final SVGAnimatedLength y;

  bool animationsPaused();

  bool checkEnclosure(SVGElement element, SVGRect rect);

  bool checkIntersection(SVGElement element, SVGRect rect);

  SVGAngle createSVGAngle();

  SVGLength createSVGLength();

  SVGMatrix createSVGMatrix();

  SVGNumber createSVGNumber();

  SVGPoint createSVGPoint();

  SVGRect createSVGRect();

  SVGTransform createSVGTransform();

  SVGTransform createSVGTransformFromMatrix(SVGMatrix matrix);

  void deselectAll();

  void forceRedraw();

  num getCurrentTime();

  Element getElementById(String elementId);

  NodeList getEnclosureList(SVGRect rect, SVGElement referenceElement);

  NodeList getIntersectionList(SVGRect rect, SVGElement referenceElement);

  void pauseAnimations();

  void setCurrentTime(num seconds);

  int suspendRedraw(int maxWaitMilliseconds);

  void unpauseAnimations();

  void unsuspendRedraw(int suspendHandleId);

  void unsuspendRedrawAll();

}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

interface SVGScriptElement extends SVGElement, SVGURIReference, SVGExternalResourcesRequired {

  String type;
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

interface SVGSetElement extends SVGAnimationElement {
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

interface SVGStopElement extends SVGElement, SVGStylable {

  final SVGAnimatedNumber offset;
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

interface SVGStringList {

  final int numberOfItems;

  String appendItem(String item);

  void clear();

  String getItem(int index);

  String initialize(String item);

  String insertItemBefore(String item, int index);

  String removeItem(int index);

  String replaceItem(String item, int index);
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

interface SVGStylable {

  final CSSStyleDeclaration style;

  CSSValue getPresentationAttribute(String name);
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

interface SVGStyleElement extends SVGElement, SVGLangSpace {

  bool disabled;

  String media;

  String title;

  String type;
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

interface SVGSwitchElement extends SVGElement, SVGTests, SVGLangSpace, SVGExternalResourcesRequired, SVGStylable, SVGTransformable {
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

interface SVGSymbolElement extends SVGElement, SVGLangSpace, SVGExternalResourcesRequired, SVGStylable, SVGFitToViewBox {
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

interface SVGTRefElement extends SVGTextPositioningElement, SVGURIReference {
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

interface SVGTSpanElement extends SVGTextPositioningElement {
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

interface SVGTests {

  final SVGStringList requiredExtensions;

  final SVGStringList requiredFeatures;

  final SVGStringList systemLanguage;

  bool hasExtension(String extension);
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

interface SVGTextContentElement extends SVGElement, SVGTests, SVGLangSpace, SVGExternalResourcesRequired, SVGStylable {

  static final int LENGTHADJUST_SPACING = 1;

  static final int LENGTHADJUST_SPACINGANDGLYPHS = 2;

  static final int LENGTHADJUST_UNKNOWN = 0;

  final SVGAnimatedEnumeration lengthAdjust;

  final SVGAnimatedLength textLength;

  int getCharNumAtPosition(SVGPoint point);

  num getComputedTextLength();

  SVGPoint getEndPositionOfChar(int offset);

  SVGRect getExtentOfChar(int offset);

  int getNumberOfChars();

  num getRotationOfChar(int offset);

  SVGPoint getStartPositionOfChar(int offset);

  num getSubStringLength(int offset, int length);

  void selectSubString(int offset, int length);
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

interface SVGTextElement extends SVGTextPositioningElement, SVGTransformable {
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

interface SVGTextPathElement extends SVGTextContentElement, SVGURIReference {

  static final int TEXTPATH_METHODTYPE_ALIGN = 1;

  static final int TEXTPATH_METHODTYPE_STRETCH = 2;

  static final int TEXTPATH_METHODTYPE_UNKNOWN = 0;

  static final int TEXTPATH_SPACINGTYPE_AUTO = 1;

  static final int TEXTPATH_SPACINGTYPE_EXACT = 2;

  static final int TEXTPATH_SPACINGTYPE_UNKNOWN = 0;

  final SVGAnimatedEnumeration method;

  final SVGAnimatedEnumeration spacing;

  final SVGAnimatedLength startOffset;
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

interface SVGTextPositioningElement extends SVGTextContentElement {

  final SVGAnimatedLengthList dx;

  final SVGAnimatedLengthList dy;

  final SVGAnimatedNumberList rotate;

  final SVGAnimatedLengthList x;

  final SVGAnimatedLengthList y;
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

interface SVGTitleElement extends SVGElement, SVGLangSpace, SVGStylable {
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

interface SVGTransform {

  static final int SVG_TRANSFORM_MATRIX = 1;

  static final int SVG_TRANSFORM_ROTATE = 4;

  static final int SVG_TRANSFORM_SCALE = 3;

  static final int SVG_TRANSFORM_SKEWX = 5;

  static final int SVG_TRANSFORM_SKEWY = 6;

  static final int SVG_TRANSFORM_TRANSLATE = 2;

  static final int SVG_TRANSFORM_UNKNOWN = 0;

  final num angle;

  final SVGMatrix matrix;

  final int type;

  void setMatrix(SVGMatrix matrix);

  void setRotate(num angle, num cx, num cy);

  void setScale(num sx, num sy);

  void setSkewX(num angle);

  void setSkewY(num angle);

  void setTranslate(num tx, num ty);
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

interface SVGTransformList {

  final int numberOfItems;

  SVGTransform appendItem(SVGTransform item);

  void clear();

  SVGTransform consolidate();

  SVGTransform createSVGTransformFromMatrix(SVGMatrix matrix);

  SVGTransform getItem(int index);

  SVGTransform initialize(SVGTransform item);

  SVGTransform insertItemBefore(SVGTransform item, int index);

  SVGTransform removeItem(int index);

  SVGTransform replaceItem(SVGTransform item, int index);
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

interface SVGTransformable extends SVGLocatable {

  final SVGAnimatedTransformList transform;
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

interface SVGURIReference {

  final SVGAnimatedString href;
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

interface SVGUnitTypes {

  static final int SVG_UNIT_TYPE_OBJECTBOUNDINGBOX = 2;

  static final int SVG_UNIT_TYPE_UNKNOWN = 0;

  static final int SVG_UNIT_TYPE_USERSPACEONUSE = 1;
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

interface SVGUseElement extends SVGElement, SVGURIReference, SVGTests, SVGLangSpace, SVGExternalResourcesRequired, SVGStylable, SVGTransformable {

  final SVGElementInstance animatedInstanceRoot;

  final SVGAnimatedLength height;

  final SVGElementInstance instanceRoot;

  final SVGAnimatedLength width;

  final SVGAnimatedLength x;

  final SVGAnimatedLength y;
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

interface SVGVKernElement extends SVGElement {
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

interface SVGViewElement extends SVGElement, SVGExternalResourcesRequired, SVGFitToViewBox, SVGZoomAndPan {

  final SVGStringList viewTarget;
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

interface SVGViewSpec extends SVGZoomAndPan, SVGFitToViewBox {

  final String preserveAspectRatioString;

  final SVGTransformList transform;

  final String transformString;

  final String viewBoxString;

  final SVGElement viewTarget;

  final String viewTargetString;
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

interface SVGZoomAndPan {

  static final int SVG_ZOOMANDPAN_DISABLE = 1;

  static final int SVG_ZOOMANDPAN_MAGNIFY = 2;

  static final int SVG_ZOOMANDPAN_UNKNOWN = 0;

  int zoomAndPan;
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

interface SVGZoomEvent extends UIEvent {

  final num newScale;

  final SVGPoint newTranslate;

  final num previousScale;

  final SVGPoint previousTranslate;

  final SVGRect zoomRectScreen;
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

interface Screen {

  final int availHeight;

  final int availLeft;

  final int availTop;

  final int availWidth;

  final int colorDepth;

  final int height;

  final int pixelDepth;

  final int width;
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

interface ScriptElement extends Element {

  bool async;

  String charset;

  String crossOrigin;

  bool defer;

  String event;

  String htmlFor;

  String src;

  String type;
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

interface ScriptProfile {

  final ScriptProfileNode head;

  final String title;

  final int uid;
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

interface ScriptProfileNode {

  final int callUID;

  final List children;

  final String functionName;

  final int lineNumber;

  final int numberOfCalls;

  final num selfTime;

  final num totalTime;

  final String url;

  final bool visible;
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

interface SelectElement extends Element {

  bool autofocus;

  bool disabled;

  final FormElement form;

  final NodeList labels;

  int length;

  bool multiple;

  String name;

  final HTMLOptionsCollection options;

  bool required;

  int selectedIndex;

  final HTMLCollection selectedOptions;

  int size;

  final String type;

  final String validationMessage;

  final ValidityState validity;

  String value;

  final bool willValidate;

  void add(Element element, Element before);

  bool checkValidity();

  Node item(int index);

  Node namedItem(String name);

  void setCustomValidity(String error);
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

interface SessionDescription default _SessionDescriptionFactoryProvider {

  SessionDescription(String sdp);

  void addCandidate(IceCandidate candidate);

  String toSdp();
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

interface ShadowElement extends Element {
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

interface ShadowRoot extends DocumentFragment default _ShadowRootFactoryProvider {

  ShadowRoot(Element host);

  final Element activeElement;

  final Element host;

  String innerHTML;

  Element getElementById(String elementId);

  NodeList getElementsByClassName(String className);

  NodeList getElementsByTagName(String tagName);

  NodeList getElementsByTagNameNS(String namespaceURI, String localName);
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

interface SharedWorker extends AbstractWorker default _SharedWorkerFactoryProvider {

  SharedWorker(String scriptURL, [String name]);

  final MessagePort port;
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

interface SharedWorkerContext extends WorkerContext {

  final String name;

  EventListener onconnect;
}
// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

typedef bool SignalingCallback(String message, DeprecatedPeerConnection source);
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

interface SourceElement extends Element {

  String media;

  String src;

  String type;
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

interface SpanElement extends Element {
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

interface SpeechGrammar default _SpeechGrammarFactoryProvider {

  SpeechGrammar();

  String src;

  num weight;
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

interface SpeechGrammarList default _SpeechGrammarListFactoryProvider {

  SpeechGrammarList();

  final int length;

  void addFromString(String string, [num weight]);

  void addFromUri(String src, [num weight]);

  SpeechGrammar item(int index);
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

interface SpeechInputEvent extends Event {

  final SpeechInputResultList results;
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

interface SpeechInputResult {

  final num confidence;

  final String utterance;
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

interface SpeechInputResultList {

  final int length;

  SpeechInputResult item(int index);
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

interface SpeechRecognition default _SpeechRecognitionFactoryProvider {

  SpeechRecognition();

  bool continuous;

  SpeechGrammarList grammars;

  String lang;

  EventListener onaudioend;

  EventListener onaudiostart;

  EventListener onend;

  EventListener onerror;

  EventListener onnomatch;

  EventListener onresult;

  EventListener onresultdeleted;

  EventListener onsoundend;

  EventListener onsoundstart;

  EventListener onspeechend;

  EventListener onspeechstart;

  EventListener onstart;

  void abort();

  void start();

  void stop();
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

interface SpeechRecognitionAlternative {

  final num confidence;

  final String transcript;
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

interface SpeechRecognitionError {

  static final int ABORTED = 2;

  static final int AUDIO_CAPTURE = 3;

  static final int BAD_GRAMMAR = 7;

  static final int LANGUAGE_NOT_SUPPORTED = 8;

  static final int NETWORK = 4;

  static final int NOT_ALLOWED = 5;

  static final int NO_SPEECH = 1;

  static final int OTHER = 0;

  static final int SERVICE_NOT_ALLOWED = 6;

  final int code;

  final String message;
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

interface SpeechRecognitionEvent extends Event {

  final SpeechRecognitionError error;

  final SpeechRecognitionResult result;

  final SpeechRecognitionResultList resultHistory;

  final int resultIndex;
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

interface SpeechRecognitionResult {

  final bool finalValue;

  final int length;

  SpeechRecognitionAlternative item(int index);
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

interface SpeechRecognitionResultList {

  final int length;

  SpeechRecognitionResult item(int index);
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

interface Storage {

  final int length;

  void clear();

  String getItem(String key);

  String key(int index);

  void removeItem(String key);

  void setItem(String key, String data);
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

interface StorageEvent extends Event {

  final String key;

  final String newValue;

  final String oldValue;

  final Storage storageArea;

  final String url;

  void initStorageEvent(String typeArg, bool canBubbleArg, bool cancelableArg, String keyArg, String oldValueArg, String newValueArg, String urlArg, Storage storageAreaArg);
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

interface StorageInfo {

  static final int PERSISTENT = 1;

  static final int TEMPORARY = 0;

  void queryUsageAndQuota(int storageType, [StorageInfoUsageCallback usageCallback, StorageInfoErrorCallback errorCallback]);

  void requestQuota(int storageType, int newQuotaInBytes, [StorageInfoQuotaCallback quotaCallback, StorageInfoErrorCallback errorCallback]);
}
// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

typedef bool StorageInfoErrorCallback(DOMException error);
// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

typedef bool StorageInfoQuotaCallback(int grantedQuotaInBytes);
// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

typedef bool StorageInfoUsageCallback(int currentUsageInBytes, int currentQuotaInBytes);
// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

typedef bool StringCallback(String data);
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

interface StyleElement extends Element {

  bool disabled;

  String media;

  final StyleSheet sheet;

  String type;
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

interface StyleMedia {

  final String type;

  bool matchMedium(String mediaquery);
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

interface StyleSheet {

  bool disabled;

  final String href;

  final MediaList media;

  final Node ownerNode;

  final StyleSheet parentStyleSheet;

  final String title;

  final String type;
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

interface StyleSheetList extends List<StyleSheet> {

  final int length;

  StyleSheet item(int index);
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

interface TableCaptionElement extends Element {

  String align;
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

interface TableCellElement extends Element {

  String abbr;

  String align;

  String axis;

  String bgColor;

  final int cellIndex;

  String ch;

  String chOff;

  int colSpan;

  String headers;

  String height;

  bool noWrap;

  int rowSpan;

  String scope;

  String vAlign;

  String width;
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

interface TableColElement extends Element {

  String align;

  String ch;

  String chOff;

  int span;

  String vAlign;

  String width;
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

interface TableElement extends Element {

  String align;

  String bgColor;

  String border;

  TableCaptionElement caption;

  String cellPadding;

  String cellSpacing;

  String frame;

  final HTMLCollection rows;

  String rules;

  String summary;

  final HTMLCollection tBodies;

  TableSectionElement tFoot;

  TableSectionElement tHead;

  String width;

  Element createCaption();

  Element createTFoot();

  Element createTHead();

  void deleteCaption();

  void deleteRow(int index);

  void deleteTFoot();

  void deleteTHead();

  Element insertRow(int index);
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

interface TableRowElement extends Element {

  String align;

  String bgColor;

  final HTMLCollection cells;

  String ch;

  String chOff;

  final int rowIndex;

  final int sectionRowIndex;

  String vAlign;

  void deleteCell(int index);

  Element insertCell(int index);
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

interface TableSectionElement extends Element {

  String align;

  String ch;

  String chOff;

  final HTMLCollection rows;

  String vAlign;

  void deleteRow(int index);

  Element insertRow(int index);
}
// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

interface Text extends CharacterData default _TextFactoryProvider {

  Text(String data);

  final String wholeText;

  Text replaceWholeText(String content);

  Text splitText(int offset);
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

interface TextAreaElement extends Element {

  bool autofocus;

  int cols;

  String defaultValue;

  bool disabled;

  final FormElement form;

  final NodeList labels;

  int maxLength;

  String name;

  String placeholder;

  bool readOnly;

  bool required;

  int rows;

  String selectionDirection;

  int selectionEnd;

  int selectionStart;

  final int textLength;

  final String type;

  final String validationMessage;

  final ValidityState validity;

  String value;

  final bool willValidate;

  String wrap;

  bool checkValidity();

  void select();

  void setCustomValidity(String error);

  void setSelectionRange(int start, int end, [String direction]);
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

interface TextEvent extends UIEvent {

  final String data;

  void initTextEvent(String typeArg, bool canBubbleArg, bool cancelableArg, Window viewArg, String dataArg);
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

interface TextMetrics {

  final num width;
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

interface TextTrack {

  static final int DISABLED = 0;

  static final int HIDDEN = 1;

  static final int SHOWING = 2;

  final TextTrackCueList activeCues;

  final TextTrackCueList cues;

  final String kind;

  final String label;

  final String language;

  int mode;

  EventListener oncuechange;

  void addCue(TextTrackCue cue);

  void addEventListener(String type, EventListener listener, [bool useCapture]);

  bool dispatchEvent(Event evt);

  void removeCue(TextTrackCue cue);

  void removeEventListener(String type, EventListener listener, [bool useCapture]);
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

interface TextTrackCue default _TextTrackCueFactoryProvider {

  TextTrackCue(String id, num startTime, num endTime, String text, [String settings, bool pauseOnExit]);

  String align;

  num endTime;

  String id;

  int line;

  EventListener onenter;

  EventListener onexit;

  bool pauseOnExit;

  int position;

  int size;

  bool snapToLines;

  num startTime;

  String text;

  final TextTrack track;

  String vertical;

  void addEventListener(String type, EventListener listener, [bool useCapture]);

  bool dispatchEvent(Event evt);

  DocumentFragment getCueAsHTML();

  void removeEventListener(String type, EventListener listener, [bool useCapture]);
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

interface TextTrackCueList {

  final int length;

  TextTrackCue getCueById(String id);

  TextTrackCue item(int index);
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

interface TextTrackList {

  final int length;

  EventListener onaddtrack;

  void addEventListener(String type, EventListener listener, [bool useCapture]);

  bool dispatchEvent(Event evt);

  TextTrack item(int index);

  void removeEventListener(String type, EventListener listener, [bool useCapture]);
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

interface TimeRanges {

  final int length;

  num end(int index);

  num start(int index);
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

interface TitleElement extends Element {
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

interface Touch {

  final int clientX;

  final int clientY;

  final int identifier;

  final int pageX;

  final int pageY;

  final int screenX;

  final int screenY;

  final EventTarget target;

  final num webkitForce;

  final int webkitRadiusX;

  final int webkitRadiusY;

  final num webkitRotationAngle;
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

interface TouchEvent extends UIEvent {

  final bool altKey;

  final TouchList changedTouches;

  final bool ctrlKey;

  final bool metaKey;

  final bool shiftKey;

  final TouchList targetTouches;

  final TouchList touches;

  void initTouchEvent(TouchList touches, TouchList targetTouches, TouchList changedTouches, String type, Window view, int screenX, int screenY, int clientX, int clientY, bool ctrlKey, bool altKey, bool shiftKey, bool metaKey);
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

interface TouchList extends List<Touch> {

  final int length;

  Touch item(int index);
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

interface TrackElement extends Element {

  static final int ERROR = 3;

  static final int LOADED = 2;

  static final int LOADING = 1;

  static final int NONE = 0;

  bool defaultValue;

  String kind;

  String label;

  final int readyState;

  String src;

  String srclang;

  final TextTrack track;
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

interface TrackEvent extends Event {

  final Object track;
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

interface TransitionEvent extends Event {

  final num elapsedTime;

  final String propertyName;
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

interface TreeWalker {

  Node currentNode;

  final bool expandEntityReferences;

  final NodeFilter filter;

  final Node root;

  final int whatToShow;

  Node firstChild();

  Node lastChild();

  Node nextNode();

  Node nextSibling();

  Node parentNode();

  Node previousNode();

  Node previousSibling();
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

interface UIEvent extends Event {

  final int charCode;

  final int detail;

  final int keyCode;

  final int layerX;

  final int layerY;

  final int pageX;

  final int pageY;

  final Window view;

  final int which;

  void initUIEvent(String type, bool canBubble, bool cancelable, Window view, int detail);
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

interface UListElement extends Element {

  bool compact;

  String type;
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

interface Uint16Array extends ArrayBufferView, List<int> default _TypedArrayFactoryProvider {

  Uint16Array(int length);

  Uint16Array.fromList(List<int> list);

  Uint16Array.fromBuffer(ArrayBuffer buffer);

  static final int BYTES_PER_ELEMENT = 2;

  final int length;

  void setElements(Object array, [int offset]);

  Uint16Array subarray(int start, [int end]);
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

interface Uint32Array extends ArrayBufferView, List<int> default _TypedArrayFactoryProvider {

  Uint32Array(int length);

  Uint32Array.fromList(List<int> list);

  Uint32Array.fromBuffer(ArrayBuffer buffer);

  static final int BYTES_PER_ELEMENT = 4;

  final int length;

  void setElements(Object array, [int offset]);

  Uint32Array subarray(int start, [int end]);
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

interface Uint8Array extends ArrayBufferView, List<int> default _TypedArrayFactoryProvider {

  Uint8Array(int length);

  Uint8Array.fromList(List<int> list);

  Uint8Array.fromBuffer(ArrayBuffer buffer);

  static final int BYTES_PER_ELEMENT = 1;

  final int length;

  void setElements(Object array, [int offset]);

  Uint8Array subarray(int start, [int end]);
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

interface Uint8ClampedArray extends Uint8Array default _TypedArrayFactoryProvider {

  Uint8ClampedArray(int length);

  Uint8ClampedArray.fromList(List<int> list);

  Uint8ClampedArray.fromBuffer(ArrayBuffer buffer);

  final int length;

  void setElements(Object array, [int offset]);

  Uint8ClampedArray subarray(int start, [int end]);
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

interface UnknownElement extends Element {
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

interface ValidityState {

  final bool customError;

  final bool patternMismatch;

  final bool rangeOverflow;

  final bool rangeUnderflow;

  final bool stepMismatch;

  final bool tooLong;

  final bool typeMismatch;

  final bool valid;

  final bool valueMissing;
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

interface VideoElement extends MediaElement {

  int height;

  String poster;

  final int videoHeight;

  final int videoWidth;

  final int webkitDecodedFrameCount;

  final bool webkitDisplayingFullscreen;

  final int webkitDroppedFrameCount;

  final bool webkitSupportsFullscreen;

  int width;

  void webkitEnterFullScreen();

  void webkitEnterFullscreen();

  void webkitExitFullScreen();

  void webkitExitFullscreen();
}
// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

typedef void VoidCallback();
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

interface WaveShaperNode extends AudioNode {

  Float32Array curve;
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

interface WebGLActiveInfo {

  final String name;

  final int size;

  final int type;
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

interface WebGLBuffer {
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

interface WebGLCompressedTextureS3TC {

  static final int COMPRESSED_RGBA_S3TC_DXT1_EXT = 0x83F1;

  static final int COMPRESSED_RGBA_S3TC_DXT3_EXT = 0x83F2;

  static final int COMPRESSED_RGBA_S3TC_DXT5_EXT = 0x83F3;

  static final int COMPRESSED_RGB_S3TC_DXT1_EXT = 0x83F0;
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

interface WebGLContextAttributes {

  bool alpha;

  bool antialias;

  bool depth;

  bool premultipliedAlpha;

  bool preserveDrawingBuffer;

  bool stencil;
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

interface WebGLContextEvent extends Event {

  final String statusMessage;
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

interface WebGLDebugRendererInfo {

  static final int UNMASKED_RENDERER_WEBGL = 0x9246;

  static final int UNMASKED_VENDOR_WEBGL = 0x9245;
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

interface WebGLDebugShaders {

  String getTranslatedShaderSource(WebGLShader shader);
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

interface WebGLFramebuffer {
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

interface WebGLLoseContext {

  void loseContext();

  void restoreContext();
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

interface WebGLProgram {
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

interface WebGLRenderbuffer {
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

interface WebGLRenderingContext extends CanvasRenderingContext {

  static final int ACTIVE_ATTRIBUTES = 0x8B89;

  static final int ACTIVE_TEXTURE = 0x84E0;

  static final int ACTIVE_UNIFORMS = 0x8B86;

  static final int ALIASED_LINE_WIDTH_RANGE = 0x846E;

  static final int ALIASED_POINT_SIZE_RANGE = 0x846D;

  static final int ALPHA = 0x1906;

  static final int ALPHA_BITS = 0x0D55;

  static final int ALWAYS = 0x0207;

  static final int ARRAY_BUFFER = 0x8892;

  static final int ARRAY_BUFFER_BINDING = 0x8894;

  static final int ATTACHED_SHADERS = 0x8B85;

  static final int BACK = 0x0405;

  static final int BLEND = 0x0BE2;

  static final int BLEND_COLOR = 0x8005;

  static final int BLEND_DST_ALPHA = 0x80CA;

  static final int BLEND_DST_RGB = 0x80C8;

  static final int BLEND_EQUATION = 0x8009;

  static final int BLEND_EQUATION_ALPHA = 0x883D;

  static final int BLEND_EQUATION_RGB = 0x8009;

  static final int BLEND_SRC_ALPHA = 0x80CB;

  static final int BLEND_SRC_RGB = 0x80C9;

  static final int BLUE_BITS = 0x0D54;

  static final int BOOL = 0x8B56;

  static final int BOOL_VEC2 = 0x8B57;

  static final int BOOL_VEC3 = 0x8B58;

  static final int BOOL_VEC4 = 0x8B59;

  static final int BROWSER_DEFAULT_WEBGL = 0x9244;

  static final int BUFFER_SIZE = 0x8764;

  static final int BUFFER_USAGE = 0x8765;

  static final int BYTE = 0x1400;

  static final int CCW = 0x0901;

  static final int CLAMP_TO_EDGE = 0x812F;

  static final int COLOR_ATTACHMENT0 = 0x8CE0;

  static final int COLOR_BUFFER_BIT = 0x00004000;

  static final int COLOR_CLEAR_VALUE = 0x0C22;

  static final int COLOR_WRITEMASK = 0x0C23;

  static final int COMPILE_STATUS = 0x8B81;

  static final int COMPRESSED_TEXTURE_FORMATS = 0x86A3;

  static final int CONSTANT_ALPHA = 0x8003;

  static final int CONSTANT_COLOR = 0x8001;

  static final int CONTEXT_LOST_WEBGL = 0x9242;

  static final int CULL_FACE = 0x0B44;

  static final int CULL_FACE_MODE = 0x0B45;

  static final int CURRENT_PROGRAM = 0x8B8D;

  static final int CURRENT_VERTEX_ATTRIB = 0x8626;

  static final int CW = 0x0900;

  static final int DECR = 0x1E03;

  static final int DECR_WRAP = 0x8508;

  static final int DELETE_STATUS = 0x8B80;

  static final int DEPTH_ATTACHMENT = 0x8D00;

  static final int DEPTH_BITS = 0x0D56;

  static final int DEPTH_BUFFER_BIT = 0x00000100;

  static final int DEPTH_CLEAR_VALUE = 0x0B73;

  static final int DEPTH_COMPONENT = 0x1902;

  static final int DEPTH_COMPONENT16 = 0x81A5;

  static final int DEPTH_FUNC = 0x0B74;

  static final int DEPTH_RANGE = 0x0B70;

  static final int DEPTH_STENCIL = 0x84F9;

  static final int DEPTH_STENCIL_ATTACHMENT = 0x821A;

  static final int DEPTH_TEST = 0x0B71;

  static final int DEPTH_WRITEMASK = 0x0B72;

  static final int DITHER = 0x0BD0;

  static final int DONT_CARE = 0x1100;

  static final int DST_ALPHA = 0x0304;

  static final int DST_COLOR = 0x0306;

  static final int DYNAMIC_DRAW = 0x88E8;

  static final int ELEMENT_ARRAY_BUFFER = 0x8893;

  static final int ELEMENT_ARRAY_BUFFER_BINDING = 0x8895;

  static final int EQUAL = 0x0202;

  static final int FASTEST = 0x1101;

  static final int FLOAT = 0x1406;

  static final int FLOAT_MAT2 = 0x8B5A;

  static final int FLOAT_MAT3 = 0x8B5B;

  static final int FLOAT_MAT4 = 0x8B5C;

  static final int FLOAT_VEC2 = 0x8B50;

  static final int FLOAT_VEC3 = 0x8B51;

  static final int FLOAT_VEC4 = 0x8B52;

  static final int FRAGMENT_SHADER = 0x8B30;

  static final int FRAMEBUFFER = 0x8D40;

  static final int FRAMEBUFFER_ATTACHMENT_OBJECT_NAME = 0x8CD1;

  static final int FRAMEBUFFER_ATTACHMENT_OBJECT_TYPE = 0x8CD0;

  static final int FRAMEBUFFER_ATTACHMENT_TEXTURE_CUBE_MAP_FACE = 0x8CD3;

  static final int FRAMEBUFFER_ATTACHMENT_TEXTURE_LEVEL = 0x8CD2;

  static final int FRAMEBUFFER_BINDING = 0x8CA6;

  static final int FRAMEBUFFER_COMPLETE = 0x8CD5;

  static final int FRAMEBUFFER_INCOMPLETE_ATTACHMENT = 0x8CD6;

  static final int FRAMEBUFFER_INCOMPLETE_DIMENSIONS = 0x8CD9;

  static final int FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT = 0x8CD7;

  static final int FRAMEBUFFER_UNSUPPORTED = 0x8CDD;

  static final int FRONT = 0x0404;

  static final int FRONT_AND_BACK = 0x0408;

  static final int FRONT_FACE = 0x0B46;

  static final int FUNC_ADD = 0x8006;

  static final int FUNC_REVERSE_SUBTRACT = 0x800B;

  static final int FUNC_SUBTRACT = 0x800A;

  static final int GENERATE_MIPMAP_HINT = 0x8192;

  static final int GEQUAL = 0x0206;

  static final int GREATER = 0x0204;

  static final int GREEN_BITS = 0x0D53;

  static final int HIGH_FLOAT = 0x8DF2;

  static final int HIGH_INT = 0x8DF5;

  static final int INCR = 0x1E02;

  static final int INCR_WRAP = 0x8507;

  static final int INT = 0x1404;

  static final int INT_VEC2 = 0x8B53;

  static final int INT_VEC3 = 0x8B54;

  static final int INT_VEC4 = 0x8B55;

  static final int INVALID_ENUM = 0x0500;

  static final int INVALID_FRAMEBUFFER_OPERATION = 0x0506;

  static final int INVALID_OPERATION = 0x0502;

  static final int INVALID_VALUE = 0x0501;

  static final int INVERT = 0x150A;

  static final int KEEP = 0x1E00;

  static final int LEQUAL = 0x0203;

  static final int LESS = 0x0201;

  static final int LINEAR = 0x2601;

  static final int LINEAR_MIPMAP_LINEAR = 0x2703;

  static final int LINEAR_MIPMAP_NEAREST = 0x2701;

  static final int LINES = 0x0001;

  static final int LINE_LOOP = 0x0002;

  static final int LINE_STRIP = 0x0003;

  static final int LINE_WIDTH = 0x0B21;

  static final int LINK_STATUS = 0x8B82;

  static final int LOW_FLOAT = 0x8DF0;

  static final int LOW_INT = 0x8DF3;

  static final int LUMINANCE = 0x1909;

  static final int LUMINANCE_ALPHA = 0x190A;

  static final int MAX_COMBINED_TEXTURE_IMAGE_UNITS = 0x8B4D;

  static final int MAX_CUBE_MAP_TEXTURE_SIZE = 0x851C;

  static final int MAX_FRAGMENT_UNIFORM_VECTORS = 0x8DFD;

  static final int MAX_RENDERBUFFER_SIZE = 0x84E8;

  static final int MAX_TEXTURE_IMAGE_UNITS = 0x8872;

  static final int MAX_TEXTURE_SIZE = 0x0D33;

  static final int MAX_VARYING_VECTORS = 0x8DFC;

  static final int MAX_VERTEX_ATTRIBS = 0x8869;

  static final int MAX_VERTEX_TEXTURE_IMAGE_UNITS = 0x8B4C;

  static final int MAX_VERTEX_UNIFORM_VECTORS = 0x8DFB;

  static final int MAX_VIEWPORT_DIMS = 0x0D3A;

  static final int MEDIUM_FLOAT = 0x8DF1;

  static final int MEDIUM_INT = 0x8DF4;

  static final int MIRRORED_REPEAT = 0x8370;

  static final int NEAREST = 0x2600;

  static final int NEAREST_MIPMAP_LINEAR = 0x2702;

  static final int NEAREST_MIPMAP_NEAREST = 0x2700;

  static final int NEVER = 0x0200;

  static final int NICEST = 0x1102;

  static final int NONE = 0;

  static final int NOTEQUAL = 0x0205;

  static final int NO_ERROR = 0;

  static final int ONE = 1;

  static final int ONE_MINUS_CONSTANT_ALPHA = 0x8004;

  static final int ONE_MINUS_CONSTANT_COLOR = 0x8002;

  static final int ONE_MINUS_DST_ALPHA = 0x0305;

  static final int ONE_MINUS_DST_COLOR = 0x0307;

  static final int ONE_MINUS_SRC_ALPHA = 0x0303;

  static final int ONE_MINUS_SRC_COLOR = 0x0301;

  static final int OUT_OF_MEMORY = 0x0505;

  static final int PACK_ALIGNMENT = 0x0D05;

  static final int POINTS = 0x0000;

  static final int POLYGON_OFFSET_FACTOR = 0x8038;

  static final int POLYGON_OFFSET_FILL = 0x8037;

  static final int POLYGON_OFFSET_UNITS = 0x2A00;

  static final int RED_BITS = 0x0D52;

  static final int RENDERBUFFER = 0x8D41;

  static final int RENDERBUFFER_ALPHA_SIZE = 0x8D53;

  static final int RENDERBUFFER_BINDING = 0x8CA7;

  static final int RENDERBUFFER_BLUE_SIZE = 0x8D52;

  static final int RENDERBUFFER_DEPTH_SIZE = 0x8D54;

  static final int RENDERBUFFER_GREEN_SIZE = 0x8D51;

  static final int RENDERBUFFER_HEIGHT = 0x8D43;

  static final int RENDERBUFFER_INTERNAL_FORMAT = 0x8D44;

  static final int RENDERBUFFER_RED_SIZE = 0x8D50;

  static final int RENDERBUFFER_STENCIL_SIZE = 0x8D55;

  static final int RENDERBUFFER_WIDTH = 0x8D42;

  static final int RENDERER = 0x1F01;

  static final int REPEAT = 0x2901;

  static final int REPLACE = 0x1E01;

  static final int RGB = 0x1907;

  static final int RGB565 = 0x8D62;

  static final int RGB5_A1 = 0x8057;

  static final int RGBA = 0x1908;

  static final int RGBA4 = 0x8056;

  static final int SAMPLER_2D = 0x8B5E;

  static final int SAMPLER_CUBE = 0x8B60;

  static final int SAMPLES = 0x80A9;

  static final int SAMPLE_ALPHA_TO_COVERAGE = 0x809E;

  static final int SAMPLE_BUFFERS = 0x80A8;

  static final int SAMPLE_COVERAGE = 0x80A0;

  static final int SAMPLE_COVERAGE_INVERT = 0x80AB;

  static final int SAMPLE_COVERAGE_VALUE = 0x80AA;

  static final int SCISSOR_BOX = 0x0C10;

  static final int SCISSOR_TEST = 0x0C11;

  static final int SHADER_COMPILER = 0x8DFA;

  static final int SHADER_TYPE = 0x8B4F;

  static final int SHADING_LANGUAGE_VERSION = 0x8B8C;

  static final int SHORT = 0x1402;

  static final int SRC_ALPHA = 0x0302;

  static final int SRC_ALPHA_SATURATE = 0x0308;

  static final int SRC_COLOR = 0x0300;

  static final int STATIC_DRAW = 0x88E4;

  static final int STENCIL_ATTACHMENT = 0x8D20;

  static final int STENCIL_BACK_FAIL = 0x8801;

  static final int STENCIL_BACK_FUNC = 0x8800;

  static final int STENCIL_BACK_PASS_DEPTH_FAIL = 0x8802;

  static final int STENCIL_BACK_PASS_DEPTH_PASS = 0x8803;

  static final int STENCIL_BACK_REF = 0x8CA3;

  static final int STENCIL_BACK_VALUE_MASK = 0x8CA4;

  static final int STENCIL_BACK_WRITEMASK = 0x8CA5;

  static final int STENCIL_BITS = 0x0D57;

  static final int STENCIL_BUFFER_BIT = 0x00000400;

  static final int STENCIL_CLEAR_VALUE = 0x0B91;

  static final int STENCIL_FAIL = 0x0B94;

  static final int STENCIL_FUNC = 0x0B92;

  static final int STENCIL_INDEX = 0x1901;

  static final int STENCIL_INDEX8 = 0x8D48;

  static final int STENCIL_PASS_DEPTH_FAIL = 0x0B95;

  static final int STENCIL_PASS_DEPTH_PASS = 0x0B96;

  static final int STENCIL_REF = 0x0B97;

  static final int STENCIL_TEST = 0x0B90;

  static final int STENCIL_VALUE_MASK = 0x0B93;

  static final int STENCIL_WRITEMASK = 0x0B98;

  static final int STREAM_DRAW = 0x88E0;

  static final int SUBPIXEL_BITS = 0x0D50;

  static final int TEXTURE = 0x1702;

  static final int TEXTURE0 = 0x84C0;

  static final int TEXTURE1 = 0x84C1;

  static final int TEXTURE10 = 0x84CA;

  static final int TEXTURE11 = 0x84CB;

  static final int TEXTURE12 = 0x84CC;

  static final int TEXTURE13 = 0x84CD;

  static final int TEXTURE14 = 0x84CE;

  static final int TEXTURE15 = 0x84CF;

  static final int TEXTURE16 = 0x84D0;

  static final int TEXTURE17 = 0x84D1;

  static final int TEXTURE18 = 0x84D2;

  static final int TEXTURE19 = 0x84D3;

  static final int TEXTURE2 = 0x84C2;

  static final int TEXTURE20 = 0x84D4;

  static final int TEXTURE21 = 0x84D5;

  static final int TEXTURE22 = 0x84D6;

  static final int TEXTURE23 = 0x84D7;

  static final int TEXTURE24 = 0x84D8;

  static final int TEXTURE25 = 0x84D9;

  static final int TEXTURE26 = 0x84DA;

  static final int TEXTURE27 = 0x84DB;

  static final int TEXTURE28 = 0x84DC;

  static final int TEXTURE29 = 0x84DD;

  static final int TEXTURE3 = 0x84C3;

  static final int TEXTURE30 = 0x84DE;

  static final int TEXTURE31 = 0x84DF;

  static final int TEXTURE4 = 0x84C4;

  static final int TEXTURE5 = 0x84C5;

  static final int TEXTURE6 = 0x84C6;

  static final int TEXTURE7 = 0x84C7;

  static final int TEXTURE8 = 0x84C8;

  static final int TEXTURE9 = 0x84C9;

  static final int TEXTURE_2D = 0x0DE1;

  static final int TEXTURE_BINDING_2D = 0x8069;

  static final int TEXTURE_BINDING_CUBE_MAP = 0x8514;

  static final int TEXTURE_CUBE_MAP = 0x8513;

  static final int TEXTURE_CUBE_MAP_NEGATIVE_X = 0x8516;

  static final int TEXTURE_CUBE_MAP_NEGATIVE_Y = 0x8518;

  static final int TEXTURE_CUBE_MAP_NEGATIVE_Z = 0x851A;

  static final int TEXTURE_CUBE_MAP_POSITIVE_X = 0x8515;

  static final int TEXTURE_CUBE_MAP_POSITIVE_Y = 0x8517;

  static final int TEXTURE_CUBE_MAP_POSITIVE_Z = 0x8519;

  static final int TEXTURE_MAG_FILTER = 0x2800;

  static final int TEXTURE_MIN_FILTER = 0x2801;

  static final int TEXTURE_WRAP_S = 0x2802;

  static final int TEXTURE_WRAP_T = 0x2803;

  static final int TRIANGLES = 0x0004;

  static final int TRIANGLE_FAN = 0x0006;

  static final int TRIANGLE_STRIP = 0x0005;

  static final int UNPACK_ALIGNMENT = 0x0CF5;

  static final int UNPACK_COLORSPACE_CONVERSION_WEBGL = 0x9243;

  static final int UNPACK_FLIP_Y_WEBGL = 0x9240;

  static final int UNPACK_PREMULTIPLY_ALPHA_WEBGL = 0x9241;

  static final int UNSIGNED_BYTE = 0x1401;

  static final int UNSIGNED_INT = 0x1405;

  static final int UNSIGNED_SHORT = 0x1403;

  static final int UNSIGNED_SHORT_4_4_4_4 = 0x8033;

  static final int UNSIGNED_SHORT_5_5_5_1 = 0x8034;

  static final int UNSIGNED_SHORT_5_6_5 = 0x8363;

  static final int VALIDATE_STATUS = 0x8B83;

  static final int VENDOR = 0x1F00;

  static final int VERSION = 0x1F02;

  static final int VERTEX_ATTRIB_ARRAY_BUFFER_BINDING = 0x889F;

  static final int VERTEX_ATTRIB_ARRAY_ENABLED = 0x8622;

  static final int VERTEX_ATTRIB_ARRAY_NORMALIZED = 0x886A;

  static final int VERTEX_ATTRIB_ARRAY_POINTER = 0x8645;

  static final int VERTEX_ATTRIB_ARRAY_SIZE = 0x8623;

  static final int VERTEX_ATTRIB_ARRAY_STRIDE = 0x8624;

  static final int VERTEX_ATTRIB_ARRAY_TYPE = 0x8625;

  static final int VERTEX_SHADER = 0x8B31;

  static final int VIEWPORT = 0x0BA2;

  static final int ZERO = 0;

  final int drawingBufferHeight;

  final int drawingBufferWidth;

  void activeTexture(int texture);

  void attachShader(WebGLProgram program, WebGLShader shader);

  void bindAttribLocation(WebGLProgram program, int index, String name);

  void bindBuffer(int target, WebGLBuffer buffer);

  void bindFramebuffer(int target, WebGLFramebuffer framebuffer);

  void bindRenderbuffer(int target, WebGLRenderbuffer renderbuffer);

  void bindTexture(int target, WebGLTexture texture);

  void blendColor(num red, num green, num blue, num alpha);

  void blendEquation(int mode);

  void blendEquationSeparate(int modeRGB, int modeAlpha);

  void blendFunc(int sfactor, int dfactor);

  void blendFuncSeparate(int srcRGB, int dstRGB, int srcAlpha, int dstAlpha);

  void bufferData(int target, var data_OR_size, int usage);

  void bufferSubData(int target, int offset, var data);

  int checkFramebufferStatus(int target);

  void clear(int mask);

  void clearColor(num red, num green, num blue, num alpha);

  void clearDepth(num depth);

  void clearStencil(int s);

  void colorMask(bool red, bool green, bool blue, bool alpha);

  void compileShader(WebGLShader shader);

  void compressedTexImage2D(int target, int level, int internalformat, int width, int height, int border, ArrayBufferView data);

  void compressedTexSubImage2D(int target, int level, int xoffset, int yoffset, int width, int height, int format, ArrayBufferView data);

  void copyTexImage2D(int target, int level, int internalformat, int x, int y, int width, int height, int border);

  void copyTexSubImage2D(int target, int level, int xoffset, int yoffset, int x, int y, int width, int height);

  WebGLBuffer createBuffer();

  WebGLFramebuffer createFramebuffer();

  WebGLProgram createProgram();

  WebGLRenderbuffer createRenderbuffer();

  WebGLShader createShader(int type);

  WebGLTexture createTexture();

  void cullFace(int mode);

  void deleteBuffer(WebGLBuffer buffer);

  void deleteFramebuffer(WebGLFramebuffer framebuffer);

  void deleteProgram(WebGLProgram program);

  void deleteRenderbuffer(WebGLRenderbuffer renderbuffer);

  void deleteShader(WebGLShader shader);

  void deleteTexture(WebGLTexture texture);

  void depthFunc(int func);

  void depthMask(bool flag);

  void depthRange(num zNear, num zFar);

  void detachShader(WebGLProgram program, WebGLShader shader);

  void disable(int cap);

  void disableVertexAttribArray(int index);

  void drawArrays(int mode, int first, int count);

  void drawElements(int mode, int count, int type, int offset);

  void enable(int cap);

  void enableVertexAttribArray(int index);

  void finish();

  void flush();

  void framebufferRenderbuffer(int target, int attachment, int renderbuffertarget, WebGLRenderbuffer renderbuffer);

  void framebufferTexture2D(int target, int attachment, int textarget, WebGLTexture texture, int level);

  void frontFace(int mode);

  void generateMipmap(int target);

  WebGLActiveInfo getActiveAttrib(WebGLProgram program, int index);

  WebGLActiveInfo getActiveUniform(WebGLProgram program, int index);

  List getAttachedShaders(WebGLProgram program);

  int getAttribLocation(WebGLProgram program, String name);

  Object getBufferParameter(int target, int pname);

  WebGLContextAttributes getContextAttributes();

  int getError();

  Object getExtension(String name);

  Object getFramebufferAttachmentParameter(int target, int attachment, int pname);

  Object getParameter(int pname);

  String getProgramInfoLog(WebGLProgram program);

  Object getProgramParameter(WebGLProgram program, int pname);

  Object getRenderbufferParameter(int target, int pname);

  String getShaderInfoLog(WebGLShader shader);

  Object getShaderParameter(WebGLShader shader, int pname);

  String getShaderSource(WebGLShader shader);

  Object getTexParameter(int target, int pname);

  Object getUniform(WebGLProgram program, WebGLUniformLocation location);

  WebGLUniformLocation getUniformLocation(WebGLProgram program, String name);

  Object getVertexAttrib(int index, int pname);

  int getVertexAttribOffset(int index, int pname);

  void hint(int target, int mode);

  bool isBuffer(WebGLBuffer buffer);

  bool isContextLost();

  bool isEnabled(int cap);

  bool isFramebuffer(WebGLFramebuffer framebuffer);

  bool isProgram(WebGLProgram program);

  bool isRenderbuffer(WebGLRenderbuffer renderbuffer);

  bool isShader(WebGLShader shader);

  bool isTexture(WebGLTexture texture);

  void lineWidth(num width);

  void linkProgram(WebGLProgram program);

  void pixelStorei(int pname, int param);

  void polygonOffset(num factor, num units);

  void readPixels(int x, int y, int width, int height, int format, int type, ArrayBufferView pixels);

  void releaseShaderCompiler();

  void renderbufferStorage(int target, int internalformat, int width, int height);

  void sampleCoverage(num value, bool invert);

  void scissor(int x, int y, int width, int height);

  void shaderSource(WebGLShader shader, String string);

  void stencilFunc(int func, int ref, int mask);

  void stencilFuncSeparate(int face, int func, int ref, int mask);

  void stencilMask(int mask);

  void stencilMaskSeparate(int face, int mask);

  void stencilOp(int fail, int zfail, int zpass);

  void stencilOpSeparate(int face, int fail, int zfail, int zpass);

  void texImage2D(int target, int level, int internalformat, int format_OR_width, int height_OR_type, var border_OR_canvas_OR_image_OR_pixels_OR_video, [int format, int type, ArrayBufferView pixels]);

  void texParameterf(int target, int pname, num param);

  void texParameteri(int target, int pname, int param);

  void texSubImage2D(int target, int level, int xoffset, int yoffset, int format_OR_width, int height_OR_type, var canvas_OR_format_OR_image_OR_pixels_OR_video, [int type, ArrayBufferView pixels]);

  void uniform1f(WebGLUniformLocation location, num x);

  void uniform1fv(WebGLUniformLocation location, Float32Array v);

  void uniform1i(WebGLUniformLocation location, int x);

  void uniform1iv(WebGLUniformLocation location, Int32Array v);

  void uniform2f(WebGLUniformLocation location, num x, num y);

  void uniform2fv(WebGLUniformLocation location, Float32Array v);

  void uniform2i(WebGLUniformLocation location, int x, int y);

  void uniform2iv(WebGLUniformLocation location, Int32Array v);

  void uniform3f(WebGLUniformLocation location, num x, num y, num z);

  void uniform3fv(WebGLUniformLocation location, Float32Array v);

  void uniform3i(WebGLUniformLocation location, int x, int y, int z);

  void uniform3iv(WebGLUniformLocation location, Int32Array v);

  void uniform4f(WebGLUniformLocation location, num x, num y, num z, num w);

  void uniform4fv(WebGLUniformLocation location, Float32Array v);

  void uniform4i(WebGLUniformLocation location, int x, int y, int z, int w);

  void uniform4iv(WebGLUniformLocation location, Int32Array v);

  void uniformMatrix2fv(WebGLUniformLocation location, bool transpose, Float32Array array);

  void uniformMatrix3fv(WebGLUniformLocation location, bool transpose, Float32Array array);

  void uniformMatrix4fv(WebGLUniformLocation location, bool transpose, Float32Array array);

  void useProgram(WebGLProgram program);

  void validateProgram(WebGLProgram program);

  void vertexAttrib1f(int indx, num x);

  void vertexAttrib1fv(int indx, Float32Array values);

  void vertexAttrib2f(int indx, num x, num y);

  void vertexAttrib2fv(int indx, Float32Array values);

  void vertexAttrib3f(int indx, num x, num y, num z);

  void vertexAttrib3fv(int indx, Float32Array values);

  void vertexAttrib4f(int indx, num x, num y, num z, num w);

  void vertexAttrib4fv(int indx, Float32Array values);

  void vertexAttribPointer(int indx, int size, int type, bool normalized, int stride, int offset);

  void viewport(int x, int y, int width, int height);
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

interface WebGLShader {
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

interface WebGLTexture {
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

interface WebGLUniformLocation {
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

interface WebGLVertexArrayObjectOES {
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

interface WebKitCSSRegionRule extends CSSRule {

  final CSSRuleList cssRules;
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

interface WebKitNamedFlow {

  final bool overflow;

  NodeList getRegionsByContentNode(Node contentNode);
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

interface WebSocket extends EventTarget default _WebSocketFactoryProvider {

  WebSocket(String url);

  WebSocketEvents get on();

  static final int CLOSED = 3;

  static final int CLOSING = 2;

  static final int CONNECTING = 0;

  static final int OPEN = 1;

  final String URL;

  String binaryType;

  final int bufferedAmount;

  final String extensions;

  final String protocol;

  final int readyState;

  final String url;

  void close([int code, String reason]);

  bool send(String data);
}

interface WebSocketEvents extends Events {

  EventListenerList get close();

  EventListenerList get error();

  EventListenerList get message();

  EventListenerList get open();
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

interface WheelEvent extends UIEvent {

  final bool altKey;

  final int clientX;

  final int clientY;

  final bool ctrlKey;

  final bool metaKey;

  final int offsetX;

  final int offsetY;

  final int screenX;

  final int screenY;

  final bool shiftKey;

  final bool webkitDirectionInvertedFromDevice;

  final int wheelDelta;

  final int wheelDeltaX;

  final int wheelDeltaY;

  final int x;

  final int y;

  void initWebKitWheelEvent(int wheelDeltaX, int wheelDeltaY, Window view, int screenX, int screenY, int clientX, int clientY, bool ctrlKey, bool altKey, bool shiftKey, bool metaKey);
}
// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

interface Window extends EventTarget {

  final Document document;

  /**
   * Executes a [callback] after the next batch of browser layout measurements
   * has completed or would have completed if any browser layout measurements
   * had been scheduled.
   */
  void requestLayoutFrame(TimeoutHandler callback);


  WindowEvents get on();

  static final int PERSISTENT = 1;

  static final int TEMPORARY = 0;

  final DOMApplicationCache applicationCache;

  final Navigator clientInformation;

  final bool closed;

  final Console console;

  final Crypto crypto;

  String defaultStatus;

  String defaultstatus;

  final num devicePixelRatio;

  final Event event;

  final Element frameElement;

  final Window frames;

  final History history;

  final int innerHeight;

  final int innerWidth;

  final int length;

  final Storage localStorage;

  Location location;

  final BarInfo locationbar;

  final BarInfo menubar;

  String name;

  final Navigator navigator;

  final bool offscreenBuffering;

  final Window opener;

  final int outerHeight;

  final int outerWidth;

  final int pageXOffset;

  final int pageYOffset;

  final Window parent;

  final Performance performance;

  final BarInfo personalbar;

  final Screen screen;

  final int screenLeft;

  final int screenTop;

  final int screenX;

  final int screenY;

  final int scrollX;

  final int scrollY;

  final BarInfo scrollbars;

  final Window self;

  final Storage sessionStorage;

  String status;

  final BarInfo statusbar;

  final StyleMedia styleMedia;

  final BarInfo toolbar;

  final Window top;

  final IDBFactory webkitIndexedDB;

  final NotificationCenter webkitNotifications;

  final StorageInfo webkitStorageInfo;

  final Window window;

  void alert(String message);

  String atob(String string);

  void blur();

  String btoa(String string);

  void captureEvents();

  void clearInterval(int handle);

  void clearTimeout(int handle);

  void close();

  bool confirm(String message);

  bool find(String string, bool caseSensitive, bool backwards, bool wrap, bool wholeWord, bool searchInFrames, bool showDialog);

  void focus();

  CSSRuleList getMatchedCSSRules(Element element, String pseudoElement);

  DOMSelection getSelection();

  MediaQueryList matchMedia(String query);

  void moveBy(num x, num y);

  void moveTo(num x, num y);

  Window open(String url, String name, [String options]);

  Database openDatabase(String name, String version, String displayName, int estimatedSize, [DatabaseCallback creationCallback]);

  void postMessage(Dynamic message, String targetOrigin, [List messagePorts]);

  void print();

  String prompt(String message, String defaultValue);

  void releaseEvents();

  void resizeBy(num x, num y);

  void resizeTo(num width, num height);

  void scroll(int x, int y);

  void scrollBy(int x, int y);

  void scrollTo(int x, int y);

  int setInterval(TimeoutHandler handler, int timeout);

  int setTimeout(TimeoutHandler handler, int timeout);

  Object showModalDialog(String url, [Object dialogArgs, String featureArgs]);

  void stop();

  void webkitCancelAnimationFrame(int id);

  void webkitCancelRequestAnimationFrame(int id);

  Point webkitConvertPointFromNodeToPage(Node node, Point p);

  Point webkitConvertPointFromPageToNode(Node node, Point p);

  void webkitPostMessage(Dynamic message, String targetOrigin, [List transferList]);

  int webkitRequestAnimationFrame(RequestAnimationFrameCallback callback, Element element);

  void webkitRequestFileSystem(int type, int size, FileSystemCallback successCallback, [ErrorCallback errorCallback]);

  void webkitResolveLocalFileSystemURL(String url, [EntryCallback successCallback, ErrorCallback errorCallback]);

}

interface WindowEvents extends Events {

  EventListenerList get abort();

  EventListenerList get animationEnd();

  EventListenerList get animationIteration();

  EventListenerList get animationStart();

  EventListenerList get beforeUnload();

  EventListenerList get blur();

  EventListenerList get canPlay();

  EventListenerList get canPlayThrough();

  EventListenerList get change();

  EventListenerList get click();

  EventListenerList get contentLoaded();

  EventListenerList get contextMenu();

  EventListenerList get deviceMotion();

  EventListenerList get deviceOrientation();

  EventListenerList get doubleClick();

  EventListenerList get drag();

  EventListenerList get dragEnd();

  EventListenerList get dragEnter();

  EventListenerList get dragLeave();

  EventListenerList get dragOver();

  EventListenerList get dragStart();

  EventListenerList get drop();

  EventListenerList get durationChange();

  EventListenerList get emptied();

  EventListenerList get ended();

  EventListenerList get error();

  EventListenerList get focus();

  EventListenerList get hashChange();

  EventListenerList get input();

  EventListenerList get invalid();

  EventListenerList get keyDown();

  EventListenerList get keyPress();

  EventListenerList get keyUp();

  EventListenerList get load();

  EventListenerList get loadStart();

  EventListenerList get loadedData();

  EventListenerList get loadedMetadata();

  EventListenerList get message();

  EventListenerList get mouseDown();

  EventListenerList get mouseMove();

  EventListenerList get mouseOut();

  EventListenerList get mouseOver();

  EventListenerList get mouseUp();

  EventListenerList get mouseWheel();

  EventListenerList get offline();

  EventListenerList get online();

  EventListenerList get pageHide();

  EventListenerList get pageShow();

  EventListenerList get pause();

  EventListenerList get play();

  EventListenerList get playing();

  EventListenerList get popState();

  EventListenerList get progress();

  EventListenerList get rateChange();

  EventListenerList get reset();

  EventListenerList get resize();

  EventListenerList get scroll();

  EventListenerList get search();

  EventListenerList get seeked();

  EventListenerList get seeking();

  EventListenerList get select();

  EventListenerList get stalled();

  EventListenerList get storage();

  EventListenerList get submit();

  EventListenerList get suspend();

  EventListenerList get timeUpdate();

  EventListenerList get touchCancel();

  EventListenerList get touchEnd();

  EventListenerList get touchMove();

  EventListenerList get touchStart();

  EventListenerList get transitionEnd();

  EventListenerList get unload();

  EventListenerList get volumeChange();

  EventListenerList get waiting();
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

interface Worker extends AbstractWorker default _WorkerFactoryProvider {

  Worker(String scriptUrl);

  WorkerEvents get on();

  void postMessage(Dynamic message, [List messagePorts]);

  void terminate();

  void webkitPostMessage(Dynamic message, [List messagePorts]);
}

interface WorkerEvents extends AbstractWorkerEvents {

  EventListenerList get message();
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

interface WorkerContext {

  static final int PERSISTENT = 1;

  static final int TEMPORARY = 0;

  final WorkerLocation location;

  final WorkerNavigator navigator;

  EventListener onerror;

  final WorkerContext self;

  final IDBFactory webkitIndexedDB;

  final NotificationCenter webkitNotifications;

  void addEventListener(String type, EventListener listener, [bool useCapture]);

  void clearInterval(int handle);

  void clearTimeout(int handle);

  void close();

  bool dispatchEvent(Event evt);

  void importScripts();

  Database openDatabase(String name, String version, String displayName, int estimatedSize, [DatabaseCallback creationCallback]);

  DatabaseSync openDatabaseSync(String name, String version, String displayName, int estimatedSize, [DatabaseCallback creationCallback]);

  void removeEventListener(String type, EventListener listener, [bool useCapture]);

  int setInterval(TimeoutHandler handler, int timeout);

  int setTimeout(TimeoutHandler handler, int timeout);

  void webkitRequestFileSystem(int type, int size, [FileSystemCallback successCallback, ErrorCallback errorCallback]);

  DOMFileSystemSync webkitRequestFileSystemSync(int type, int size);

  EntrySync webkitResolveLocalFileSystemSyncURL(String url);

  void webkitResolveLocalFileSystemURL(String url, [EntryCallback successCallback, ErrorCallback errorCallback]);
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

interface WorkerLocation {

  final String hash;

  final String host;

  final String hostname;

  final String href;

  final String pathname;

  final String port;

  final String protocol;

  final String search;

  String toString();
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

interface WorkerNavigator {

  final String appName;

  final String appVersion;

  final bool onLine;

  final String platform;

  final String userAgent;
}
// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

interface XMLHttpRequest extends EventTarget default _XMLHttpRequestFactoryProvider {
  // TODO(rnystrom): This name should just be "get" which is valid in Dart, but
  // not correctly implemented yet. (b/4970173)
  XMLHttpRequest.getTEMPNAME(String url, onSuccess(XMLHttpRequest request));

  XMLHttpRequest();

  XMLHttpRequestEvents get on();

  static final int DONE = 4;

  static final int HEADERS_RECEIVED = 2;

  static final int LOADING = 3;

  static final int OPENED = 1;

  static final int UNSENT = 0;

  bool asBlob;

  final int readyState;

  final Object response;

  final Blob responseBlob;

  final String responseText;

  String responseType;

  final Document responseXML;

  final int status;

  final String statusText;

  final XMLHttpRequestUpload upload;

  bool withCredentials;

  void abort();

  String getAllResponseHeaders();

  String getResponseHeader(String header);

  void open(String method, String url, [bool async, String user, String password]);

  void overrideMimeType(String override);

  void send([var data]);

  void setRequestHeader(String header, String value);
}

interface XMLHttpRequestEvents extends Events {

  EventListenerList get abort();

  EventListenerList get error();

  EventListenerList get load();

  EventListenerList get loadEnd();

  EventListenerList get loadStart();

  EventListenerList get progress();

  EventListenerList get readyStateChange();
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

interface XMLHttpRequestException {

  static final int ABORT_ERR = 102;

  static final int NETWORK_ERR = 101;

  final int code;

  final String message;

  final String name;

  String toString();
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

interface XMLHttpRequestProgressEvent extends ProgressEvent {

  final int position;

  final int totalSize;
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

interface XMLHttpRequestUpload extends EventTarget {

  XMLHttpRequestUploadEvents get on();
}

interface XMLHttpRequestUploadEvents extends Events {

  EventListenerList get abort();

  EventListenerList get error();

  EventListenerList get load();

  EventListenerList get loadEnd();

  EventListenerList get loadStart();

  EventListenerList get progress();
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

interface XMLSerializer default _XMLSerializerFactoryProvider {

  XMLSerializer();

  String serializeToString(Node node);
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

interface XPathEvaluator default _XPathEvaluatorFactoryProvider {

  XPathEvaluator();

  XPathExpression createExpression(String expression, XPathNSResolver resolver);

  XPathNSResolver createNSResolver(Node nodeResolver);

  XPathResult evaluate(String expression, Node contextNode, XPathNSResolver resolver, int type, XPathResult inResult);
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

interface XPathException {

  static final int INVALID_EXPRESSION_ERR = 51;

  static final int TYPE_ERR = 52;

  final int code;

  final String message;

  final String name;

  String toString();
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

interface XPathExpression {

  XPathResult evaluate(Node contextNode, int type, XPathResult inResult);
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

interface XPathNSResolver {

  String lookupNamespaceURI(String prefix);
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

interface XPathResult {

  static final int ANY_TYPE = 0;

  static final int ANY_UNORDERED_NODE_TYPE = 8;

  static final int BOOLEAN_TYPE = 3;

  static final int FIRST_ORDERED_NODE_TYPE = 9;

  static final int NUMBER_TYPE = 1;

  static final int ORDERED_NODE_ITERATOR_TYPE = 5;

  static final int ORDERED_NODE_SNAPSHOT_TYPE = 7;

  static final int STRING_TYPE = 2;

  static final int UNORDERED_NODE_ITERATOR_TYPE = 4;

  static final int UNORDERED_NODE_SNAPSHOT_TYPE = 6;

  final bool booleanValue;

  final bool invalidIteratorState;

  final num numberValue;

  final int resultType;

  final Node singleNodeValue;

  final int snapshotLength;

  final String stringValue;

  Node iterateNext();

  Node snapshotItem(int index);
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

interface XSLTProcessor default _XSLTProcessorFactoryProvider {

  XSLTProcessor();

  void clearParameters();

  String getParameter(String namespaceURI, String localName);

  void importStylesheet(Node stylesheet);

  void removeParameter(String namespaceURI, String localName);

  void reset();

  void setParameter(String namespaceURI, String localName, String value);

  Document transformToDocument(Node source);

  DocumentFragment transformToFragment(Node source, Document docVal);
}
// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

typedef void EventListener(Event event);
// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

/**
 * Defines the standard key locations returned by
 * KeyboardEvent.getKeyLocation.
 */
interface KeyLocation {

  /**
   * The event key is not distinguished as the left or right version
   * of the key, and did not originate from the numeric keypad (or did not
   * originate with a virtual key corresponding to the numeric keypad).
   */
  static final int STANDARD = 0;

  /**
   * The event key is in the left key location.
   */
  static final int LEFT = 1;

  /**
   * The event key is in the right key location.
   */
  static final int RIGHT = 2;

  /**
   * The event key originated on the numeric keypad or with a virtual key
   * corresponding to the numeric keypad.
   */
  static final int NUMPAD = 3;

  /**
   * The event key originated on a mobile device, either on a physical
   * keypad or a virtual keyboard.
   */
  static final int MOBILE = 4;

  /**
   * The event key originated on a game controller or a joystick on a mobile
   * device.
   */
  static final int JOYSTICK = 5;
}
// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

/**
 * Defines the standard keyboard identifier names for keys that are returned
 * by KeyEvent.getKeyboardIdentifier when the key does not have a direct
 * unicode mapping.
 */
interface KeyName {

  /** The Accept (Commit, OK) key */
  static final String ACCEPT = "Accept";

  /** The Add key */
  static final String ADD = "Add";

  /** The Again key */
  static final String AGAIN = "Again";

  /** The All Candidates key */
  static final String ALL_CANDIDATES = "AllCandidates";

  /** The Alphanumeric key */
  static final String ALPHANUMERIC = "Alphanumeric";

  /** The Alt (Menu) key */
  static final String ALT = "Alt";

  /** The Alt-Graph key */
  static final String ALT_GRAPH = "AltGraph";

  /** The Application key */
  static final String APPS = "Apps";

  /** The ATTN key */
  static final String ATTN = "Attn";

  /** The Browser Back key */
  static final String BROWSER_BACK = "BrowserBack";

  /** The Browser Favorites key */
  static final String BROWSER_FAVORTIES = "BrowserFavorites";

  /** The Browser Forward key */
  static final String BROWSER_FORWARD = "BrowserForward";

  /** The Browser Home key */
  static final String BROWSER_NAME = "BrowserHome";

  /** The Browser Refresh key */
  static final String BROWSER_REFRESH = "BrowserRefresh";

  /** The Browser Search key */
  static final String BROWSER_SEARCH = "BrowserSearch";

  /** The Browser Stop key */
  static final String BROWSER_STOP = "BrowserStop";

  /** The Camera key */
  static final String CAMERA = "Camera";

  /** The Caps Lock (Capital) key */
  static final String CAPS_LOCK = "CapsLock";

  /** The Clear key */
  static final String CLEAR = "Clear";

  /** The Code Input key */
  static final String CODE_INPUT = "CodeInput";

  /** The Compose key */
  static final String COMPOSE = "Compose";

  /** The Control (Ctrl) key */
  static final String CONTROL = "Control";

  /** The Crsel key */
  static final String CRSEL = "Crsel";

  /** The Convert key */
  static final String CONVERT = "Convert";

  /** The Copy key */
  static final String COPY = "Copy";

  /** The Cut key */
  static final String CUT = "Cut";

  /** The Decimal key */
  static final String DECIMAL = "Decimal";

  /** The Divide key */
  static final String DIVIDE = "Divide";

  /** The Down Arrow key */
  static final String DOWN = "Down";

  /** The diagonal Down-Left Arrow key */
  static final String DOWN_LEFT = "DownLeft";

  /** The diagonal Down-Right Arrow key */
  static final String DOWN_RIGHT = "DownRight";

  /** The Eject key */
  static final String EJECT = "Eject";

  /** The End key */
  static final String END = "End";

  /**
   * The Enter key. Note: This key value must also be used for the Return
   *  (Macintosh numpad) key
   */
  static final String ENTER = "Enter";

  /** The Erase EOF key */
  static final String ERASE_EOF= "EraseEof";

  /** The Execute key */
  static final String EXECUTE = "Execute";

  /** The Exsel key */
  static final String EXSEL = "Exsel";

  /** The Function switch key */
  static final String FN = "Fn";

  /** The F1 key */
  static final String F1 = "F1";

  /** The F2 key */
  static final String F2 = "F2";

  /** The F3 key */
  static final String F3 = "F3";

  /** The F4 key */
  static final String F4 = "F4";

  /** The F5 key */
  static final String F5 = "F5";

  /** The F6 key */
  static final String F6 = "F6";

  /** The F7 key */
  static final String F7 = "F7";

  /** The F8 key */
  static final String F8 = "F8";

  /** The F9 key */
  static final String F9 = "F9";

  /** The F10 key */
  static final String F10 = "F10";

  /** The F11 key */
  static final String F11 = "F11";

  /** The F12 key */
  static final String F12 = "F12";

  /** The F13 key */
  static final String F13 = "F13";

  /** The F14 key */
  static final String F14 = "F14";

  /** The F15 key */
  static final String F15 = "F15";

  /** The F16 key */
  static final String F16 = "F16";

  /** The F17 key */
  static final String F17 = "F17";

  /** The F18 key */
  static final String F18 = "F18";

  /** The F19 key */
  static final String F19 = "F19";

  /** The F20 key */
  static final String F20 = "F20";

  /** The F21 key */
  static final String F21 = "F21";

  /** The F22 key */
  static final String F22 = "F22";

  /** The F23 key */
  static final String F23 = "F23";

  /** The F24 key */
  static final String F24 = "F24";

  /** The Final Mode (Final) key used on some asian keyboards */
  static final String FINAL_MODE = "FinalMode";

  /** The Find key */
  static final String FIND = "Find";

  /** The Full-Width Characters key */
  static final String FULL_WIDTH = "FullWidth";

  /** The Half-Width Characters key */
  static final String HALF_WIDTH = "HalfWidth";

  /** The Hangul (Korean characters) Mode key */
  static final String HANGUL_MODE = "HangulMode";

  /** The Hanja (Korean characters) Mode key */
  static final String HANJA_MODE = "HanjaMode";

  /** The Help key */
  static final String HELP = "Help";

  /** The Hiragana (Japanese Kana characters) key */
  static final String HIRAGANA = "Hiragana";

  /** The Home key */
  static final String HOME = "Home";

  /** The Insert (Ins) key */
  static final String INSERT = "Insert";

  /** The Japanese-Hiragana key */
  static final String JAPANESE_HIRAGANA = "JapaneseHiragana";

  /** The Japanese-Katakana key */
  static final String JAPANESE_KATAKANA = "JapaneseKatakana";

  /** The Japanese-Romaji key */
  static final String JAPANESE_ROMAJI = "JapaneseRomaji";

  /** The Junja Mode key */
  static final String JUNJA_MODE = "JunjaMode";

  /** The Kana Mode (Kana Lock) key */
  static final String KANA_MODE = "KanaMode";

  /**
   * The Kanji (Japanese name for ideographic characters of Chinese origin)
   * Mode key
   */
  static final String KANJI_MODE = "KanjiMode";

  /** The Katakana (Japanese Kana characters) key */
  static final String KATAKANA = "Katakana";

  /** The Start Application One key */
  static final String LAUNCH_APPLICATION_1 = "LaunchApplication1";

  /** The Start Application Two key */
  static final String LAUNCH_APPLICATION_2 = "LaunchApplication2";

  /** The Start Mail key */
  static final String LAUNCH_MAIL = "LaunchMail";

  /** The Left Arrow key */
  static final String LEFT = "Left";

  /** The Menu key */
  static final String MENU = "Menu";

  /**
   * The Meta key. Note: This key value shall be also used for the Apple
   * Command key
   */
  static final String META = "Meta";

  /** The Media Next Track key */
  static final String MEDIA_NEXT_TRACK = "MediaNextTrack";

  /** The Media Play Pause key */
  static final String MEDIA_PAUSE_PLAY = "MediaPlayPause";

  /** The Media Previous Track key */
  static final String MEDIA_PREVIOUS_TRACK = "MediaPreviousTrack";

  /** The Media Stop key */
  static final String MEDIA_STOP = "MediaStop";

  /** The Mode Change key */
  static final String MODE_CHANGE = "ModeChange";

  /** The Next Candidate function key */
  static final String NEXT_CANDIDATE = "NextCandidate";

  /** The Nonconvert (Don't Convert) key */
  static final String NON_CONVERT = "Nonconvert";

  /** The Number Lock key */
  static final String NUM_LOCK = "NumLock";

  /** The Page Down (Next) key */
  static final String PAGE_DOWN = "PageDown";

  /** The Page Up key */
  static final String PAGE_UP = "PageUp";

  /** The Paste key */
  static final String PASTE = "Paste";

  /** The Pause key */
  static final String PAUSE = "Pause";

  /** The Play key */
  static final String PLAY = "Play";

  /**
   * The Power key. Note: Some devices may not expose this key to the
   * operating environment
   */
  static final String POWER = "Power";

  /** The Previous Candidate function key */
  static final String PREVIOUS_CANDIDATE = "PreviousCandidate";

  /** The Print Screen (PrintScrn, SnapShot) key */
  static final String PRINT_SCREEN = "PrintScreen";

  /** The Process key */
  static final String PROCESS = "Process";

  /** The Props key */
  static final String PROPS = "Props";

  /** The Right Arrow key */
  static final String RIGHT = "Right";

  /** The Roman Characters function key */
  static final String ROMAN_CHARACTERS = "RomanCharacters";

  /** The Scroll Lock key */
  static final String SCROLL = "Scroll";

  /** The Select key */
  static final String SELECT = "Select";

  /** The Select Media key */
  static final String SELECT_MEDIA = "SelectMedia";

  /** The Separator key */
  static final String SEPARATOR = "Separator";

  /** The Shift key */
  static final String SHIFT = "Shift";

  /** The Soft1 key */
  static final String SOFT_1 = "Soft1";

  /** The Soft2 key */
  static final String SOFT_2 = "Soft2";

  /** The Soft3 key */
  static final String SOFT_3 = "Soft3";

  /** The Soft4 key */
  static final String SOFT_4 = "Soft4";

  /** The Stop key */
  static final String STOP = "Stop";

  /** The Subtract key */
  static final String SUBTRACT = "Subtract";

  /** The Symbol Lock key */
  static final String SYMBOL_LOCK = "SymbolLock";

  /** The Up Arrow key */
  static final String UP = "Up";

  /** The diagonal Up-Left Arrow key */
  static final String UP_LEFT = "UpLeft";

  /** The diagonal Up-Right Arrow key */
  static final String UP_RIGHT = "UpRight";

  /** The Undo key */
  static final String UNDO = "Undo";

  /** The Volume Down key */
  static final String VOLUME_DOWN = "VolumeDown";

  /** The Volume Mute key */
  static final String VOLUMN_MUTE = "VolumeMute";

  /** The Volume Up key */
  static final String VOLUMN_UP = "VolumeUp";

  /** The Windows Logo key */
  static final String WIN = "Win";

  /** The Zoom key */
  static final String ZOOM = "Zoom";

  /**
   * The Backspace (Back) key. Note: This key value shall be also used for the
   * key labeled 'delete' MacOS keyboards when not modified by the 'Fn' key
   */
  static final String BACKSPACE = "Backspace";

  /** The Horizontal Tabulation (Tab) key */
  static final String TAB = "Tab";

  /** The Cancel key */
  static final String CANCEL = "Cancel";

  /** The Escape (Esc) key */
  static final String ESC = "Esc";

  /** The Space (Spacebar) key:   */
  static final String SPACEBAR = "Spacebar";

  /**
   * The Delete (Del) Key. Note: This key value shall be also used for the key
   * labeled 'delete' MacOS keyboards when modified by the 'Fn' key
   */
  static final String DEL = "Del";

  /** The Combining Grave Accent (Greek Varia, Dead Grave) key */
  static final String DEAD_GRAVE = "DeadGrave";

  /**
   * The Combining Acute Accent (Stress Mark, Greek Oxia, Tonos, Dead Eacute)
   * key
   */
  static final String DEAD_EACUTE = "DeadEacute";

  /** The Combining Circumflex Accent (Hat, Dead Circumflex) key */
  static final String DEAD_CIRCUMFLEX = "DeadCircumflex";

  /** The Combining Tilde (Dead Tilde) key */
  static final String DEAD_TILDE = "DeadTilde";

  /** The Combining Macron (Long, Dead Macron) key */
  static final String DEAD_MACRON = "DeadMacron";

  /** The Combining Breve (Short, Dead Breve) key */
  static final String DEAD_BREVE = "DeadBreve";

  /** The Combining Dot Above (Derivative, Dead Above Dot) key */
  static final String DEAD_ABOVE_DOT = "DeadAboveDot";

  /**
   * The Combining Diaeresis (Double Dot Abode, Umlaut, Greek Dialytika,
   * Double Derivative, Dead Diaeresis) key
   */
  static final String DEAD_UMLAUT = "DeadUmlaut";

  /** The Combining Ring Above (Dead Above Ring) key */
  static final String DEAD_ABOVE_RING = "DeadAboveRing";

  /** The Combining Double Acute Accent (Dead Doubleacute) key */
  static final String DEAD_DOUBLEACUTE = "DeadDoubleacute";

  /** The Combining Caron (Hacek, V Above, Dead Caron) key */
  static final String DEAD_CARON = "DeadCaron";

  /** The Combining Cedilla (Dead Cedilla) key */
  static final String DEAD_CEDILLA = "DeadCedilla";

  /** The Combining Ogonek (Nasal Hook, Dead Ogonek) key */
  static final String DEAD_OGONEK = "DeadOgonek";

  /**
   * The Combining Greek Ypogegrammeni (Greek Non-Spacing Iota Below, Iota
   * Subscript, Dead Iota) key
   */
  static final String DEAD_IOTA = "DeadIota";

  /**
   * The Combining Katakana-Hiragana Voiced Sound Mark (Dead Voiced Sound) key
   */
  static final String DEAD_VOICED_SOUND = "DeadVoicedSound";

  /**
   * The Combining Katakana-Hiragana Semi-Voiced Sound Mark (Dead Semivoiced
   * Sound) key
   */
  static final String DEC_SEMIVOICED_SOUND= "DeadSemivoicedSound";

  /**
   * Key value used when an implementation is unable to identify another key
   * value, due to either hardware, platform, or software constraints
   */
  static final String UNIDENTIFIED = "Unidentified";
}
// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

/**
 * Contains the set of standard values returned by HTMLDocument.getReadyState.
 */
interface ReadyState {
  /**
   * Indicates the document is still loading and parsing.
   */
  static final String LOADING = "loading";

  /**
   * Indicates the document is finished parsing but is still loading
   * subresources.
   */
  static final String INTERACTIVE = "interactive";

  /**
   * Indicates the document and all subresources have been loaded.
   */
  static final String COMPLETE = "complete";
}
// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

typedef void TimeoutHandler();
// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

/**
 * The [Collections] class implements static methods useful when
 * writing a class that implements [Collection] and the [iterator]
 * method.
 */
class _Collections {
  static void forEach(Iterable<Object> iterable, void f(Object o)) {
    for (final e in iterable) {
      f(e);
    }
  }

  static List map(Iterable<Object> source,
                  List<Object> destination,
                  f(o)) {
    for (final e in source) {
      destination.add(f(e));
    }
    return destination;
  }

  static bool some(Iterable<Object> iterable, bool f(Object o)) {
    for (final e in iterable) {
      if (f(e)) return true;
    }
    return false;
  }

  static bool every(Iterable<Object> iterable, bool f(Object o)) {
    for (final e in iterable) {
      if (!f(e)) return false;
    }
    return true;
  }

  static List filter(Iterable<Object> source,
                     List<Object> destination,
                     bool f(o)) {
    for (final e in source) {
      if (f(e)) destination.add(e);
    }
    return destination;
  }

  static bool isEmpty(Iterable<Object> iterable) {
    return !iterable.iterator().hasNext();
  }
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

class _XMLHttpRequestUtils {

  // Helper for factory XMLHttpRequest.getTEMPNAME
  static XMLHttpRequest getTEMPNAME(String url,
                                    onSuccess(XMLHttpRequest request)) {
    final request = new XMLHttpRequest();
    request.open('GET', url, true);

    // TODO(terry): Validate after client login added if necessary to forward
    //              cookies to server.
    request.withCredentials = true;

    // Status 0 is for local XHR request.
    request.on.readyStateChange.add((e) {
      if (request.readyState == XMLHttpRequest.DONE &&
          (request.status == 200 || request.status == 0)) {
        onSuccess(request);
      }
    });

    request.send();

    return request;
  }
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

class _TextFactoryProvider {

  factory Text(String data) => _document._createTextNode(data);
}

class _EventFactoryProvider {
  factory Event(String type, [bool canBubble = true,
      bool cancelable = true]) {
    final _EventImpl e = _document._createEvent("Event");
    e._initEvent(type, canBubble, cancelable);
    return e;
  }
}

class _MouseEventFactoryProvider {
  factory MouseEvent(String type, Window view, int detail,
      int screenX, int screenY, int clientX, int clientY, int button,
      [bool canBubble = true, bool cancelable = true, bool ctrlKey = false,
      bool altKey = false, bool shiftKey = false, bool metaKey = false,
      EventTarget relatedTarget = null]) {
    final e = _document._createEvent("MouseEvent");
    e._initMouseEvent(type, canBubble, cancelable, view, detail,
        screenX, screenY, clientX, clientY, ctrlKey, altKey, shiftKey, metaKey,
        button, relatedTarget);
    return e;
  }
}

class _CSSStyleDeclarationFactoryProvider {
  factory CSSStyleDeclaration.css(String css) {
    final style = new Element.tag('div').style;
    style.cssText = css;
    return style;
  } 

  factory CSSStyleDeclaration() {
    return new CSSStyleDeclaration.css('');
  }
}

final _START_TAG_REGEXP = const RegExp('<(\\w+)');
class _ElementFactoryProvider {
  static final _CUSTOM_PARENT_TAG_MAP = const {
    'body' : 'html',
    'head' : 'html',
    'caption' : 'table',
    'td': 'tr',
    'colgroup': 'table',
    'col' : 'colgroup',
    'tr' : 'tbody',
    'tbody' : 'table',
    'tfoot' : 'table',
    'thead' : 'table',
    'track' : 'audio',
  };

  /** @domName Document.createElement */
  factory Element.html(String html) {
    // TODO(jacobr): this method can be made more robust and performant.
    // 1) Cache the dummy parent elements required to use innerHTML rather than
    //    creating them every call.
    // 2) Verify that the html does not contain leading or trailing text nodes.
    // 3) Verify that the html does not contain both <head> and <body> tags.
    // 4) Detatch the created element from its dummy parent.
    String parentTag = 'div';
    String tag;
    final match = _START_TAG_REGEXP.firstMatch(html);
    if (match !== null) {
      tag = match.group(1).toLowerCase();
      if (_CUSTOM_PARENT_TAG_MAP.containsKey(tag)) {
        parentTag = _CUSTOM_PARENT_TAG_MAP[tag];
      }
    }
    final _ElementImpl temp = new Element.tag(parentTag);
    temp.innerHTML = html;

    Element element;
    if (temp.elements.length == 1) {
      element = temp.elements.first;
    } else if (parentTag == 'html' && temp.elements.length == 2) {
      // Work around for edge case in WebKit and possibly other browsers where
      // both body and head elements are created even though the inner html
      // only contains a head or body element.
      element = temp.elements[tag == 'head' ? 0 : 1];
    } else {
      throw new IllegalArgumentException('HTML had ${temp.elements.length} ' +
          'top level elements but 1 expected');
    }
    element.remove();
    return element;
  }

  /** @domName Document.createElement */
  factory Element.tag(String tag) => _document._createElement(tag);
}

class _DocumentFragmentFactoryProvider {
  /** @domName Document.createDocumentFragment */
  factory DocumentFragment() => document.createDocumentFragment();

  factory DocumentFragment.html(String html) {
    final fragment = new DocumentFragment();
    fragment.innerHTML = html;
    return fragment;
  }

  // TODO(nweiz): enable this when XML is ported.
  // factory DocumentFragment.xml(String xml) {
  //   final fragment = new DocumentFragment();
  //   final e = new XMLElement.tag("xml");
  //   e.innerHTML = xml;
  //
  //   // Copy list first since we don't want liveness during iteration.
  //   final List nodes = new List.from(e.nodes);
  //   fragment.nodes.addAll(nodes);
  //   return fragment;
  // }

  factory DocumentFragment.svg(String svg) {
    final fragment = new DocumentFragment();
    final e = new SVGSVGElement();
    e.innerHTML = svg;

    // Copy list first since we don't want liveness during iteration.
    final List nodes = new List.from(e.nodes);
    fragment.nodes.addAll(nodes);
    return fragment;
  }
}

class _SVGElementFactoryProvider {
  factory SVGElement.tag(String tag) {
    final Element temp =
      _document._createElementNS("http://www.w3.org/2000/svg", tag);
    return temp;
  }

  factory SVGElement.svg(String svg) {
    Element parentTag;
    final match = _START_TAG_REGEXP.firstMatch(svg);
    if (match != null && match.group(1).toLowerCase() == 'svg') {
      parentTag = new Element.tag('div');
    } else {
      parentTag = new SVGSVGElement();
    }

    parentTag.innerHTML = svg;
    if (parentTag.elements.length == 1) return parentTag.nodes.removeLast();

    throw new IllegalArgumentException('SVG had ${parentTag.elements.length} ' +
        'top-level elements but 1 expected');
  }
}

class _SVGSVGElementFactoryProvider {
  factory SVGSVGElement() {
    final el = new SVGElement.tag("svg");
    // The SVG spec requires the version attribute to match the spec version
    el.attributes['version'] = "1.1";
    return el;
  }
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

class _AudioContextFactoryProvider {
  factory AudioContext() => _wrap(new dom.AudioContext());
}

class _TypedArrayFactoryProvider {

  factory Float32Array(int length) => _F32(length);
  factory Float32Array.fromList(List<num> list) => _F32(ensureNative(list));
  factory Float32Array.fromBuffer(ArrayBuffer buffer) => _F32(buffer);

  factory Float64Array(int length) => _F64(length);
  factory Float64Array.fromList(List<num> list) => _F64(ensureNative(list));
  factory Float64Array.fromBuffer(ArrayBuffer buffer) => _F64(buffer);

  factory Int8Array(int length) => _I8(length);
  factory Int8Array.fromList(List<num> list) => _I8(ensureNative(list));
  factory Int8Array.fromBuffer(ArrayBuffer buffer) => _I8(buffer);

  factory Int16Array(int length) => _I16(length);
  factory Int16Array.fromList(List<num> list) => _I16(ensureNative(list));
  factory Int16Array.fromBuffer(ArrayBuffer buffer) => _I16(buffer);

  factory Int32Array(int length) => _I32(length);
  factory Int32Array.fromList(List<num> list) => _I32(ensureNative(list));
  factory Int32Array.fromBuffer(ArrayBuffer buffer) => _I32(buffer);

  factory Uint8Array(int length) => _U8(length);
  factory Uint8Array.fromList(List<num> list) => _U8(ensureNative(list));
  factory Uint8Array.fromBuffer(ArrayBuffer buffer) => _U8(buffer);

  factory Uint16Array(int length) => _U16(length);
  factory Uint16Array.fromList(List<num> list) => _U16(ensureNative(list));
  factory Uint16Array.fromBuffer(ArrayBuffer buffer) => _U16(buffer);

  factory Uint32Array(int length) => _U32(length);
  factory Uint32Array.fromList(List<num> list) => _U32(ensureNative(list));
  factory Uint32Array.fromBuffer(ArrayBuffer buffer) => _U32(buffer);

  factory Uint8ClampedArray(int length) => _U8C(length);
  factory Uint8ClampedArray.fromList(List<num> list) => _U8C(ensureNative(list));
  factory Uint8ClampedArray.fromBuffer(ArrayBuffer buffer) => _U8C(buffer);

  static Float32Array _F32(arg) => _wrap(new dom.Float32Array(arg));
  static Float64Array _F64(arg) => _wrap(new dom.Float64Array(arg));
  static Int8Array _I8(arg) => _wrap(new dom.Int8Array(arg));
  static Int16Array _I16(arg) => _wrap(new dom.Int16Array(arg));
  static Int32Array _I32(arg) => _wrap(new dom.Int32Array(arg));
  static Uint8Array _U8(arg) => _wrap(new dom.Uint8Array(arg));
  static Uint16Array _U16(arg) => _wrap(new dom.Uint16Array(arg));
  static Uint32Array _U32(arg) => _wrap(new dom.Uint32Array(arg));
  static Uint8ClampedArray _U8C(arg) => _wrap(new dom.Uint8ClampedArray(arg));

  static ensureNative(List list) => list;  // TODO: make sure.
}

class _PointFactoryProvider {

  factory Point(num x, num y) => _wrap(new dom.WebKitPoint(x, y));
}

class _WebSocketFactoryProvider {

  factory WebSocket(String url) => _wrap(new dom.WebSocket(url));
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

typedef Object ComputeValue();

class _MeasurementRequest<T> {
  final ComputeValue computeValue;
  final Completer<T> completer;
  Object value;
  bool exception = false;
  _MeasurementRequest(this.computeValue, this.completer);
}

final _MEASUREMENT_MESSAGE = "DART-MEASURE";
List<_MeasurementRequest> _pendingRequests;
List<TimeoutHandler> _pendingMeasurementFrameCallbacks;
bool _nextMeasurementFrameScheduled = false;
bool _firstMeasurementRequest = true;

void _maybeScheduleMeasurementFrame() {
  if (_nextMeasurementFrameScheduled) return;

  _nextMeasurementFrameScheduled = true;
  // postMessage gives us a way to receive a callback after the current
  // event listener has unwound but before the browser has repainted.
  if (_firstMeasurementRequest) {
    // Messages from other windows do not cause a security risk as
    // all we care about is that _onCompleteMeasurementRequests is called
    // after the current event loop is unwound and calling the function is
    // a noop when zero requests are pending.
    window.on.message.add((e) => _completeMeasurementFutures());
    _firstMeasurementRequest = false;
  }

  // TODO(jacobr): other mechanisms such as setImmediate and
  // requestAnimationFrame may work better of platforms that support them.
  // The key is we need a way to execute code immediately after the current
  // event listener queue unwinds.
  window.postMessage(_MEASUREMENT_MESSAGE, "*");
}

/**
 * Registers a [callback] which is called after the next batch of measurements
 * completes. Even if no measurements completed, the callback is triggered
 * when they would have completed to avoid confusing bugs if it happened that
 * no measurements were actually requested.
 */
void _addMeasurementFrameCallback(TimeoutHandler callback) {
  if (_pendingMeasurementFrameCallbacks === null) {
    _pendingMeasurementFrameCallbacks = <TimeoutHandler>[];
    _maybeScheduleMeasurementFrame();
  }
  _pendingMeasurementFrameCallbacks.add(callback);
}

/**
 * Returns a [Future] whose value will be the result of evaluating
 * [computeValue] during the next safe measurement interval.
 * The next safe measurement interval is after the current event loop has
 * unwound but before the browser has rendered the page.
 * It is important that the [computeValue] function only queries the html
 * layout and html in any way.
 */
Future _createMeasurementFuture(ComputeValue computeValue,
                                Completer completer) {
  if (_pendingRequests === null) {
    _pendingRequests = <_MeasurementRequest>[];
    _maybeScheduleMeasurementFrame();
  }
  _pendingRequests.add(new _MeasurementRequest(computeValue, completer));
  return completer.future;
}

/**
 * Complete all pending measurement futures evaluating them in a single batch
 * so that the the browser is guaranteed to avoid multiple layouts.
 */
void _completeMeasurementFutures() {
  if (_nextMeasurementFrameScheduled == false) {
    // Ignore spurious call to this function.
    return;
  }

  _nextMeasurementFrameScheduled = false;
  // We must compute all new values before fulfilling the futures as
  // the onComplete callbacks for the futures could modify the DOM making
  // subsequent measurement calculations expensive to compute.
  if (_pendingRequests !== null) {
    for (_MeasurementRequest request in _pendingRequests) {
      try {
        request.value = request.computeValue();
      } catch(var e) {
        request.value = e;
        request.exception = true;
      }
    }
  }

  final completedRequests = _pendingRequests;
  final readyMeasurementFrameCallbacks = _pendingMeasurementFrameCallbacks;
  _pendingRequests = null;
  _pendingMeasurementFrameCallbacks = null;
  if (completedRequests !== null) {
    for (_MeasurementRequest request in completedRequests) {
      if (request.exception) {
        request.completer.completeException(request.value);
      } else {
        request.completer.complete(request.value);
      }
    }
  }

  if (readyMeasurementFrameCallbacks !== null) {
    for (TimeoutHandler handler in readyMeasurementFrameCallbacks) {
      // TODO(jacobr): wrap each call to a handler in a try-catch block.
      handler();
    }
  }
}
// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

/**
 * Utils for device detection.
 */
class _Device {
  /**
   * Gets the browser's user agent. Using this function allows tests to inject
   * the user agent.
   * Returns the user agent.
   */
  static String get userAgent() => window.navigator.userAgent;

  /**
   * Determines if the current device is running Firefox.
   */
  static bool get isFirefox() => userAgent.contains("Firefox", 0);
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// TODO(rnystrom): add a way to supress public classes from DartDoc output.
/**
 * This class is intended for testing purposes only.
 */
class Testing {
  static void addEventListener(EventTarget target, String type, EventListener listener, bool useCapture) {
    final _EventTargetImpl targetImpl = target;
    targetImpl._addEventListener(type, listener, useCapture);
  }
  static void removeEventListener(EventTarget target, String type, EventListener listener, bool useCapture) {
    final _EventTargetImpl targetImpl = target;
    targetImpl._removeEventListener(type, listener, useCapture);
  }

}// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

class _DOMTypeBase {
  final _ptr;

  _DOMTypeBase._wrap(this._ptr) {
  	// We should never be creating duplicate wrappers.
  	// TODO(jacobr): this boolean value is evaluated outside of the assert
  	// to work around a mysterious and flaky bug in tip of trunk versions of
  	// chrome.
  	bool hasExistingWrapper = _ptr.dartObjectLocalStorage === null;
  	assert(hasExistingWrapper);
	  _ptr.dartObjectLocalStorage = this;
  }
}

/** This function is provided for unittest purposes only. */
unwrapDomObject(_DOMTypeBase wrapper) {
  return wrapper._ptr;
}// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// Iterator for arrays with fixed size.
class _FixedSizeListIterator<T> extends _VariableSizeListIterator<T> {
  _FixedSizeListIterator(List<T> array)
      : super(array),
        _length = array.length;

  bool hasNext() => _length > _pos;

  final int _length;  // Cache array length for faster access.
}

// Iterator for arrays with variable size.
class _VariableSizeListIterator<T> implements Iterator<T> {
  _VariableSizeListIterator(List<T> array)
      : _array = array,
        _pos = 0;

  bool hasNext() => _array.length > _pos;

  T next() {
    if (!hasNext()) {
      throw const NoMoreElementsException();
    }
    return _array[_pos++];
  }

  final List<T> _array;
  int _pos;
}
// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

class _Lists {

  /**
   * Returns the index in the array [a] of the given [element], starting
   * the search at index [startIndex] to [endIndex] (exclusive).
   * Returns -1 if [element] is not found.
   */
  static int indexOf(List a,
                     Object element,
                     int startIndex,
                     int endIndex) {
    if (startIndex >= a.length) {
      return -1;
    }
    if (startIndex < 0) {
      startIndex = 0;
    }
    for (int i = startIndex; i < endIndex; i++) {
      if (a[i] == element) {
        return i;
      }
    }
    return -1;
  }

  /**
   * Returns the last index in the array [a] of the given [element], starting
   * the search at index [startIndex] to 0.
   * Returns -1 if [element] is not found.
   */
  static int lastIndexOf(List a, Object element, int startIndex) {
    if (startIndex < 0) {
      return -1;
    }
    if (startIndex >= a.length) {
      startIndex = a.length - 1;
    }
    for (int i = startIndex; i >= 0; i--) {
      if (a[i] == element) {
        return i;
      }
    }
    return -1;
  }

  /**
   * Returns a sub list copy of this list, from [start] to
   * [:start + length:].
   * Returns an empty list if [length] is 0.
   * Throws an [IllegalArgumentException] if [length] is negative.
   * Throws an [IndexOutOfRangeException] if [start] or
   * [:start + length:] are out of range.
   */
  static List getRange(List a, int start, int length, List accumulator) {
    if (length < 0) throw new IllegalArgumentException('length');
    if (start < 0) throw new IndexOutOfRangeException(start);
    int end = start + length;
    if (end > a.length) throw new IndexOutOfRangeException(end);
    for (int i = start; i < end; i++) {
      accumulator.add(a[i]);
    }
    return accumulator;
  }
}
